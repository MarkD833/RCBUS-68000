00007F78 Starting Address
Assembler used: EASy68K Editor/Assembler v5.16.01
Created On: 09/05/2025 17:19:03

00000000                             1  *******************************************************************************
00000000                             2  * rcMon-68k v1.3
00000000                             3  *******************************************************************************
00000000                             4  * Written to support my own RCBus 68000 board. Supports simple S-Record loading as
00000000                             5  * well as memory display & modification. No breakpoints, single stepping or
00000000                             6  * disassembly stuff.
00000000                             7  *
00000000                             8  * ROM : 128K organised as 64K  x 16bits (2x W27C512 EEPROM)
00000000                             9  * RAM : 1M   organised as 512K x 16bits (2x AS6C4008)
00000000                            10  *
00000000                            11  * ROM starts at 0x000000 up to 0x01FFFF (128K)
00000000                            12  * RAM starts at 0x100000 up to 0x1FFFFF (1M)
00000000                            13  *
00000000                            14  * Use EASyBIN to split the S-Record into ODD and EVEN bytes.
00000000                            15  * The *_0.BIN file goes in the U ROM socket - holding D08..D15
00000000                            16  * The *_1.BIN file goes in the L ROM socket - holding D00..D07
00000000                            17  *
00000000                            18  *******************************************************************************
00000000                            19  * Exception Handling
00000000                            20  *******************************************************************************
00000000                            21  * ROM starts at $0000 and holds the exception vector table. The table entries
00000000                            22  * each jump to a small routine that gets the handler address from the start of
00000000                            23  * RAM (or wherever VEC_BASE is defined) and re-directs execution to that address.
00000000                            24  * Initially the RAM addresses all point back to handlers in ROM but can be
00000000                            25  * overwritten to point to a user supplied handler in RAM. 
00000000                            26  *
00000000                            27  * BUS ERROR & ADDRESS ERROR handlers always use the ROM vector table addresses.
00000000                            28  * Some Easy68k TRAP #15 text I/O routines are implemented as follows:
00000000                            29  * Currently only tasks 0,1,5,6,13 & 14 are supported.
00000000                            30  *******************************************************************************
00000000                            31  * CP/M-68K Support
00000000                            32  * V1.3 of CP/M-68K is now supported. The CPM400 s-record file should be
00000000                            33  * programmed into the EEPROMs at the same time as this monitor. CP/M will
00000000                            34  * reside at address 0x0400 onwards.
00000000                            35  *
00000000                            36  * The hardware specific BIOS should also be programmed into the EEPROMs. The
00000000                            37  * BIOS must reside at address 0x6000 onwards. 
00000000                            38  *******************************************************************************
00000000                            39  
00000000                            40      INCLUDE "..\asm-inc\memory.inc"
00000000                            41  
00000000  =00007000                 42  MON_BASE        EQU     $7000
00000000                            43  
00000000  =00009000                 44  EHBASIC_BASE    EQU     $9000
00000000                            45  
00000000  =00100000                 46  RAM_BASE        EQU     $100000
00000000  =00100000                 47  RAM_LEN         EQU     $100000
00000000                            48  
00000000  =00100000                 49  VEC_BASE        EQU     RAM_BASE
00000000  =00000400                 50  VEC_SIZE        EQU     $400         * table takes up 1024 bytes
00000000                            51  
00000000  =00F80000                 52  IO_BASE         EQU     $F80000     * I/O space base address = 00F8_0000
00000000                            53  
00000000  =00F00000                 54  MEM_BASE        EQU     $F00000     * Mem space base address = 00F0_0000
00000000                            55  
00000000  =00000400                 56  CPM_BASE        EQU     $0400       * CP/M-68K entry point
00000000                            57  
00000000  =001FD800                 58  CCP_BSS_BASE    EQU     $1FD800
00000000  =00001000                 59  CCP_PRIV        EQU     4096
00000000                            60  
00000000  =00000800                 61  MON_PRIV        EQU     2048
00000000                            62  
00000000  =00001000                 63  BIOS_PRIV       EQU     4096
00000000                            64  
00000000  =001FF800                 65  STACK_START     EQU     RAM_BASE+RAM_LEN-MON_PRIV
00000000  =001FF800                 66  -------------------- end include --------------------
00000000                            67      INCLUDE "..\asm-inc\devices.inc"
00000000                            68  
00000000  =00D00000                 69  DUART1      EQU     $D00000
00000000                            70  
00000000  =00000010                 71  SC145ADDR   EQU     $10           * SC145 base address is 0x10
00000000                            72  
00000000  =00F80020                 73  SC145       EQU     IO_BASE+(SC145ADDR<<1)
00000000                            74  
00000000                            75  
00000000  =00D00001                 76  MRA         EQU DUART1+1           * Mode Register A             (R/W)
00000000  =00D00003                 77  SRA         EQU DUART1+3           * Status Register A           (R)
00000000  =00D00003                 78  CSRA        EQU DUART1+3           * Clock Select Register A     (W)
00000000  =00D00005                 79  CRA         EQU DUART1+5           * Commands Register A         (W)
00000000  =00D00007                 80  RBA         EQU DUART1+7           * Receiver Buffer A           (R)
00000000  =00D00007                 81  TBA         EQU DUART1+7           * Transmitter Buffer A        (W)
00000000  =00D00009                 82  ACR         EQU DUART1+9           * Aux. Control Register       (R/W)
00000000  =00D0000B                 83  ISR         EQU DUART1+11          * Interrupt Status Register   (R)
00000000  =00D0000B                 84  IMR         EQU DUART1+11          * Interrupt Mask Register     (W)
00000000  =00D00011                 85  MRB         EQU DUART1+17          * Mode Register B             (R/W)
00000000  =00D00013                 86  SRB         EQU DUART1+19          * Status Register B           (R)
00000000  =00D00013                 87  CSRB        EQU DUART1+19          * Clock Select Register B     (W)
00000000  =00D00015                 88  CRB         EQU DUART1+21          * Commands Register B         (W)
00000000  =00D00017                 89  RBB         EQU DUART1+23          * Reciever Buffer B           (R)
00000000  =00D00017                 90  TBB         EQU DUART1+23          * Transmitter Buffer B        (W)
00000000  =00D00019                 91  IVR         EQU DUART1+25          * Interrupt Vector Register   (R/W)
00000000  =00D0001B                 92  IPR         EQU DUART1+27          * Input Port Register         (R)
00000000  =00D0001B                 93  OPCR        EQU DUART1+27          * Output Port Config Register (W)
00000000  =00D0001D                 94  BCNT        EQU DUART1+29          * Start Counter               (R)
00000000  =00D0001D                 95  SOPR        EQU DUART1+29          * Set Output Port Register    (W)
00000000  =00D0001F                 96  ECNT        EQU DUART1+31          * Stop Counter                (R)
00000000  =00D0001F                 97  ROPR        EQU DUART1+31          * Reset Output Port Register  (W)
00000000                            98  
00000000  =00000066                 99  BAUD_1200       EQU     $66         * 1200 baud
00000000  =00000088                100  BAUD_2400       EQU     $88         * 2400 baud
00000000  =00000099                101  BAUD_4800       EQU     $99         * 4800 baud
00000000  =000000BB                102  BAUD_9600       EQU     $BB         * 9600 baud
00000000  =000000CC                103  BAUD_38400      EQU     $CC         * 38400 baud
00000000                           104  
00000000  =000000CC                105  BAUD_RATE       EQU     BAUD_38400
00000000                           106  
00000000  =00F80021                107  CF_DATA     EQU SC145+1           * Data               (R/W)
00000000  =00F80023                108  CF_FEATURES EQU SC145+3           * Features           (W)
00000000  =00F80023                109  CF_ERROR    EQU SC145+3           * Error              (R)
00000000  =00F80025                110  CF_SECCOUNT EQU SC145+5           * Sector Count       (R/W)
00000000  =00F80027                111  CF_SECTOR   EQU SC145+7           * Sector Number      (R/W)
00000000  =00F80029                112  CF_CYL_LOW  EQU SC145+9           * Cylinder Low Byte  (R/W) 
00000000  =00F8002B                113  CF_CYL_HI   EQU SC145+11          * Cylinder High Byte (R/W)
00000000  =00F8002D                114  CF_HEAD     EQU SC145+13          * Drive / Head       (R/W)
00000000  =00F8002F                115  CF_STATUS   EQU SC145+15          * Status             (R)
00000000  =00F8002F                116  CF_COMMAND  EQU SC145+15          * Command            (W)
00000000                           117  
00000000  =00F80027                118  CF_LBA0007  EQU SC145+7           * LBA bits 07..00    (R/W)
00000000  =00F80029                119  CF_LBA0815  EQU SC145+9           * LBA bits 15..08    (R/W)
00000000  =00F8002B                120  CF_LBA1623  EQU SC145+11          * LBA bits 23..16    (R/W)
00000000  =00F8002D                121  CF_LBA2427  EQU SC145+13          * LBA bits 27..24    (R/W)
00000000                           122  
00000000  =00000001                123  CF_8BIT     EQU 1                 * Set 8-bit mode
00000000  =00000082                124  CF_NOCACHE  EQU $82               * Disable the cache
00000000                           125  
00000000  =00000020                126  CF_RD_SEC   EQU $20               * Read Sector Command
00000000  =00000030                127  CF_WR_SEC   EQU $30               * Write Sector Command
00000000  =000000EF                128  CF_SET_FEAT EQU $EF               * Set Feature Command
00000000  =000000E0                129  CF_LBAMODE  EQU $E0               * LBA mode
00000000  =000000E0                130  -------------------- end include --------------------
00000000                           131      
00000000                           132  *******************************************************************************
00000000                           133  * Set USE_REAL_UART as follows:
00000000                           134  *  1 = use the real MC6861 DUART hardware
00000000                           135  *  0 = use Easy68k Sim68k I/O window
00000000                           136  * -1 = use Easy68k Sim68k COM port
00000000                           137  *
00000000                           138  * Sim68K COM port is defined at the end of this file - change accordingly
00000000                           139  *
00000000  =00000001                140  USE_REAL_UART     EQU     1
00000000                           141  
00000000                           142  *------------------------------------------------------------------------------
00000000                           143  * Macro to "jump" to exception handler pointed to in the RAM vector table
00000000                           144  * Parameter \1 is the vector number 
00000000                           145  * Put the handler address held in RAM onto the stack and RET to it
00000000                           146  *------------------------------------------------------------------------------
00000000                           147  ramVecJump  MACRO
00000000                           148      move.l  VEC_BASE+(\1<<2),-(SP)
00000000                           149      rts
00000000                           150      ENDM
00000000                           151  
00000000                           152  *------------------------------------------------------------------------------
00000000                           153  * ASCII control characters
00000000                           154  *------------------------------------------------------------------------------
00000000  =0000000A                155  LF    equ $0A
00000000  =0000000D                156  CR    equ $0D
00000000                           157  
00000000                           158  *------------------------------------------------------------------------------
00000000                           159  * 68000 Exception Vector Table - THIS ONE IS IN ROM
00000000                           160  * All exceptions get the handler addresses from the RAM vector table except for
00000000                           161  * Bus Error, Address Error & TRAP #15 which always call handlers in the ROM. 
00000000                           162  *------------------------------------------------------------------------------
00000000                           163  
00000000                           164      ORG     $0000
00000000                           165  
00000000= 001FF800                 166      DC.l    STACK_START    * Supervisor stack pointer
00000004= 00007F78                 167      DC.l    START          * Initial PC    
00000008                           168  
00000008= 00007578                 169      DC.L    handleBusErr   *02 Bus Error     (** ROM handler **)
0000000C= 00007594                 170      DC.L    handleAddrErr  *03 Address Error (** ROM handler **)
00000010= 00007010                 171      DC.L    jmpIllInst     *04 Illegal Instruction
00000014= 00007018                 172      DC.L    jmpZeroDiv     *05 Zero Divide
00000018= 00007020                 173      DC.L    jmpChkInst     *06 CHK Instruction
0000001C= 00007028                 174      DC.L    jmpTrapV       *07 TRAPV Instruction
00000020= 00007030                 175      DC.L    jmpPriv        *08 Privilege Violation
00000024= 00007038                 176      DC.L    jmpTrace       *09 Trace
00000028= 00007040                 177      DC.L    jmpLineA       *0A Line 1010 Emulator
0000002C= 00007048                 178      DC.L    jmpLineF       *0B Line 1111 Emulator
00000030= 00007050                 179      DC.L    jmpRes1        *0C (Unassigned, Reserved)
00000034= 00007058                 180      DC.L    jmpRes2        *0D (Unassigned, Reserved)
00000038= 00007060                 181      DC.L    jmpRes3        *0E (Unassigned, Reserved)
0000003C= 00007068                 182      DC.L    jmpUnInit      *0F Uninitialized Interrupt Vector
00000040= 00007070                 183      DC.L    jmpRes4        *10 (Unassigned, Reserved)
00000044= 00007078                 184      DC.L    jmpRes5        *11 (Unassigned, Reserved)
00000048= 00007080                 185      DC.L    jmpRes6        *12 (Unassigned, Reserved)
0000004C= 00007088                 186      DC.L    jmpRes7        *13 (Unassigned, Reserved)
00000050= 00007090                 187      DC.L    jmpRes8        *14 (Unassigned, Reserved)
00000054= 00007098                 188      DC.L    jmpRes9        *15 (Unassigned, Reserved)
00000058= 000070A0                 189      DC.L    jmpRes10       *16 (Unassigned, Reserved)
0000005C= 000070A8                 190      DC.L    jmpRes11       *17 (Unassigned, Reserved)
00000060= 000070B0                 191      DC.L    jmpSpur        *18 Spurious Interrupt
00000064= 000070B8                 192      DC.L    jmpAV1         *19 Level 1 Interrupt Autovector
00000068= 000070C0                 193      DC.L    jmpAV2         *1A Level 2 Interrupt Autovector
0000006C= 000070C8                 194      DC.L    jmpAV3         *1B Level 3 Interrupt Autovector
00000070= 000070D0                 195      DC.L    jmpAV4         *1C Level 4 Interrupt Autovector
00000074= 000070D8                 196      DC.L    jmpAV5         *1D Level 5 Interrupt Autovector
00000078= 000070E0                 197      DC.L    jmpAV6         *1E Level 6 Interrupt Autovector
0000007C= 000070E8                 198      DC.L    jmpAV7         *1F Level 7 Interrupt Autovector
00000080= 000070F0                 199      DC.L    jmpTrap0       *20 TRAP #0  Instruction Vector
00000084= 000070F8                 200      DC.L    jmpTrap1       *21 TRAP #1  Instruction Vector
00000088= 00007100                 201      DC.L    jmpTrap2       *22 TRAP #2  Instruction Vector
0000008C= 00007108                 202      DC.L    jmpTrap3       *23 TRAP #3  Instruction Vector
00000090= 00007110                 203      DC.L    jmpTrap4       *24 TRAP #4  Instruction Vector
00000094= 00007118                 204      DC.L    jmpTrap5       *25 TRAP #5  Instruction Vector
00000098= 00007120                 205      DC.L    jmpTrap6       *26 TRAP #6  Instruction Vector
0000009C= 00007128                 206      DC.L    jmpTrap7       *27 TRAP #7  Instruction Vector
000000A0= 00007130                 207      DC.L    jmpTrap8       *28 TRAP #8  Instruction Vector
000000A4= 00007138                 208      DC.L    jmpTrap9       *29 TRAP #9  Instruction Vector
000000A8= 00007140                 209      DC.L    jmpTrap10      *2A TRAP #10 Instruction Vector
000000AC= 00007148                 210      DC.L    jmpTrap11      *2B TRAP #11 Instruction Vector
000000B0= 00007150                 211      DC.L    jmpTrap12      *2C TRAP #12 Instruction Vector
000000B4= 00007158                 212      DC.L    jmpTrap13      *2D TRAP #13 Instruction Vector
000000B8= 00007160                 213      DC.L    jmpTrap14      *2E TRAP #14 Instruction Vector
000000BC= 000084D8                 214      DC.L    easy68kTrap15  *2E TRAP #15 Instruction Vector (** ROM handler **)
000000C0                           215          
000000C0                           216  *------------------------------------------------------------------------------
000000C0                           217  * Exception Vectors 30 to FF are not used on my system so just point them
000000C0                           218  * all to the default handler.
000000C0                           219  
000000C0= 00007170 00007170 ...    220      DCB.L   208,jmpUnused
00000400                           221  
00000400                           222  *------------------------------------------------------------------------------
00000400                           223  * Start the monitor program after the CP/M BIOS code.
00000400                           224  *------------------------------------------------------------------------------
00007000                           225      ORG     MON_BASE
00007000                           226  
00007000                           227  *------------------------------------------------------------------------------
00007000                           228  * The hard coded ROM exception vector table entries point to these individual
00007000                           229  * handlers that then jump to (actually RETurn to) the address specified in the
00007000                           230  * RAM exception vector table.
00007000                           231  *------------------------------------------------------------------------------
00007000                           232      ORG     (*+1)&-2    * make sure the table is word aligned
00007000                           233  
00007000                           234m jmpBusErr:  ramVecJump  $02
00007000  2F39 00100008            235m     MOVE.L  VEC_BASE+($02<<2),-(SP)
00007006  4E75                     236m     RTS
00007008                           237m     ENDM
00007008                           238m jmpAddrErr: ramVecJump  $03
00007008  2F39 0010000C            239m     MOVE.L  VEC_BASE+($03<<2),-(SP)
0000700E  4E75                     240m     RTS
00007010                           241m     ENDM
00007010                           242m jmpIllInst: ramVecJump  $04
00007010  2F39 00100010            243m     MOVE.L  VEC_BASE+($04<<2),-(SP)
00007016  4E75                     244m     RTS
00007018                           245m     ENDM
00007018                           246m jmpZeroDiv: ramVecJump  $05
00007018  2F39 00100014            247m     MOVE.L  VEC_BASE+($05<<2),-(SP)
0000701E  4E75                     248m     RTS
00007020                           249m     ENDM
00007020                           250m jmpChkInst: ramVecJump  $06
00007020  2F39 00100018            251m     MOVE.L  VEC_BASE+($06<<2),-(SP)
00007026  4E75                     252m     RTS
00007028                           253m     ENDM
00007028                           254m jmpTrapV:   ramVecJump  $07
00007028  2F39 0010001C            255m     MOVE.L  VEC_BASE+($07<<2),-(SP)
0000702E  4E75                     256m     RTS
00007030                           257m     ENDM
00007030                           258m jmpPriv:    ramVecJump  $08
00007030  2F39 00100020            259m     MOVE.L  VEC_BASE+($08<<2),-(SP)
00007036  4E75                     260m     RTS
00007038                           261m     ENDM
00007038                           262m jmpTrace:   ramVecJump  $09
00007038  2F39 00100024            263m     MOVE.L  VEC_BASE+($09<<2),-(SP)
0000703E  4E75                     264m     RTS
00007040                           265m     ENDM
00007040                           266m jmpLineA:   ramVecJump  $0A
00007040  2F39 00100028            267m     MOVE.L  VEC_BASE+($0A<<2),-(SP)
00007046  4E75                     268m     RTS
00007048                           269m     ENDM
00007048                           270m jmpLineF:   ramVecJump  $0B
00007048  2F39 0010002C            271m     MOVE.L  VEC_BASE+($0B<<2),-(SP)
0000704E  4E75                     272m     RTS
00007050                           273m     ENDM
00007050                           274m jmpRes1:    ramVecJump  $0C
00007050  2F39 00100030            275m     MOVE.L  VEC_BASE+($0C<<2),-(SP)
00007056  4E75                     276m     RTS
00007058                           277m     ENDM
00007058                           278m jmpRes2:    ramVecJump  $0D
00007058  2F39 00100034            279m     MOVE.L  VEC_BASE+($0D<<2),-(SP)
0000705E  4E75                     280m     RTS
00007060                           281m     ENDM
00007060                           282m jmpRes3:    ramVecJump  $0E
00007060  2F39 00100038            283m     MOVE.L  VEC_BASE+($0E<<2),-(SP)
00007066  4E75                     284m     RTS
00007068                           285m     ENDM
00007068                           286m jmpUnInit:  ramVecJump  $0F
00007068  2F39 0010003C            287m     MOVE.L  VEC_BASE+($0F<<2),-(SP)
0000706E  4E75                     288m     RTS
00007070                           289m     ENDM
00007070                           290m jmpRes4:    ramVecJump  $10
00007070  2F39 00100040            291m     MOVE.L  VEC_BASE+($10<<2),-(SP)
00007076  4E75                     292m     RTS
00007078                           293m     ENDM
00007078                           294m jmpRes5:    ramVecJump  $11
00007078  2F39 00100044            295m     MOVE.L  VEC_BASE+($11<<2),-(SP)
0000707E  4E75                     296m     RTS
00007080                           297m     ENDM
00007080                           298m jmpRes6:    ramVecJump  $12
00007080  2F39 00100048            299m     MOVE.L  VEC_BASE+($12<<2),-(SP)
00007086  4E75                     300m     RTS
00007088                           301m     ENDM
00007088                           302m jmpRes7:    ramVecJump  $13
00007088  2F39 0010004C            303m     MOVE.L  VEC_BASE+($13<<2),-(SP)
0000708E  4E75                     304m     RTS
00007090                           305m     ENDM
00007090                           306m jmpRes8:    ramVecJump  $14
00007090  2F39 00100050            307m     MOVE.L  VEC_BASE+($14<<2),-(SP)
00007096  4E75                     308m     RTS
00007098                           309m     ENDM
00007098                           310m jmpRes9:    ramVecJump  $15
00007098  2F39 00100054            311m     MOVE.L  VEC_BASE+($15<<2),-(SP)
0000709E  4E75                     312m     RTS
000070A0                           313m     ENDM
000070A0                           314m jmpRes10:   ramVecJump  $16
000070A0  2F39 00100058            315m     MOVE.L  VEC_BASE+($16<<2),-(SP)
000070A6  4E75                     316m     RTS
000070A8                           317m     ENDM
000070A8                           318m jmpRes11:   ramVecJump  $17
000070A8  2F39 0010005C            319m     MOVE.L  VEC_BASE+($17<<2),-(SP)
000070AE  4E75                     320m     RTS
000070B0                           321m     ENDM
000070B0                           322m jmpSpur:    ramVecJump  $18
000070B0  2F39 00100060            323m     MOVE.L  VEC_BASE+($18<<2),-(SP)
000070B6  4E75                     324m     RTS
000070B8                           325m     ENDM
000070B8                           326m jmpAV1:     ramVecJump  $19
000070B8  2F39 00100064            327m     MOVE.L  VEC_BASE+($19<<2),-(SP)
000070BE  4E75                     328m     RTS
000070C0                           329m     ENDM
000070C0                           330m jmpAV2:     ramVecJump  $1A
000070C0  2F39 00100068            331m     MOVE.L  VEC_BASE+($1A<<2),-(SP)
000070C6  4E75                     332m     RTS
000070C8                           333m     ENDM
000070C8                           334m jmpAV3:     ramVecJump  $1B
000070C8  2F39 0010006C            335m     MOVE.L  VEC_BASE+($1B<<2),-(SP)
000070CE  4E75                     336m     RTS
000070D0                           337m     ENDM
000070D0                           338m jmpAV4:     ramVecJump  $1C
000070D0  2F39 00100070            339m     MOVE.L  VEC_BASE+($1C<<2),-(SP)
000070D6  4E75                     340m     RTS
000070D8                           341m     ENDM
000070D8                           342m jmpAV5:     ramVecJump  $1D
000070D8  2F39 00100074            343m     MOVE.L  VEC_BASE+($1D<<2),-(SP)
000070DE  4E75                     344m     RTS
000070E0                           345m     ENDM
000070E0                           346m jmpAV6:     ramVecJump  $1E
000070E0  2F39 00100078            347m     MOVE.L  VEC_BASE+($1E<<2),-(SP)
000070E6  4E75                     348m     RTS
000070E8                           349m     ENDM
000070E8                           350m jmpAV7:     ramVecJump  $1F
000070E8  2F39 0010007C            351m     MOVE.L  VEC_BASE+($1F<<2),-(SP)
000070EE  4E75                     352m     RTS
000070F0                           353m     ENDM
000070F0                           354m jmpTrap0:   ramVecJump  $20
000070F0  2F39 00100080            355m     MOVE.L  VEC_BASE+($20<<2),-(SP)
000070F6  4E75                     356m     RTS
000070F8                           357m     ENDM
000070F8                           358m jmpTrap1:   ramVecJump  $21
000070F8  2F39 00100084            359m     MOVE.L  VEC_BASE+($21<<2),-(SP)
000070FE  4E75                     360m     RTS
00007100                           361m     ENDM
00007100                           362m jmpTrap2:   ramVecJump  $22
00007100  2F39 00100088            363m     MOVE.L  VEC_BASE+($22<<2),-(SP)
00007106  4E75                     364m     RTS
00007108                           365m     ENDM
00007108                           366m jmpTrap3:   ramVecJump  $23
00007108  2F39 0010008C            367m     MOVE.L  VEC_BASE+($23<<2),-(SP)
0000710E  4E75                     368m     RTS
00007110                           369m     ENDM
00007110                           370m jmpTrap4:   ramVecJump  $24
00007110  2F39 00100090            371m     MOVE.L  VEC_BASE+($24<<2),-(SP)
00007116  4E75                     372m     RTS
00007118                           373m     ENDM
00007118                           374m jmpTrap5:   ramVecJump  $25
00007118  2F39 00100094            375m     MOVE.L  VEC_BASE+($25<<2),-(SP)
0000711E  4E75                     376m     RTS
00007120                           377m     ENDM
00007120                           378m jmpTrap6:   ramVecJump  $26
00007120  2F39 00100098            379m     MOVE.L  VEC_BASE+($26<<2),-(SP)
00007126  4E75                     380m     RTS
00007128                           381m     ENDM
00007128                           382m jmpTrap7:   ramVecJump  $27
00007128  2F39 0010009C            383m     MOVE.L  VEC_BASE+($27<<2),-(SP)
0000712E  4E75                     384m     RTS
00007130                           385m     ENDM
00007130                           386m jmpTrap8:   ramVecJump  $28
00007130  2F39 001000A0            387m     MOVE.L  VEC_BASE+($28<<2),-(SP)
00007136  4E75                     388m     RTS
00007138                           389m     ENDM
00007138                           390m jmpTrap9:   ramVecJump  $29
00007138  2F39 001000A4            391m     MOVE.L  VEC_BASE+($29<<2),-(SP)
0000713E  4E75                     392m     RTS
00007140                           393m     ENDM
00007140                           394m jmpTrap10:  ramVecJump  $2A
00007140  2F39 001000A8            395m     MOVE.L  VEC_BASE+($2A<<2),-(SP)
00007146  4E75                     396m     RTS
00007148                           397m     ENDM
00007148                           398m jmpTrap11:  ramVecJump  $2B
00007148  2F39 001000AC            399m     MOVE.L  VEC_BASE+($2B<<2),-(SP)
0000714E  4E75                     400m     RTS
00007150                           401m     ENDM
00007150                           402m jmpTrap12:  ramVecJump  $2C
00007150  2F39 001000B0            403m     MOVE.L  VEC_BASE+($2C<<2),-(SP)
00007156  4E75                     404m     RTS
00007158                           405m     ENDM
00007158                           406m jmpTrap13:  ramVecJump  $2D
00007158  2F39 001000B4            407m     MOVE.L  VEC_BASE+($2D<<2),-(SP)
0000715E  4E75                     408m     RTS
00007160                           409m     ENDM
00007160                           410m jmpTrap14:  ramVecJump  $2E
00007160  2F39 001000B8            411m     MOVE.L  VEC_BASE+($2E<<2),-(SP)
00007166  4E75                     412m     RTS
00007168                           413m     ENDM
00007168                           414m jmpTrap15:  ramVecJump  $2F
00007168  2F39 001000BC            415m     MOVE.L  VEC_BASE+($2F<<2),-(SP)
0000716E  4E75                     416m     RTS
00007170                           417m     ENDM
00007170                           418  
00007170                           419m jmpUnused:  ramVecJump  $30
00007170  2F39 001000C0            420m     MOVE.L  VEC_BASE+($30<<2),-(SP)
00007176  4E75                     421m     RTS
00007178                           422m     ENDM
00007178                           423  
00007178                           424  *------------------------------------------------------------------------------
00007178                           425  * This is the initial exception vector table that gets copied into RAM. It just
00007178                           426  * holds the addresses of basic exception handlers in ROM. The ramVecJump indexes
00007178                           427  * into this table to get the addresses of the actual exception handlers. 
00007178                           428  *
00007178                           429  * NOTE: Bus Error, Address Error & TRAP #15 are all hard coded to be handled by
00007178                           430  * routines in ROM and the entries in this table are not used.
00007178                           431  *------------------------------------------------------------------------------
00007178                           432      ORG     (*+1)&-2       * make sure the table is word aligned
00007178                           433  
00007178                           434  rom2ramIVT:
00007178= 001FF800                 435      DC.L    STACK_START    *00 Supervisor stack pointer
0000717C= 00007F78                 436      DC.L    START          *01 Initial PC    
00007180                           437  
00007180= 00007578                 438      DC.L    handleBusErr   *02 Bus Error
00007184= 00007594                 439      DC.L    handleAddrErr  *03 Address Error
00007188= 000075B0                 440      DC.L    handleIllInst  *04 Illegal Instruction
0000718C= 000075BC                 441      DC.L    handleZeroDiv  *05 Zero Divide
00007190= 000075C8                 442      DC.L    handleChkInst  *06 CHK Instruction
00007194= 000075D4                 443      DC.L    handleTrapV    *07 TRAPV Instruction
00007198= 000075E0                 444      DC.L    handlePriv     *08 Privilege Violation
0000719C= 000075EC                 445      DC.L    handleTrace    *09 Trace
000071A0= 000075F8                 446      DC.L    handleLineA    *0A Line 1010 Emulator
000071A4= 00007604                 447      DC.L    handleLineF    *0B Line 1111 Emulator
000071A8= 00007610                 448      DC.L    handleRes1     *0C (Unassigned, Reserved)
000071AC= 00007610                 449      DC.L    handleRes2     *0D (Unassigned, Reserved)
000071B0= 00007610                 450      DC.L    handleRes3     *0E (Unassigned, Reserved)
000071B4= 0000761C                 451      DC.L    handleUnInit   *0F Uninitialized Interrupt Vector
000071B8= 00007610                 452      DC.L    handleRes4     *10 (Unassigned, Reserved)
000071BC= 00007610                 453      DC.L    handleRes5     *11 (Unassigned, Reserved)
000071C0= 00007610                 454      DC.L    handleRes6     *12 (Unassigned, Reserved)
000071C4= 00007610                 455      DC.L    handleRes7     *13 (Unassigned, Reserved)
000071C8= 00007610                 456      DC.L    handleRes8     *14 (Unassigned, Reserved)
000071CC= 00007610                 457      DC.L    handleRes9     *15 (Unassigned, Reserved)
000071D0= 00007610                 458      DC.L    handleRes10    *16 (Unassigned, Reserved)
000071D4= 00007610                 459      DC.L    handleRes11    *17 (Unassigned, Reserved)
000071D8= 00007628                 460      DC.L    handleSpur     *18 Spurious Interrupt
000071DC= 00007634                 461      DC.L    handleAV1      *19 Level 1 Interrupt Autovector
000071E0= 00007640                 462      DC.L    handleAV2      *1A Level 2 Interrupt Autovector
000071E4= 0000764C                 463      DC.L    handleAV3      *1B Level 3 Interrupt Autovector
000071E8= 00007658                 464      DC.L    handleAV4      *1C Level 4 Interrupt Autovector
000071EC= 00007664                 465      DC.L    handleAV5      *1D Level 5 Interrupt Autovector
000071F0= 00007670                 466      DC.L    handleAV6      *1E Level 6 Interrupt Autovector
000071F4= 0000767C                 467      DC.L    handleAV7      *1F Level 7 Interrupt Autovector
000071F8= 00007688                 468      DC.L    handleTrap0    *20 TRAP #0  Instruction Vector
000071FC= 00007694                 469      DC.L    handleTrap1    *21 TRAP #1  Instruction Vector
00007200= 000076A0                 470      DC.L    handleTrap2    *22 TRAP #2  Instruction Vector
00007204= 000076AC                 471      DC.L    handleTrap3    *23 TRAP #3  Instruction Vector
00007208= 000076B8                 472      DC.L    handleTrap4    *24 TRAP #4  Instruction Vector
0000720C= 000076C4                 473      DC.L    handleTrap5    *25 TRAP #5  Instruction Vector
00007210= 000076D0                 474      DC.L    handleTrap6    *26 TRAP #6  Instruction Vector
00007214= 000076DC                 475      DC.L    handleTrap7    *27 TRAP #7  Instruction Vector
00007218= 000076E8                 476      DC.L    handleTrap8    *28 TRAP #8  Instruction Vector
0000721C= 000076F4                 477      DC.L    handleTrap9    *29 TRAP #9  Instruction Vector
00007220= 00007700                 478      DC.L    handleTrap10   *2A TRAP #10 Instruction Vector
00007224= 0000770C                 479      DC.L    handleTrap11   *2B TRAP #11 Instruction Vector
00007228= 00007718                 480      DC.L    handleTrap12   *2C TRAP #12 Instruction Vector
0000722C= 00007724                 481      DC.L    handleTrap13   *2D TRAP #13 Instruction Vector
00007230= 00007730                 482      DC.L    handleTrap14   *2E TRAP #14 Instruction Vector
00007234= 0000773C                 483      DC.L    handleTrap15   *2F TRAP #15 Instruction Vector
00007238                           484  
00007238= 00007748 00007748 ...    485      DCB.L   208,handleUnused
00007578                           486  
00007578                           487  *------------------------------------------------------------------------------
00007578                           488  * Below are the actual exception handlers that are accessed from the vector
00007578                           489  * table in RAM. The user can overwrite any of the RAM vector table addresses
00007578                           490  * with the address of their own exception handler. These handlers simply output
00007578                           491  * a message to the serial port and enter an endless loop.
00007578                           492  *------------------------------------------------------------------------------
00007578                           493  
00007578                           494  *------------------------------------------------------------------------------
00007578                           495  * BUS ERROR handler
00007578                           496  * Print a message showing the PC and address being accessed
00007578                           497  *------------------------------------------------------------------------------
00007578                           498  handleBusErr:
00007578  41FA 0402                499      lea     bemsg1(PC), a0  * first message
0000757C  6100 0FBE                500      bsr.w   putString
00007580  202F 000A                501      move.l  10(a7),d0       * get the program counter 
00007584  6100 0F72                502      bsr.w   writeAddr32
00007588                           503      
00007588  41FA 0431                504      lea     bemsg2(PC), a0  * second message
0000758C  6100 0FAE                505      bsr.w   putString
00007590  6000 01C2                506      bra.w   handleCleanUp
00007594                           507      
00007594                           508  *------------------------------------------------------------------------------
00007594                           509  * ADDRESS ERROR handler
00007594                           510  * Print a message showing the PC and address being accessed
00007594                           511  *------------------------------------------------------------------------------
00007594                           512  handleAddrErr:
00007594  41FA 01CC                513      lea     aemsg1(PC), a0  * first message
00007598  6100 0FA2                514      bsr.w   putString
0000759C  202F 000A                515      move.l  10(a7),d0       * get the program counter 
000075A0  6100 0F56                516      bsr.w   writeAddr32
000075A4                           517      
000075A4  41FA 0200                518      lea     aemsg2(PC), a0  * second message
000075A8  6100 0F92                519      bsr.w   putString
000075AC  6000 01A6                520      bra.w   handleCleanUp
000075B0                           521      
000075B0                           522  *------------------------------------------------------------------------------
000075B0                           523  * ILLEGAL INSTRUCTION handler
000075B0                           524  *------------------------------------------------------------------------------
000075B0                           525  handleIllInst:
000075B0  41FA 0468                526      lea     iimsg(PC), a0   * display message
000075B4  6100 0F86                527      bsr.w   putString
000075B8  6000 019A                528      bra.w   handleCleanUp
000075BC                           529      
000075BC                           530  *------------------------------------------------------------------------------
000075BC                           531  * DIVISION BY ZERO handler
000075BC                           532  *------------------------------------------------------------------------------
000075BC                           533  handleZeroDiv:
000075BC  41FA 0985                534      lea     zdmsg(PC), a0   * display message
000075C0  6100 0F7A                535      bsr.w   putString
000075C4  6000 018E                536      bra.w   handleCleanUp
000075C8                           537      
000075C8                           538  *------------------------------------------------------------------------------
000075C8                           539  * CHK handler
000075C8                           540  *------------------------------------------------------------------------------
000075C8                           541  handleChkInst:
000075C8  41FA 0423                542      lea     cimsg(PC), a0   * display message
000075CC  6100 0F6E                543      bsr.w   putString
000075D0  6000 0182                544      bra.w   handleCleanUp
000075D4                           545      
000075D4                           546  *------------------------------------------------------------------------------
000075D4                           547  * TRAPV handler
000075D4                           548  *------------------------------------------------------------------------------
000075D4                           549  handleTrapV:
000075D4  41FA 08CF                550      lea     tvmsg(PC), a0   * display message
000075D8  6100 0F62                551      bsr.w   putString
000075DC  6000 0176                552      bra.w   handleCleanUp
000075E0                           553      
000075E0                           554  *------------------------------------------------------------------------------
000075E0                           555  * PRIVILEGE VIOLATION handler
000075E0                           556  *------------------------------------------------------------------------------
000075E0                           557  handlePriv:
000075E0  41FA 04D3                558      lea     pvmsg(PC), a0   * display message
000075E4  6100 0F56                559      bsr.w   putString
000075E8  6000 016A                560      bra.w   handleCleanUp
000075EC                           561      
000075EC                           562  *------------------------------------------------------------------------------
000075EC                           563  * TRACE handler
000075EC                           564  *------------------------------------------------------------------------------
000075EC                           565  handleTrace:
000075EC  41FA 0572                566      lea     trmsg(PC), a0   * display message
000075F0  6100 0F4A                567      bsr.w   putString
000075F4  6000 015E                568      bra.w   handleCleanUp
000075F8                           569      
000075F8                           570  *------------------------------------------------------------------------------
000075F8                           571  * Unimplementd Instruction - Line A handler
000075F8                           572  *------------------------------------------------------------------------------
000075F8                           573  handleLineA:
000075F8  41FA 045B                574      lea     lamsg(PC), a0   * display message
000075FC  6100 0F3E                575      bsr.w   putString
00007600  6000 0152                576      bra.w   handleCleanUp
00007604                           577      
00007604                           578  *------------------------------------------------------------------------------
00007604                           579  * Unimplementd Instruction - Line F handler
00007604                           580  *------------------------------------------------------------------------------
00007604                           581  handleLineF:
00007604  41FA 047F                582      lea     lfmsg(PC), a0   * display message
00007608  6100 0F32                583      bsr.w   putString
0000760C  6000 0146                584      bra.w   handleCleanUp
00007610                           585      
00007610                           586  *------------------------------------------------------------------------------
00007610                           587  * Reserved Instruction handler
00007610                           588  *------------------------------------------------------------------------------
00007610                           589  handleRes1:
00007610                           590  handleRes2:
00007610                           591  handleRes3:
00007610                           592  handleRes4:
00007610                           593  handleRes5:
00007610                           594  handleRes6:
00007610                           595  handleRes7:
00007610                           596  handleRes8:
00007610                           597  handleRes9:
00007610                           598  handleRes10:
00007610                           599  handleRes11:
00007610  41FA 04E0                600      lea     rimsg(PC), a0   * display message
00007614  6100 0F26                601      bsr.w   putString
00007618  6000 013A                602      bra.w   handleCleanUp
0000761C                           603      
0000761C                           604  *------------------------------------------------------------------------------
0000761C                           605  * Uninitialised Interrupt handler
0000761C                           606  *------------------------------------------------------------------------------
0000761C                           607  handleUnInit:
0000761C  41FA 08B6                608      lea     uimsg(PC), a0   * display message
00007620  6100 0F1A                609      bsr.w   putString
00007624  6000 012E                610      bra.w   handleCleanUp
00007628                           611      
00007628                           612  *------------------------------------------------------------------------------
00007628                           613  * Spurious Interrupt handler
00007628                           614  *------------------------------------------------------------------------------
00007628                           615  handleSpur:
00007628  41FA 04FA                616      lea     simsg(PC), a0   * display message
0000762C  6100 0F0E                617      bsr.w   putString
00007630  6000 0122                618      bra.w   handleCleanUp
00007634                           619      
00007634                           620  *------------------------------------------------------------------------------
00007634                           621  * Autovector Level 1 Exception handler
00007634                           622  *------------------------------------------------------------------------------
00007634                           623  handleAV1:
00007634  41FA 01A2                624      lea     av1msg(PC), a0  * display message
00007638  6100 0F02                625      bsr.w   putString
0000763C  6000 0116                626      bra.w   handleCleanUp
00007640                           627  
00007640                           628  *------------------------------------------------------------------------------
00007640                           629  * Autovector Level 2 Exception handler
00007640                           630  *------------------------------------------------------------------------------
00007640                           631  handleAV2:
00007640  41FA 01D2                632      lea     av2msg(PC), a0  * display message
00007644  6100 0EF6                633      bsr.w   putString
00007648  6000 010A                634      bra.w   handleCleanUp
0000764C                           635  
0000764C                           636  *------------------------------------------------------------------------------
0000764C                           637  * Autovector Level 3 Exception handler
0000764C                           638  *------------------------------------------------------------------------------
0000764C                           639  handleAV3:
0000764C  41FA 0202                640      lea     av3msg(PC), a0  * display message
00007650  6100 0EEA                641      bsr.w   putString
00007654  6000 00FE                642      bra.w   handleCleanUp
00007658                           643  
00007658                           644  *------------------------------------------------------------------------------
00007658                           645  * Autovector Level 4 Exception handler
00007658                           646  *------------------------------------------------------------------------------
00007658                           647  handleAV4:
00007658  41FA 0232                648      lea     av4msg(PC), a0  * display message
0000765C  6100 0EDE                649      bsr.w   putString
00007660  6000 00F2                650      bra.w   handleCleanUp
00007664                           651  
00007664                           652  *------------------------------------------------------------------------------
00007664                           653  * Autovector Level 5 Exception handler
00007664                           654  *------------------------------------------------------------------------------
00007664                           655  handleAV5:
00007664  41FA 0262                656      lea     av5msg(PC), a0  * display message
00007668  6100 0ED2                657      bsr.w   putString
0000766C  6000 00E6                658      bra.w   handleCleanUp
00007670                           659  
00007670                           660  *------------------------------------------------------------------------------
00007670                           661  * Autovector Level 6 Exception handler
00007670                           662  *------------------------------------------------------------------------------
00007670                           663  handleAV6:
00007670  41FA 0292                664      lea     av6msg(PC), a0  * display message
00007674  6100 0EC6                665      bsr.w   putString
00007678  6000 00DA                666      bra.w   handleCleanUp
0000767C                           667  
0000767C                           668  *------------------------------------------------------------------------------
0000767C                           669  * Autovector Level 7 Exception handler
0000767C                           670  *------------------------------------------------------------------------------
0000767C                           671  handleAV7:
0000767C  41FA 02C2                672      lea     av7msg(PC), a0  * display message
00007680  6100 0EBA                673      bsr.w   putString
00007684  6000 00CE                674      bra.w   handleCleanUp
00007688                           675      
00007688                           676  *------------------------------------------------------------------------------
00007688                           677  * TRAP #0 Exception handler
00007688                           678  *------------------------------------------------------------------------------
00007688                           679  handleTrap0:
00007688  41FA 0505                680      lea     tr0msg(PC), a0  * display message
0000768C  6100 0EAE                681      bsr.w   putString
00007690  6000 00C2                682      bra.w   handleCleanUp
00007694                           683  
00007694                           684  *------------------------------------------------------------------------------
00007694                           685  * TRAP #1 Exception handler
00007694                           686  *------------------------------------------------------------------------------
00007694                           687  handleTrap1:
00007694  41FA 052A                688      lea     tr1msg(PC), a0  * display message
00007698  6100 0EA2                689      bsr.w   putString
0000769C  6000 00B6                690      bra.w   handleCleanUp
000076A0                           691  
000076A0                           692  *------------------------------------------------------------------------------
000076A0                           693  * TRAP #2 Exception handler
000076A0                           694  *------------------------------------------------------------------------------
000076A0                           695  handleTrap2:
000076A0  41FA 054F                696      lea     tr2msg(PC), a0  * display message
000076A4  6100 0E96                697      bsr.w   putString
000076A8  6000 00AA                698      bra.w   handleCleanUp
000076AC                           699  
000076AC                           700  *------------------------------------------------------------------------------
000076AC                           701  * TRAP #3 Exception handler
000076AC                           702  *------------------------------------------------------------------------------
000076AC                           703  handleTrap3:
000076AC  41FA 0574                704      lea     tr3msg(PC), a0  * display message
000076B0  6100 0E8A                705      bsr.w   putString
000076B4  6000 009E                706      bra.w   handleCleanUp
000076B8                           707  
000076B8                           708  *------------------------------------------------------------------------------
000076B8                           709  * TRAP #4 Exception handler
000076B8                           710  *------------------------------------------------------------------------------
000076B8                           711  handleTrap4:
000076B8  41FA 0599                712      lea     tr4msg(PC), a0  * display message
000076BC  6100 0E7E                713      bsr.w   putString
000076C0  6000 0092                714      bra.w   handleCleanUp
000076C4                           715  
000076C4                           716  *------------------------------------------------------------------------------
000076C4                           717  * TRAP #5 Exception handler
000076C4                           718  *------------------------------------------------------------------------------
000076C4                           719  handleTrap5:
000076C4  41FA 05BE                720      lea     tr5msg(PC), a0  * display message
000076C8  6100 0E72                721      bsr.w   putString
000076CC  6000 0086                722      bra.w   handleCleanUp
000076D0                           723  
000076D0                           724  *------------------------------------------------------------------------------
000076D0                           725  * TRAP #6 Exception handler
000076D0                           726  *------------------------------------------------------------------------------
000076D0                           727  handleTrap6:
000076D0  41FA 05E3                728      lea     tr6msg(PC), a0  * display message
000076D4  6100 0E66                729      bsr.w   putString
000076D8  6000 007A                730      bra.w   handleCleanUp
000076DC                           731  
000076DC                           732  *------------------------------------------------------------------------------
000076DC                           733  * TRAP #7 Exception handler
000076DC                           734  *------------------------------------------------------------------------------
000076DC                           735  handleTrap7:
000076DC  41FA 0608                736      lea     tr7msg(PC), a0  * display message
000076E0  6100 0E5A                737      bsr.w   putString
000076E4  6000 006E                738      bra.w   handleCleanUp
000076E8                           739  
000076E8                           740  *------------------------------------------------------------------------------
000076E8                           741  * TRAP #8 Exception handler
000076E8                           742  *------------------------------------------------------------------------------
000076E8                           743  handleTrap8:
000076E8  41FA 062D                744      lea     tr8msg(PC), a0  * display message
000076EC  6100 0E4E                745      bsr.w   putString
000076F0  6000 0062                746      bra.w   handleCleanUp
000076F4                           747  
000076F4                           748  *------------------------------------------------------------------------------
000076F4                           749  * TRAP #9 Exception handler
000076F4                           750  *------------------------------------------------------------------------------
000076F4                           751  handleTrap9:
000076F4  41FA 0652                752      lea     tr9msg(PC), a0  * display message
000076F8  6100 0E42                753      bsr.w   putString
000076FC  6000 0056                754      bra.w   handleCleanUp
00007700                           755  
00007700                           756  *------------------------------------------------------------------------------
00007700                           757  * TRAP #10 Exception handler
00007700                           758  *------------------------------------------------------------------------------
00007700                           759  handleTrap10:
00007700  41FA 0677                760      lea     tr10msg(PC), a0 * display message
00007704  6100 0E36                761      bsr.w   putString
00007708  6000 004A                762      bra.w   handleCleanUp
0000770C                           763  
0000770C                           764  *------------------------------------------------------------------------------
0000770C                           765  * TRAP #11 Exception handler
0000770C                           766  *------------------------------------------------------------------------------
0000770C                           767  handleTrap11:
0000770C  41FA 069D                768      lea     tr11msg(PC), a0 * display message
00007710  6100 0E2A                769      bsr.w   putString
00007714  6000 003E                770      bra.w   handleCleanUp
00007718                           771  
00007718                           772  *------------------------------------------------------------------------------
00007718                           773  * TRAP #12 Exception handler
00007718                           774  *------------------------------------------------------------------------------
00007718                           775  handleTrap12:
00007718  41FA 06C3                776      lea     tr12msg(PC), a0 * display message
0000771C  6100 0E1E                777      bsr.w   putString
00007720  6000 0032                778      bra.w   handleCleanUp
00007724                           779      
00007724                           780  *------------------------------------------------------------------------------
00007724                           781  * TRAP #13 Exception handler
00007724                           782  *------------------------------------------------------------------------------
00007724                           783  handleTrap13:
00007724  41FA 06E9                784      lea     tr13msg(PC), a0 * display message
00007728  6100 0E12                785      bsr.w   putString
0000772C  6000 0026                786      bra.w   handleCleanUp
00007730                           787      
00007730                           788  *------------------------------------------------------------------------------
00007730                           789  * TRAP #14 Exception handler
00007730                           790  *------------------------------------------------------------------------------
00007730                           791  handleTrap14:
00007730  41FA 070F                792      lea     tr14msg(PC), a0 * display message
00007734  6100 0E06                793      bsr.w   putString
00007738  6000 001A                794      bra.w   handleCleanUp
0000773C                           795      
0000773C                           796  *------------------------------------------------------------------------------
0000773C                           797  * TRAP #15 Exception handler
0000773C                           798  *------------------------------------------------------------------------------
0000773C                           799  handleTrap15:
0000773C  41FA 0735                800      lea     tr15msg(PC), a0 * display message
00007740  6100 0DFA                801      bsr.w   putString
00007744  6000 000E                802      bra.w   handleCleanUp
00007748                           803      
00007748                           804  *------------------------------------------------------------------------------
00007748                           805  * User Exception handler - all remaining exception handlers land here
00007748                           806  *------------------------------------------------------------------------------
00007748                           807  handleUnused:
00007748  41FA 07CB                808      lea     usermsg(PC), a0 * display message
0000774C  6100 0DEE                809      bsr.w   putString
00007750  6000 0002                810      bra.w   handleCleanUp
00007754                           811      
00007754                           812  *------------------------------------------------------------------------------
00007754                           813  * All exception handlers jump here to output the PC of the next instruction
00007754                           814  * after the exception occured.
00007754                           815  *------------------------------------------------------------------------------
00007754                           816  handleCleanUp:
00007754  202F 0002                817      move.l  2(a7),d0        * get the address
00007758  6100 0D9E                818      bsr.w   writeAddr32
0000775C  6100 0DDA                819      bsr.w   putCRLF
00007760                           820  .infloop:
00007760  60FE                     821      bra.s   .infloop
00007762                           822  
00007762                           823  *------------------------------------------------------------------------------
00007762                           824  * Exception handler messages
00007762                           825  *------------------------------------------------------------------------------
00007762= 0A 0D 53 54 4F 50 ...    826  aemsg1:  dc.b   10,13,'STOP: An Address Error occured whilst executing code at address $',0
000077A6= 0A 0D 53 54 4F 50 ...    827  aemsg2:  dc.b   10,13,'STOP: The address location being accessed was $',0
000077D8= 0A 0D 53 54 4F 50 ...    828  av1msg:  dc.b   10,13,'STOP: Autovector Level 1 exception occured near address $',0
00007814= 0A 0D 53 54 4F 50 ...    829  av2msg:  dc.b   10,13,'STOP: Autovector Level 2 exception occured near address $',0
00007850= 0A 0D 53 54 4F 50 ...    830  av3msg:  dc.b   10,13,'STOP: Autovector Level 3 exception occured near address $',0
0000788C= 0A 0D 53 54 4F 50 ...    831  av4msg:  dc.b   10,13,'STOP: Autovector Level 4 exception occured near address $',0
000078C8= 0A 0D 53 54 4F 50 ...    832  av5msg:  dc.b   10,13,'STOP: Autovector Level 5 exception occured near address $',0
00007904= 0A 0D 53 54 4F 50 ...    833  av6msg:  dc.b   10,13,'STOP: Autovector Level 6 exception occured near address $',0
00007940= 0A 0D 53 54 4F 50 ...    834  av7msg:  dc.b   10,13,'STOP: Autovector Level 7 exception occured near address $',0
0000797C= 0A 0D 53 54 4F 50 ...    835  bemsg1:  dc.b   10,13,'STOP: A Bus Error occured whilst executing code at address $',0
000079BB= 0A 0D 20 20 20 20 ...    836  bemsg2:  dc.b   10,13,'    : The address location being accessed was $',0
000079ED= 0A 0D 53 54 4F 50 ...    837  cimsg:   dc.b   10,13,'STOP: CHK exception occured near address $',0
00007A1A= 0A 0D 53 54 4F 50 ...    838  iimsg:   dc.b   10,13,'STOP: Illegal Instruction was encountered near address $',0
00007A55= 0A 0D 53 54 4F 50 ...    839  lamsg:   dc.b   10,13,'STOP: LINE A exception occured near address $',0
00007A85= 0A 0D 53 54 4F 50 ...    840  lfmsg:   dc.b   10,13,'STOP: LINE F exception occured near address $',0
00007AB5= 0A 0D 53 54 4F 50 ...    841  pvmsg:   dc.b   10,13,'STOP: Privilege Viloation exception occured near address $',0
00007AF2= 0A 0D 53 54 4F 50 ...    842  rimsg:   dc.b   10,13,'STOP: Reserved exception occured near address $',0
00007B24= 0A 0D 53 54 4F 50 ...    843  simsg:   dc.b   10,13,'STOP: Spurious Interrupt exception occured near address $',0
00007B60= 0A 0D 53 54 4F 50 ...    844  trmsg:   dc.b   10,13,'STOP: TRACE exception occured near address $',0
00007B8F= 0A 0D 53 54 4F 50 ...    845  tr0msg:  dc.b   10,13,'STOP: TRAP #0 exception occured near address $',0
00007BC0= 0A 0D 53 54 4F 50 ...    846  tr1msg:  dc.b   10,13,'STOP: TRAP #1 exception occured near address $',0
00007BF1= 0A 0D 53 54 4F 50 ...    847  tr2msg:  dc.b   10,13,'STOP: TRAP #2 exception occured near address $',0
00007C22= 0A 0D 53 54 4F 50 ...    848  tr3msg:  dc.b   10,13,'STOP: TRAP #3 exception occured near address $',0
00007C53= 0A 0D 53 54 4F 50 ...    849  tr4msg:  dc.b   10,13,'STOP: TRAP #4 exception occured near address $',0
00007C84= 0A 0D 53 54 4F 50 ...    850  tr5msg:  dc.b   10,13,'STOP: TRAP #5 exception occured near address $',0
00007CB5= 0A 0D 53 54 4F 50 ...    851  tr6msg:  dc.b   10,13,'STOP: TRAP #6 exception occured near address $',0
00007CE6= 0A 0D 53 54 4F 50 ...    852  tr7msg:  dc.b   10,13,'STOP: TRAP #7 exception occured near address $',0
00007D17= 0A 0D 53 54 4F 50 ...    853  tr8msg:  dc.b   10,13,'STOP: TRAP #8 exception occured near address $',0
00007D48= 0A 0D 53 54 4F 50 ...    854  tr9msg:  dc.b   10,13,'STOP: TRAP #9 exception occured near address $',0
00007D79= 0A 0D 53 54 4F 50 ...    855  tr10msg: dc.b   10,13,'STOP: TRAP #10 exception occured near address $',0
00007DAB= 0A 0D 53 54 4F 50 ...    856  tr11msg: dc.b   10,13,'STOP: TRAP #11 exception occured near address $',0
00007DDD= 0A 0D 53 54 4F 50 ...    857  tr12msg: dc.b   10,13,'STOP: TRAP #12 exception occured near address $',0
00007E0F= 0A 0D 53 54 4F 50 ...    858  tr13msg: dc.b   10,13,'STOP: TRAP #13 exception occured near address $',0
00007E41= 0A 0D 53 54 4F 50 ...    859  tr14msg: dc.b   10,13,'STOP: TRAP #14 exception occured near address $',0
00007E73= 0A 0D 53 54 4F 50 ...    860  tr15msg: dc.b   10,13,'STOP: TRAP #15 exception occured near address $',0
00007EA5= 0A 0D 53 54 4F 50 ...    861  tvmsg:   dc.b   10,13,'STOP: TRAPV exception occured near address $',0
00007ED4= 0A 0D 53 54 4F 50 ...    862  uimsg:   dc.b   10,13,'STOP: Uninitialised Interrupt exception occured near address $',0
00007F15= 0A 0D 53 54 4F 50 ...    863  usermsg: dc.b   10,13,'STOP: User exception occured near address $',0
00007F43= 0A 0D 53 54 4F 50 ...    864  zdmsg:   dc.b   10,13,'STOP: Divide By Zero error occured near address $',0
00007F77                           865  
00007F77                           866  * #############################################################################
00007F77                           867  * #############################################################################
00007F77                           868  * C O L D   S T A R T
00007F77                           869  * #############################################################################
00007F77                           870  * #############################################################################
00007F77                           871  
00007F78                           872      ORG     (*+1)&-2    * make we start on a word aligned address
00007F78                           873  START:
00007F78  4FF9 001FF800            874      lea     STACK_START, sp     * Set the stack pointer just in case
00007F7E                           875  
00007F7E                           876      * copy the exception vector table into RAM
00007F7E  207C 00007178            877      move.l  #rom2ramIVT,a0      * start of exception table in ROM
00007F84  227C 00100000            878      move.l  #VEC_BASE,a1        * location in RAM to copy table to
00007F8A  203C 000000FF            879      move.l  #255,d0             * 256 entries to copy
00007F90                           880  .copy:
00007F90  22D8                     881      move.l  (a0)+,(a1)+     * copy the byte from ROM to RAM
00007F92  51C8 FFFC                882      dbra    d0,.copy
00007F96                           883  
00007F96                           884  *------------------------------------------------------------------------------
00007F96                           885  * Initialise the SCC68692 DUART port A
00007F96                           886  *------------------------------------------------------------------------------
00007F96                           887  
00007F96  13FC 0030 00D00005       888      move.b  #$30, CRA       * Reset Transmitter
00007F9E  13FC 0020 00D00005       889      move.b  #$20, CRA       * Reset Reciever
00007FA6  13FC 0010 00D00005       890      move.b  #$10, CRA       * Reset Mode Register Pointer
00007FAE                           891      
00007FAE  13FC 0000 00D00009       892      move.b  #$00, ACR       * Baud Rate Set #1
00007FB6  13FC 0013 00D00001       893      move.b  #$13, MRA       * No Parity & 8-bit
00007FBE  13FC 0007 00D00001       894      move.b  #$07, MRA       * Normal Mode, No CTS/RTS & 1 stop bit
00007FC6  13FC 00CC 00D00003       895      move.b  #BAUD_RATE, CSRA      * Set Tx and Rx baud rates
00007FCE  13FC 0000 00D0000B       896      move.b  #$00, IMR       * No interrupts
00007FD6  13FC 0005 00D00005       897      move.b  #$05, CRA       * Enable Transmit/Recieve
00007FDE  13FC 0003 00D0001D       898      move.b  #$03, SOPR      * Turn off the 2 user LEDs on OP0 & OP1
00007FE6                           899  
00007FE6                 FALSE     900      iflt USE_REAL_UART
00007FE6                           901      ; using Sim68K COM port
00007FE6                           902      ; initialise the serial port
00007FE6                           903      ; set port parameters
00007FE6                           904      endc
00007FE6                           905      
00007FE6                           906  *------------------------------------------------------------------------------
00007FE6                           907  * Warm Restart entry point
00007FE6                           908  *------------------------------------------------------------------------------
00007FE6                           909  monStart:
00007FE6  41FA 058C                910      lea     strBanner1(PC), a0  * Show the monitor details
00007FEA  6100 0550                911      bsr.w   putString
00007FEE                           912  
00007FEE  41FA 05E2                913      lea     strCommands(PC), a0 * And the command help message
00007FF2  6100 0548                914      bsr.w   putString
00007FF6                           915  
00007FF6                           916  monLoop:
00007FF6  41FA 0781                917      lea     strPrompt(PC), a0   * Prompt
00007FFA  6100 0540                918      bsr.w   putString
00007FFE                           919  
00007FFE                           920  monLoop_NP:
00007FFE  6100 0558                921      bsr.w   getc            * get a character into D0
00008002  6100 0348                922      bsr.w   chToUpper       * convert character to upper case
00008006                           923      
00008006  0C00 000A                924      cmpi.b  #LF,d0          * ignore Line-Feed
0000800A  67EA                     925      beq.s   monLoop
0000800C                           926      
0000800C  B03C 0042                927      cmp.b   #'B', d0        * Boot EhBASIC v3.54
00008010  6700 005E                928      beq.w   cmdBootEHBASIC
00008014                           929  
00008014  B03C 0043                930      cmp.b   #'C', d0        * Boot CP/M-68K
00008018  6700 007E                931      beq.w   cmdBootCPM
0000801C                           932  
0000801C  B03C 0044                933      cmp.b   #'D', d0        * Dump memory command
00008020  6700 00B0                934      beq.w   cmdDispMemory
00008024                           935  
00008024  B03C 0049                936      cmp.b   #'I', d0        * Read from I/O space address
00008028  6700 00F2                937      beq.w   cmdIORead
0000802C                           938  
0000802C  B03C 004D                939      cmp.b   #'M', d0        * Modify memory command
00008030  6700 012C                940      beq.w   cmdModifyMemory
00008034                           941  
00008034  B03C 004F                942      cmp.b   #'O', d0        * Write to I/O space address
00008038  6700 0182                943      beq.w   cmdIOWrite
0000803C                           944  
0000803C  B03C 0053                945      cmp.b   #'S', d0        * S record download
00008040  6700 01C4                946      beq.w   cmdDownload
00008044                           947  
00008044  B03C 0047                948      cmp.b   #'G', d0        * Go command
00008048  6700 00AA                949      beq.w   cmdRun
0000804C                           950  
0000804C  B03C 003F                951      cmp.b   #'?', d0        * Help command
00008050  6700 0288                952      beq.w   cmdHelp
00008054                           953  
00008054  B03C 0020                954      cmp.b   #' ', d0        * Ignore spaces
00008058  6FA4                     955      ble.s   monLoop_NP      * go back without printing prompt    
0000805A                           956  
0000805A  1200                     957      move.b  d0,d1           * save the unknown char
0000805C  41FA 071E                958      lea     strUnkCmd(PC), a0   * unknown command
00008060  6100 04DA                959      bsr.w   putString
00008064  1001                     960      move.b  d1,d0           * get unnknown char back
00008066  6100 04AE                961      bsr.w   writeByte       * print it
0000806A                           962      
0000806A                           963  monLoop_CRLF:
0000806A  6100 04CC                964      bsr.w   putCRLF
0000806E  6086                     965      bra.s   monLoop
00008070                           966      
00008070                           967  *------------------------------------------------------------------------------
00008070                           968  * (B) Boot EhBASIC v3.54
00008070                           969  *------------------------------------------------------------------------------
00008070                           970  cmdBootEHBASIC:
00008070                           971      * perform a simple check to see if EhBASIC has been programmed into the
00008070                           972      * EEPROM by reading address 0x9000 in the EEPROM. If it contains 0xFFFF,
00008070                           973      * then EhBASIC hasn't been programmed in!
00008070  0C79 FFFF 00009000       974      cmpi.w  #$FFFF,EHBASIC_BASE
00008078  660C                     975      bne.s   .bootEHBASIC
0000807A  41FA 0832                976      lea     strBASICErr1(PC), a0
0000807E  6100 04BC                977      bsr.w   putString
00008082  6000 FF72                978      bra.w   monLoop
00008086                           979  
00008086                           980  .bootEHBASIC:
00008086  207C 00009000            981      move.l  #EHBASIC_BASE,a0
0000808C  4E90                     982      jsr     (a0)            * jump to EhBASIC 
0000808E                           983  
0000808E                           984      * I don't think EhBASIC can return back to the monitor but just in case it can
0000808E                           985      * print out a message and wait for a reset.
0000808E  41FA 0854                986      lea     strBASICReturn(PC), a0
00008092  6100 04A8                987      bsr.w   putString
00008096                           988  .forever:
00008096  60FE                     989      bra.s   .forever
00008098                           990  
00008098                           991  *------------------------------------------------------------------------------
00008098                           992  * (C) Boot CP/M-68K v1.3
00008098                           993  *------------------------------------------------------------------------------
00008098                           994  cmdBootCPM:
00008098                           995      * perform a simple check to see if CP/M has been programmed into the EEPROM
00008098                           996      * by reading address 0x0400 in the EEPROM. If it contains 0xFFFF then CP/M
00008098                           997      * hasn't been programmed in!
00008098  0C78 FFFF 0400           998      cmpi.w  #$FFFF,CPM_BASE
0000809E  660C                     999      bne.s   .chkBIOS
000080A0  41FA 075D               1000      lea     strCPMErr1(PC), a0
000080A4  6100 0496               1001      bsr.w   putString
000080A8  6000 FF4C               1002      bra.w   monLoop
000080AC                          1003      
000080AC                          1004  .chkBIOS:   
000080AC                          1005      * perform a simple check to see if the BIOS has been programmed into the EEPROM
000080AC                          1006      * by reading address 0x0400 in the EEPROM. If it contains 0xFFFF then the CP/M
000080AC                          1007      * BIOS hasn't been programmed in!
000080AC  0C78 FFFF 6000          1008      cmpi.w  #$FFFF,$6000
000080B2  660C                    1009      bne.s   .bootCPM
000080B4  41FA 0781               1010      lea     strCPMErr2(PC), a0
000080B8  6100 0482               1011      bsr.w   putString
000080BC  6000 FF38               1012      bra.w   monLoop
000080C0                          1013      
000080C0                          1014  .bootCPM:
000080C0  207C 00000400           1015      move.l  #CPM_BASE,a0
000080C6  4E90                    1016      jsr     (a0)            * jump to CP/M-68K 
000080C8                          1017      
000080C8                          1018      * I don't think CP/M-68K can return back to the moitor but just in case it can
000080C8                          1019      * print out a message and wait for a reset.
000080C8  41FA 07AA               1020      lea     strCPMReturn(PC), a0
000080CC  6100 046E               1021      bsr.w   putString
000080D0                          1022  .forever:
000080D0  60FE                    1023      bra.s   .forever
000080D2                          1024      
000080D2                          1025  *------------------------------------------------------------------------------
000080D2                          1026  * (D)ump memory
000080D2                          1027  * Display 256 bytes of memory as ASCII-HEX characters
000080D2                          1028  *------------------------------------------------------------------------------
000080D2                          1029  cmdDispMemory:
000080D2  6100 0472               1030      bsr.w   putc            * echo back the command character in D0
000080D6  103C 0020               1031      move.b  #' ',d0
000080DA  6100 046A               1032      bsr.w   putc
000080DE                          1033      
000080DE  4282                    1034      clr.l   d2              * pre-set D2 to 0
000080E0  7208                    1035      move.l  #8,d1           * read up to 8 digits
000080E2  6100 02C6               1036      bsr.w   hexToIntEcho    * from the serial port into D0
000080E6  6500 FF0E               1037      bcs.w   monLoop         * back to prompt if there's an error
000080EA                          1038      
000080EA  2040                    1039      move.l  d0,a0           * A0 holds the start address
000080EC  6100 01F8               1040      bsr.w   dumpRAM
000080F0                          1041  
000080F0  6000 FF04               1042      bra.w   monLoop
000080F4                          1043  
000080F4                          1044  *------------------------------------------------------------------------------
000080F4                          1045  * (G)o - execute code in memory starting at the specified address
000080F4                          1046  *------------------------------------------------------------------------------
000080F4                          1047  cmdRun:
000080F4  6100 0450               1048      bsr.w   putc            * echo back the command character in D0
000080F8  103C 0020               1049      move.b  #' ',d0
000080FC  6100 0448               1050      bsr.w   putc
00008100                          1051  
00008100  4282                    1052      clr.l   d2              * pre-set D2 to 0
00008102  7208                    1053      move.l  #8,d1           * read up to 8 digits
00008104  6100 02A4               1054      bsr.w   hexToIntEcho    * from the serial port
00008108  6500 FEEC               1055      bcs.w   monLoop         * back to prompt if there's an error
0000810C                          1056  
0000810C  2040                    1057      move.l  d0, a0          * copy start address into A0
0000810E  4E90                    1058      jsr     (a0)            * jump to user code
00008110                          1059      
00008110  41FA 0699               1060      lea     strUserReturn(PC),a0
00008114  6100 0426               1061      bsr.w   putString
00008118                          1062      
00008118  6000 FEDC               1063      bra.w   monLoop
0000811C                          1064  
0000811C                          1065  *------------------------------------------------------------------------------
0000811C                          1066  * (I)nput a byte from I/O space address
0000811C                          1067  *------------------------------------------------------------------------------
0000811C                          1068  cmdIORead:
0000811C  6100 0428               1069      bsr.w   putc            * echo back the command character in D0
00008120  103C 0020               1070      move.b  #' ',d0
00008124  6100 0420               1071      bsr.w   putc
00008128                          1072  
00008128  4282                    1073      clr.l   d2              * pre-set D2 to 0
0000812A  7202                    1074      move.l  #2,d1           * read up to 2 digit address
0000812C  6100 027C               1075      bsr.w   hexToIntEcho    * from the serial port
00008130  6500 FEC4               1076      bcs.w   monLoop         * back to prompt if there's an error
00008134  1600                    1077      move.b  d0,d3           * save the typed in 8-bit address
00008136  103C 003D               1078      move.b  #'=',d0
0000813A  6100 040A               1079      bsr.w   putc            * send an EQUALS
0000813E                          1080  
0000813E                          1081      ; D3 = 8-bit address
0000813E  207C 00F80000           1082      movea.l #IO_BASE,a0
00008144  0283 000000FF           1083      andi.l  #$FF,d3         * clear all the unused bits
0000814A  E383                    1084      asl.l   #1,d3           * make it a word offset
0000814C  5283                    1085      addi.l  #1,d3           * make it an odd address to read from D0..D7
0000814E  1030 3000               1086      move.b  (0,a0,d3),d0    * and read the new value in
00008152  6100 03C2               1087      bsr.w   writeByte       * display the value
00008156  6100 03E0               1088      bsr.w   putCRLF
0000815A  6000 FE9A               1089      bra.w   monLoop
0000815E                          1090  
0000815E                          1091  *------------------------------------------------------------------------------
0000815E                          1092  * (M)odify memory
0000815E                          1093  * Change memory contents 1 byte at a time
0000815E                          1094  *------------------------------------------------------------------------------
0000815E                          1095  cmdModifyMemory:
0000815E  6100 03E6               1096      bsr.w   putc            * echo back the command character in D0
00008162  103C 0020               1097      move.b  #' ',d0
00008166  6100 03DE               1098      bsr.w   putc
0000816A                          1099  
0000816A  4282                    1100      clr.l   d2              * pre-set D2 to 0
0000816C  7208                    1101      move.l  #8,d1           * read up to 8 digits
0000816E  6100 023A               1102      bsr.w   hexToIntEcho    * from the serial port
00008172  6500 FE82               1103      bcs.w   monLoop         * back to prompt if there's an error
00008176  1200                    1104      move.b  d0,d1           * save the typed in address
00008178  6100 03BE               1105      bsr.w   putCRLF
0000817C  1001                    1106      move.b  d1,d0           * restore the typed in address
0000817E                          1107      
0000817E  2040                    1108      move.l  d0,a0           * copy address into A0
00008180                          1109  .cMM_1:
00008180  6100 0376               1110      bsr.w   writeAddr32     * display the memory location address
00008184  103C 0020               1111      move.b  #' ',d0
00008188  6100 03BC               1112      bsr.w   putc
0000818C  1010                    1113      move.b  (a0),d0         * get the current memory contents
0000818E  1400                    1114      move.b  d0,d2           * pre-set D2 to the existing memory value
00008190  6100 0384               1115      bsr.w   writeByte       * display the byte
00008194  103C 0020               1116      move.b  #' ',d0
00008198  6100 03AC               1117      bsr.w   putc
0000819C  7202                    1118      move.l  #2,d1           * read up to 2 digits
0000819E  6100 020A               1119      bsr.w   hexToIntEcho    * from the serial port
000081A2  6500 0010               1120      bcs.w   .cMM_2          * back to prompt if there's an error
000081A6                          1121  
000081A6  10C0                    1122      move.b  d0,(a0)+        * write out the new byte and move on
000081A8  2F08                    1123      move.l  a0,-(SP)        * save our address
000081AA  6100 038C               1124      bsr.w   putCRLF
000081AE  205F                    1125      move.l  (SP)+,a0        * restore our address
000081B0  2008                    1126      move.l  a0,d0           * copy address back into D0 for printing
000081B2  60CC                    1127      bra.s   .cMM_1
000081B4                          1128  
000081B4                          1129  .cMM_2:
000081B4  6100 0382               1130      bsr.w   putCRLF
000081B8  6000 FE3C               1131      bra.w   monLoop
000081BC                          1132      
000081BC                          1133  *------------------------------------------------------------------------------
000081BC                          1134  * (O)utput a byte to I/O space address
000081BC                          1135  *------------------------------------------------------------------------------
000081BC                          1136  cmdIOWrite:
000081BC  6100 0388               1137      bsr.w   putc            * echo back the command character in D0
000081C0  103C 0020               1138      move.b  #' ',d0
000081C4  6100 0380               1139      bsr.w   putc
000081C8                          1140  
000081C8  4282                    1141      clr.l   d2              * pre-set D2 to 0
000081CA  7202                    1142      move.l  #2,d1           * read up to 2 digit address
000081CC  6100 01DC               1143      bsr.w   hexToIntEcho    * from the serial port
000081D0  6500 FE24               1144      bcs.w   monLoop         * back to prompt if there's an error
000081D4  1600                    1145      move.b  d0,d3           * save the typed in 8-bit address
000081D6  103C 003D               1146      move.b  #'=',d0
000081DA  6100 036A               1147      bsr.w   putc            * send an EQUALS
000081DE                          1148  
000081DE  4282                    1149      clr.l   d2              * pre-set D2 to 0
000081E0  7202                    1150      move.l  #2,d1           * read up to 2 digit value
000081E2  6100 01C6               1151      bsr.w   hexToIntEcho    * from the serial port
000081E6  6500 FE0E               1152      bcs.w   monLoop         * back to prompt if there's an error
000081EA                          1153  
000081EA                          1154      ; D0 = value and D3 = 8-bit address
000081EA  207C 00F80000           1155      movea.l #IO_BASE,a0
000081F0  0283 000000FF           1156      andi.l  #$FF,d3         * clear all the unused bits
000081F6  E383                    1157      asl.l   #1,d3           * make it a word offset
000081F8  5283                    1158      addi.l  #1,d3           * make it an odd address to write to D0..D7
000081FA  1180 3000               1159      move.b  d0,(0,a0,d3)    * and write the new value out
000081FE                          1160  
000081FE  6100 0338               1161      bsr.w   putCRLF
00008202  6000 FDF2               1162      bra.w   monLoop
00008206                          1163  
00008206                          1164  *------------------------------------------------------------------------------
00008206                          1165  * (S) - download a single line of a Motorola S-Record
00008206                          1166  *------------------------------------------------------------------------------
00008206                          1167  cmdDownload:
00008206  6100 0350               1168      bsr.w   getc            * get the S-Record type
0000820A  B03C 0031               1169      cmp.b   #'1', d0
0000820E  671A                    1170      beq.s   .cdl_S1         * read in an S1 record
00008210  B03C 0032               1171      cmp.b   #'2', d0
00008214  6738                    1172      beq.s   .cdl_S2         * read in an S2 record
00008216  B03C 0038               1173      cmp.b   #'8', d0
0000821A  6700 00A8               1174      beq.w   .cdl_EOL89      * handle S8 SRec terminator
0000821E  B03C 0039               1175      cmp.b   #'9', d0
00008222  6700 00A0               1176      beq.w   .cdl_EOL89      * handle S9 SRec terminator
00008226                          1177  
00008226  6600 008A               1178      bne     .cdl_EOL        * not S1 or S2 so ignore to end of line
0000822A                          1179              
0000822A                          1180  .cdl_S1:        
0000822A  4282                    1181      clr.l   d2
0000822C  123C 0002               1182      move.b  #2, d1          * 2 characters to read
00008230  6100 013E               1183      bsr     hexToInt        * convert to byte count
00008234  2C00                    1184      move.l  d0, d6          * D6 = byte count
00008236  2E00                    1185      move.l  d0, d7          * D7 = byte count (running checksum)
00008238                          1186  
00008238  4282                    1187      clr.l   d2
0000823A  123C 0004               1188      move.b  #4, d1          * 4 characters to read
0000823E  6100 0130               1189      bsr     hexToInt        * convert to address
00008242  2640                    1190      movea.l d0, a3          * A3 = destination address
00008244  DE00                    1191      add.b   d0, d7          * update checksum with bits 00..07
00008246  E088                    1192      lsr.l   #8, d0
00008248  DE00                    1193      add.b   d0, d7          * update checksum with bits 08..15
0000824A                          1194  
0000824A  5746                    1195      subq.w  #3, D6          * take off the 3 bytes we just read in
0000824C                          1196  
0000824C  6026                    1197      bra.s   .cdl_1              
0000824E                          1198                  
0000824E                          1199  .cdl_S2:            
0000824E  4282                    1200      clr.l   d2
00008250  123C 0002               1201      move.b  #2, d1          * 2 characters to read
00008254  6100 011A               1202      bsr     hexToInt        * convert to byte count
00008258  2C00                    1203      move.l  d0, d6          * D6 = byte count
0000825A  2E00                    1204      move.l  d0, d7          * D7 = byte count (running checksum)
0000825C                          1205  
0000825C  4282                    1206      clr.l   d2
0000825E  123C 0006               1207      move.b  #6, d1          * 6 characters to read
00008262  6100 010C               1208      bsr     hexToInt        * convert to address
00008266  2640                    1209      movea.l d0, a3          * A3 = destination address
00008268  DE00                    1210      add.b   d0, d7          * update checksum with bits 00..07
0000826A  E088                    1211      lsr.l   #8, d0
0000826C  DE00                    1212      add.b   d0, d7          * update checksum with bits 08..15
0000826E  E088                    1213      lsr.l   #8, d0
00008270  DE00                    1214      add.b   d0, d7          * update checksum with bits 16..23
00008272                          1215  
00008272  5946                    1216      subq.w  #4, d6          * take off the 4 bytes we just read in
00008274                          1217  
00008274                          1218  .cdl_1:
00008274  4A46                    1219      tst.w   d6              * read all the bytes yet?
00008276  6712                    1220      beq.s   .cdl_2
00008278                          1221  
00008278  4282                    1222      clr.l   d2
0000827A  323C 0002               1223      move.w  #2, d1          * 2 characters to read
0000827E  6100 00F0               1224      bsr     hexToInt        * convert to data byte
00008282  16C0                    1225      move.b  d0, (a3)+       * write the byte to memory
00008284  DE00                    1226      add.b   d0, d7          * update checksum
00008286  5346                    1227      subq.w  #1, d6          * decrement byte count
00008288  60EA                    1228      bra.s   .cdl_1
0000828A                          1229  
0000828A                          1230  .cdl_2:
0000828A  4282                    1231      clr.l   d2
0000828C  323C 0002               1232      move.w  #2, d1          * 2 characters to read
00008290  6100 00DE               1233      bsr     hexToInt        * convert to checksum byte
00008294  DE00                    1234      add.b   d0, d7          * D7 = calc checksum + srec checksum
00008296  5207                    1235      addq.b  #1, d7          * checksum + 1 should = 0 if OK
00008298  670C                    1236      beq.s   .cdl_X
0000829A                          1237  
0000829A  103C 0058               1238      move.b  #'X', d0        * checksum fail - print an X
0000829E  6100 02A6               1239      bsr     putc
000082A2  6000 FD5A               1240      bra.w   monLoop_NP      * return to main loop without prompt
000082A6                          1241  
000082A6                          1242  .cdl_X
000082A6  103C 002E               1243      move.b  #'.', d0        * checksum good - print a dot
000082AA  6100 029A               1244      bsr     putc
000082AE  6000 FD4E               1245      bra.w   monLoop_NP      * return to main loop without prompt
000082B2                          1246  
000082B2                          1247  .cdl_EOL
000082B2  6100 02A4               1248      bsr.w   getc            * discard chars until CR or LF
000082B6  0C00 000D               1249      cmpi.b  #CR,d0
000082BA  67EA                    1250      beq.s   .cdl_X
000082BC  0C00 000A               1251      cmpi.b  #LF,d0
000082C0  67E4                    1252      beq.s   .cdl_X
000082C2  60EE                    1253      bra.s   .cdl_EOL
000082C4                          1254  
000082C4                          1255  .cdl_EOL89
000082C4  6100 0292               1256      bsr.w   getc            * discard chars until CR or LF
000082C8  0C00 000D               1257      cmpi.b  #CR,d0
000082CC  6700 FD9C               1258      beq.w   monLoop_CRLF    * return to main loop with prompt
000082D0  0C00 000A               1259      cmpi.b  #LF,d0
000082D4  6700 FD94               1260      beq.w   monLoop_CRLF    * return to main loop with prompt
000082D8  60EA                    1261      bra.s   .cdl_EOL89
000082DA                          1262      
000082DA                          1263  *------------------------------------------------------------------------------
000082DA                          1264  * Display the supported commands
000082DA                          1265  *------------------------------------------------------------------------------
000082DA                          1266  cmdHelp:
000082DA  41FA 02F6               1267      lea     strCommands(PC), a0
000082DE  6100 025C               1268      bsr.w   putString
000082E2  6000 FD12               1269      bra.w   monLoop
000082E6                          1270  
000082E6                          1271  *------------------------------------------------------------------------------
000082E6                          1272  * Dumps a 256 section of RAM to the screen
000082E6                          1273  * Displays both hex values and ASCII characters
000082E6                          1274  * a0 - Start Address
000082E6                          1275  *------------------------------------------------------------------------------
000082E6                          1276  dumpRAM:
000082E6  48E7 E040               1277      movem.l d0-d2/a1, -(SP) * Save registers
000082EA  2248                    1278      move.l  a0,a1           * move the start address to A1
000082EC                          1279  
000082EC  6100 024A               1280      bsr.w   putCRLF         * new line - trashes D0 & A0
000082F0                          1281      
000082F0  323C 000F               1282      move.w  #15,d1          * 16 rows of data (DBRA needs 1 less!)
000082F4                          1283  .dr_1:
000082F4  343C 000F               1284      move.w  #15,d2          * 16 bytes of data per row (DBRA needs 1 less!)
000082F8  2009                    1285      move.l  a1, d0          * copy the start address of the line into D0          
000082FA  6100 01FC               1286      bsr.w   writeAddr32     * Display as a 32-bit hex value
000082FE  41FA 0491               1287      lea     strColonSpace(PC), a0
00008302  6100 0238               1288      bsr.w   putString
00008306  41F9 001FF800           1289      lea     msgASCIIDump, a0
0000830C                          1290  .dr_2:
0000830C  1019                    1291      move.b  (a1)+, d0       * Read a byte from RAM
0000830E  6100 0206               1292      bsr.w   writeByte       * display byte as 2 hex digits  
00008312  6100 004A               1293      bsr.w   makePrintable   * convert to printable character
00008316  10C0                    1294      move.b  d0,(a0)+        * save the printable char in output string
00008318  103C 0020               1295      move.b  #' ', d0
0000831C  6100 0228               1296      bsr.w   putc            * insert a space
00008320  51CA FFEA               1297      dbra    d2,.dr_2
00008324                          1298  
00008324  103C 0020               1299      move.b  #' ', d0
00008328  6100 021C               1300      bsr.w   putc            * insert a space
0000832C                          1301  
0000832C  10FC 000D               1302      move.b  #CR,(a0)+
00008330  10FC 000A               1303      move.b  #LF,(a0)+
00008334  10FC 0000               1304      move.b  #0,(a0)+
00008338  41F9 001FF800           1305      lea     msgASCIIDump, a0
0000833E  6100 01FC               1306      bsr.w   putString       * print out the printable bytes
00008342  51C9 FFB0               1307      dbra    d1,.dr_1
00008346                          1308  
00008346  4CDF 0207               1309      movem.l (SP)+, d0-d2/a1 * Restore registers
0000834A  4E75                    1310      rts
0000834C                          1311              
0000834C                          1312  *------------------------------------------------------------------------------
0000834C                          1313  * Convert character in D0 to upper case
0000834C                          1314  * Only changes D0 if char is between 'a'..'z'
0000834C                          1315  *------------------------------------------------------------------------------
0000834C                          1316  chToUpper:
0000834C  B03C 0061               1317      cmp.b   #'a', d0         
00008350  6D0A                    1318      blt.s   .done            * less than lower-case 'a' so leave alone
00008352  B03C 007A               1319      cmp.b   #'z', d0
00008356  6E04                    1320      bgt.s   .done            * greater than lower-case 'z' so leave alone
00008358  0400 0020               1321      sub.b   #$20, d0         * convert to upper case
0000835C                          1322  .done:
0000835C  4E75                    1323      rts
0000835E                          1324      
0000835E                          1325  *------------------------------------------------------------------------------
0000835E                          1326  * Convert a byte into a print safe character
0000835E                          1327  * Substitute a '.' for any byte <32 or >126
0000835E                          1328  * D0 holds the byte
0000835E                          1329  *------------------------------------------------------------------------------
0000835E                          1330  makePrintable:
0000835E  B03C 0020               1331      cmp.b   #' ', d0         
00008362  6D06                    1332      blt.s   .mp_1           * less than a SPACE (char 32)
00008364                          1333  
00008364  B03C 007E               1334      cmp.b   #'~', d0         
00008368  6F04                    1335      ble.s   .mp_x           * less than a DEL (char 127)
0000836A                          1336  
0000836A                          1337  .mp_1:
0000836A  103C 002E               1338      move.b  #'.',d0         * substitute a DOT (char 46)
0000836E                          1339  .mp_x:
0000836E  4E75                    1340      rts
00008370                          1341      
00008370                          1342  *--------------------------------------------------------------------------
00008370                          1343  * Read in an ASCII-HEX number - no echo back
00008370                          1344  *
00008370                          1345  * D2 = Value to return if no digits read in
00008370                          1346  * D1 = Max no of ASCII digits to read in
00008370                          1347  * D0 = Result
00008370                          1348  * Carry flag set if an error occurs / not ASCII-HEX digit
00008370                          1349  *--------------------------------------------------------------------------
00008370                          1350  hexToInt:
00008370                          1351  *   move.l  d2,-(SP)        * save D2
00008370                          1352  *   clr.l   d2              * D2 used to accumulate the final value
00008370                          1353  .h2i_1:
00008370  6100 01E6               1354      bsr.w   getc            * get a character
00008374  61D6                    1355      bsr.s   chToUpper       * convert to upper case if needed
00008376                          1356  
00008376  0C00 000A               1357      cmpi.b  #10,d0          * finish if it's CR or LF
0000837A  6724                    1358      beq.s   .h2i_x
0000837C  0C00 000D               1359      cmpi.b  #13,d0
00008380  671E                    1360      beq.s   .h2i_x
00008382                          1361      
00008382  0400 0030               1362      subi.b  #'0',d0
00008386  6B1C                    1363      bmi.s   .h2i_err        * quit if char is less than '0'
00008388                          1364  
00008388  0C00 0009               1365      cmpi.b  #9,d0
0000838C  6F0A                    1366      ble.s   .h2i_2          * is it <= 9
0000838E                          1367      
0000838E  5F00                    1368      subi.b  #7,d0
00008390  6B12                    1369      bmi.s   .h2i_err        * quit if char is >'9' and <'A'
00008392                          1370  
00008392  0C00 000F               1371      cmpi.b  #15,d0
00008396  6E0C                    1372      bgt.s   .h2i_err        * quit if char is >'F'
00008398                          1373  
00008398                          1374  .h2i_2:
00008398  E98A                    1375      lsl.l   #4, d2
0000839A  8400                    1376      or.b    d0, d2          * insert the new digit
0000839C                          1377  
0000839C  5301                    1378      subq.b  #1, d1          * decrement the digit count
0000839E  66D0                    1379      bne.s   .h2i_1          * go back for another digit?
000083A0                          1380  
000083A0                          1381  .h2i_x:
000083A0  2002                    1382      move.l  d2,d0           * put the answer back into D0
000083A2                          1383  *   move.l  (SP)+,d2        * restore D2
000083A2  4E75                    1384      rts
000083A4                          1385  
000083A4                          1386  .h2i_err:
000083A4                          1387  *   move.l  (SP)+,d2        * restore D2
000083A4  003C 0001               1388      ori.b   #1,CCR          * set the CARRY flag to signal an error
000083A8  4E75                    1389      rts
000083AA                          1390  
000083AA                          1391  *--------------------------------------------------------------------------
000083AA                          1392  * Read in an ASCII-HEX number with echo back
000083AA                          1393  *
000083AA                          1394  * D2 = Value to return if no digits read in
000083AA                          1395  * D1 = Max no of ASCII digits to read in
000083AA                          1396  * D0 = Result
000083AA                          1397  * Carry flag set if an error occurs / not ASCII-HEX digit
000083AA                          1398  *--------------------------------------------------------------------------
000083AA                          1399  hexToIntEcho:
000083AA                          1400  *   move.l  d2,-(SP)        * save D2
000083AA                          1401  *   clr.l   d2              * D2 used to accumulate the final value
000083AA                          1402  .h2i_1:
000083AA  6100 01AC               1403      bsr.w   getc            * get a character
000083AE  6100 0196               1404      bsr.w   putc            * echo it back
000083B2  6198                    1405      bsr.s   chToUpper       * convert to upper case if needed
000083B4                          1406  
000083B4  0C00 000A               1407      cmpi.b  #10,d0          * finish if it's CR or LF
000083B8  6724                    1408      beq.s   .h2i_x
000083BA  0C00 000D               1409      cmpi.b  #13,d0
000083BE  671E                    1410      beq.s   .h2i_x
000083C0                          1411      
000083C0  0400 0030               1412      subi.b  #'0',d0
000083C4  6B1C                    1413      bmi.s   .h2i_err        * quit if char is less than '0'
000083C6                          1414  
000083C6  0C00 0009               1415      cmpi.b  #9,d0
000083CA  6F0A                    1416      ble.s   .h2i_2          * is it <= 9
000083CC                          1417      
000083CC  5F00                    1418      subi.b  #7,d0
000083CE  6B12                    1419      bmi.s   .h2i_err        * quit if char is >'9' and <'A'
000083D0                          1420  
000083D0  0C00 000F               1421      cmpi.b  #15,d0
000083D4  6E0C                    1422      bgt.s   .h2i_err        * quit if char is >'F'
000083D6                          1423  
000083D6                          1424  .h2i_2:
000083D6  E98A                    1425      lsl.l   #4, d2
000083D8  8400                    1426      or.b    d0, d2          * insert the new digit
000083DA                          1427  
000083DA  5301                    1428      subq.b  #1, d1          * decrement the digit count
000083DC  66CC                    1429      bne.s   .h2i_1          * go back for another digit?
000083DE                          1430  
000083DE                          1431  .h2i_x:
000083DE  2002                    1432      move.l  d2,d0           * put the answer back into D0
000083E0                          1433  *   move.l  (SP)+,d2        * restore D2
000083E0  4E75                    1434      rts
000083E2                          1435  
000083E2                          1436  .h2i_err:
000083E2                          1437  *   move.l  (SP)+,d2        * restore D2
000083E2  003C 0001               1438      ori.b   #1,CCR          * set the CARRY flag to signal an error
000083E6  4E75                    1439      rts
000083E8                          1440  
000083E8                          1441  *==============================================================================
000083E8                          1442  *==============================================================================
000083E8                          1443  * EASy68K TRAP #15 routines
000083E8                          1444  *==============================================================================
000083E8                          1445  *==============================================================================
000083E8                          1446  
000083E8                          1447  *------------------------------------------------------------------------------
000083E8                          1448  * This is the jump table for the TRAP #15 tasks - not all tasks are supported!
000083E8                          1449  *------------------------------------------------------------------------------
000083E8                          1450  
000083E8                          1451  easy68kTaskTable:
000083E8  6000 008A               1452      bra.w   easyTask0 
000083EC  6000 009E               1453      bra.w   easyTask1 
000083F0  6000 005E               1454      bra.w   easyTask2 
000083F4  6000 005A               1455      bra.w   easyTask3 
000083F8  6000 0056               1456      bra.w   easyTask4 
000083FC  6000 00A2               1457      bra.w   easyTask5 
00008400  6000 00A6               1458      bra.w   easyTask6 
00008404  6000 00AA               1459      bra.w   easyTask7 
00008408  6000 0046               1460      bra.w   easyTask8 
0000840C  6000 0042               1461      bra.w   easyTask9 
00008410  6000 003E               1462      bra.w   easyTask10
00008414  6000 003A               1463      bra.w   easyTask11
00008418  6000 0036               1464      bra.w   easyTask12
0000841C  6000 009E               1465      bra.w   easyTask13
00008420  6000 00AA               1466      bra.w   easyTask14
00008424  6000 002A               1467      bra.w   easyTask15
00008428  6000 0026               1468      bra.w   easyTask16
0000842C  6000 0022               1469      bra.w   easyTask17
00008430  6000 001E               1470      bra.w   easyTask18
00008434  6000 001A               1471      bra.w   easyTask19
00008438  6000 0016               1472      bra.w   easyTask20
0000843C  6000 0012               1473      bra.w   easyTask21
00008440  6000 000E               1474      bra.w   easyTask22
00008444  6000 000A               1475      bra.w   easyTask23
00008448  6000 0006               1476      bra.w   easyTask24
0000844C  6000 0002               1477      bra.w   easyTask25
00008450                          1478  
00008450                          1479  *------------------------------------------------------------------------------
00008450                          1480  * These are the EASy68K tasks not yet implemented
00008450                          1481  * The required task number is in D0
00008450                          1482  * Display a message and stop in an endless loop.
00008450                          1483  *------------------------------------------------------------------------------
00008450                          1484  
00008450                          1485  easyTask2: 
00008450                          1486  easyTask3:
00008450                          1487  easyTask4:
00008450                          1488  easyTask8: 
00008450                          1489  easyTask9: 
00008450                          1490  easyTask10:
00008450                          1491  easyTask11:
00008450                          1492  easyTask12:
00008450                          1493  easyTask15:
00008450                          1494  easyTask16:
00008450                          1495  easyTask17:
00008450                          1496  easyTask18:
00008450                          1497  easyTask19:
00008450                          1498  easyTask20:
00008450                          1499  easyTask21:
00008450                          1500  easyTask22:
00008450                          1501  easyTask23:
00008450                          1502  easyTask24:
00008450                          1503  easyTask25:
00008450                          1504  easyTaskUnsupported:
00008450  C141                    1505      exg     d0,d1           ; put the task number into D1
00008452  41FA 0373               1506      lea     strEasyTask1(PC), a0
00008456  6100 00E4               1507      bsr.w   putString
0000845A  C141                    1508      exg     d0,d1           ; put the task number back into D0
0000845C  80FC 000A               1509      divu    #10,d0          ; divide task number by 10
00008460  6100 00BC               1510      bsr.w   writeNibble     ; output the 10's digit
00008464  4840                    1511      swap    d0
00008466  6100 00B6               1512      bsr.w   writeNibble     ; output the 1's digit
0000846A  41FA 037C               1513      lea     strEasyTask2(PC), a0
0000846E  6100 00CC               1514      bsr.w   putString
00008472                          1515  .infloop:
00008472  60FE                    1516      bra.s   .infloop
00008474                          1517  
00008474                          1518  *------------------------------------------------------------------------------
00008474                          1519  * EASy68K TRAP #15 - Task 0
00008474                          1520  * Display n characters of string at (A1), n is D1.W (stops on NULL or max 255) with CR, LF.
00008474                          1521  *------------------------------------------------------------------------------
00008474                          1522  easyTask0:
00008474  0241 00FF               1523      andi.w  #$00FF,d1   * DBRA works on a WORD so make sure upper byte is zero
00008478  5301                    1524      sub.b   #1,d1       * DBRA requires 1 less than actual number
0000847A                          1525  .loop:
0000847A  1019                    1526      move.b  (a1)+, d0    * Read in character
0000847C  6708                    1527      beq.s   .end         * Check for the null
0000847E                          1528      
0000847E  6100 00C6               1529      bsr.w   putc         * Otherwise write the character
00008482  51C9 FFF6               1530      dbra    d1,.loop     * And continue
00008486                          1531  .end:
00008486  6100 00B0               1532      bsr.w   putCRLF     * append CR & LF
0000848A  4E75                    1533      rts
0000848C                          1534  
0000848C                          1535  *------------------------------------------------------------------------------
0000848C                          1536  * EASy68K TRAP #15 - Task 1
0000848C                          1537  * Display n characters of string at (A1), n is D1.W (stops on NULL or max 255) without CR, LF.
0000848C                          1538  *------------------------------------------------------------------------------
0000848C                          1539  easyTask1:
0000848C  0241 00FF               1540      andi.w  #$00FF,d1   * DBRA works on a WORD so make sure upper byte is zero
00008490  5301                    1541      sub.b   #1,d1       * DBRA requires 1 less than actual number
00008492                          1542  .loop:
00008492  1019                    1543      move.b  (a1)+, d0    * Read in character
00008494  6708                    1544      beq.s   .end         * Check for the null
00008496                          1545      
00008496  6100 00AE               1546      bsr.w   putc         * Otherwise write the character
0000849A  51C9 FFF6               1547      dbra    d1,.loop     * And continue
0000849E                          1548  .end:
0000849E  4E75                    1549      rts
000084A0                          1550  
000084A0                          1551  *------------------------------------------------------------------------------
000084A0                          1552  * EASy68K TRAP #15 - Task 5
000084A0                          1553  * Read single ASCII character from the keyboard into D1.B. 
000084A0                          1554  *------------------------------------------------------------------------------
000084A0                          1555  easyTask5:
000084A0  6100 00B6               1556      bsr.w   getc        * wait for char - returned in D0
000084A4  1200                    1557      move.b  d0,d1       * move the char into D1
000084A6  4E75                    1558      rts
000084A8                          1559      
000084A8                          1560  *------------------------------------------------------------------------------
000084A8                          1561  * EASy68K TRAP #15 - Task 6
000084A8                          1562  * Display single ASCII character in D1.B.   
000084A8                          1563  *------------------------------------------------------------------------------
000084A8                          1564  easyTask6:
000084A8  1001                    1565      move.b  d1,d0       * move the char into D0
000084AA  6100 009A               1566      bsr.w   putc        * output the char
000084AE  4E75                    1567      rts
000084B0                          1568  
000084B0                          1569  *------------------------------------------------------------------------------
000084B0                          1570  * EASy68K TRAP #15 - Task 7
000084B0                          1571  * Check for keyboard input. Set D1.B to 1 if keyboard input is pending,
000084B0                          1572  * otherwise set to 0.
000084B0                          1573  *------------------------------------------------------------------------------
000084B0                          1574  easyTask7:
000084B0  1239 00D00003           1575      move.b  SRA,d1          * get DUART status register
000084B6  0201 0001               1576      andi.b  #$01,d1         * mask all but the RxRDY bit
000084BA  4E75                    1577      rts
000084BC                          1578  
000084BC                          1579  *------------------------------------------------------------------------------
000084BC                          1580  * EASy68K TRAP #15 - Task 13
000084BC                          1581  * Display the NULL terminated string at (A1) with CR, LF.
000084BC                          1582  *------------------------------------------------------------------------------
000084BC                          1583  easyTask13:
000084BC                          1584  .loop:
000084BC  1019                    1585      move.b  (a1)+, d0    * Read in character
000084BE  6706                    1586      beq.s   .end         * Check for the null
000084C0                          1587      
000084C0  6100 0084               1588      bsr.w   putc         * Otherwise write the character
000084C4  60F6                    1589      bra.s   .loop        * And continue
000084C6                          1590  .end:
000084C6  6100 0070               1591      bsr.w   putCRLF     * append CR & LF
000084CA  4E75                    1592      rts
000084CC                          1593  
000084CC                          1594  *------------------------------------------------------------------------------
000084CC                          1595  * EASy68K TRAP #15 - Task 14
000084CC                          1596  * Display the NULL terminated string pointed to by (A1).
000084CC                          1597  *------------------------------------------------------------------------------
000084CC                          1598  easyTask14:
000084CC                          1599  .loop:
000084CC  1019                    1600      move.b  (a1)+, d0    * Read in character
000084CE  6706                    1601      beq.s   .end         * Check for the null
000084D0                          1602      
000084D0  6100 0074               1603      bsr.w   putc         * Otherwise write the character
000084D4  60F6                    1604      bra.s   .loop        * And continue
000084D6                          1605  .end:
000084D6  4E75                    1606      rts
000084D8                          1607  
000084D8                          1608  *------------------------------------------------------------------------------
000084D8                          1609  * This is the entry point for the TRAP #15 handler that gets called when any
000084D8                          1610  * TRAP #15 services are required. Only a few tasks are implemented.
000084D8                          1611  * Unimplemented tasks will produce an error message.
000084D8                          1612  *------------------------------------------------------------------------------
000084D8                          1613  easy68kTrap15:
000084D8  48E7 10A0               1614      movem.l d3/a0/a2,-(sp)
000084DC  45FA FF0A               1615      lea     easy68kTaskTable(PC),a2
000084E0  B03C 0019               1616      cmp.b   #25,d0          ; is task number greater than 25?
000084E4  6E00 FF6A               1617      bgt     easyTaskUnsupported
000084E8                          1618      
000084E8  4283                    1619      clr.l   d3
000084EA  1600                    1620      move.b  d0,d3           ; task number into D3
000084EC  E58B                    1621      lsl.l   #2,d3           ; convert task number into longword offset
000084EE  4EB2 3000               1622      jsr     (a2,d3)         ; jump to the specific task handler
000084F2                          1623      
000084F2  4CDF 0508               1624      movem.l (sp)+,d3/a0/a2
000084F6  4E73                    1625      rte
000084F8                          1626      
000084F8                          1627  *==============================================================================
000084F8                          1628  * These are the various printing routines that handle displaying of bytes,
000084F8                          1629  * words, long words and 24-bit values as ASCII hexadecimal text. The routines
000084F8                          1630  * must be kept in this order as program flow is meant to fall out of one
000084F8                          1631  * routine and into the next, often without a return statement.
000084F8                          1632  *==============================================================================
000084F8                          1633  
000084F8                          1634  *------------------------------------------------------------------------------
000084F8                          1635  * Output a 32-bit address as 8 ASCII hexadecimal digits
000084F8                          1636  * D0 holds the 32-bit address
000084F8                          1637  *------------------------------------------------------------------------------
000084F8                          1638  writeAddr32:
000084F8  2F00                    1639      move.l  d0,-(sp)    ; save D0 first
000084FA  E098                    1640      ror.l   #8,d0
000084FC  E098                    1641      ror.l   #8,d0
000084FE  610E                    1642      bsr.s   writeWord   ; write bits 16..31
00008500  201F                    1643      move.l  (sp)+,d0    ; restore D0
00008502  600A                    1644      bra.s   writeWord
00008504                          1645      
00008504                          1646  *------------------------------------------------------------------------------
00008504                          1647  * Output a 24-bit address as 6 ASCII hexadecimal digits
00008504                          1648  * D0 holds the address in bits 0..23
00008504                          1649  * NOTE: the writeWord function must be directly after this function
00008504                          1650  *------------------------------------------------------------------------------
00008504                          1651  writeAddr24:
00008504  2F00                    1652      move.l  d0,-(sp)    ; save D0 first
00008506  E098                    1653      ror.l   #8,d0
00008508  E098                    1654      ror.l   #8,d0
0000850A  610A                    1655      bsr.s   writeByte   ; write bits 16..23
0000850C  201F                    1656      move.l  (sp)+,d0    ; restore D0
0000850E                          1657      
0000850E                          1658  *------------------------------------------------------------------------------
0000850E                          1659  * Output a word as 4 ASCII hexadecimal digits
0000850E                          1660  * D0 holds the word in bits 0..15
0000850E                          1661  * NOTE: the writeByte function must be directly after this function
0000850E                          1662  *------------------------------------------------------------------------------
0000850E                          1663  writeWord:
0000850E  3F00                    1664      move.w  d0,-(sp)    ; save D0 first
00008510  E058                    1665      ror.w   #8,d0       ; get upper byte (0 => shift 8 times)
00008512  6102                    1666      bsr.s   writeByte
00008514  301F                    1667      move.w  (sp)+,d0    ; restore D0
00008516                          1668  
00008516                          1669  *------------------------------------------------------------------------------
00008516                          1670  * Output a byte as 2 ASCII hexadecimal digits
00008516                          1671  * D0 holds the byte in bits 0..7
00008516                          1672  * NOTE: the writeNibble function must be directly after this function
00008516                          1673  *------------------------------------------------------------------------------
00008516                          1674  writeByte:
00008516  1F00                    1675      move.b  d0,-(sp)    ; save D0 first
00008518  E818                    1676      ror.b   #4,d0       ; get upper nibble
0000851A  6102                    1677      bsr.s   writeNibble
0000851C  101F                    1678      move.b  (sp)+,d0    ; restore D0
0000851E                          1679      
0000851E                          1680  *------------------------------------------------------------------------------
0000851E                          1681  * Output 4 bits as an ASCII hexadecimal digit
0000851E                          1682  * D0 holds the nibble in bits 0..3
0000851E                          1683  *------------------------------------------------------------------------------
0000851E                          1684  writeNibble:
0000851E  1F00                    1685      move.b  d0,-(sp)    ; save D0 first
00008520  0200 000F               1686      andi.b  #$0F,d0     ; make sure we only have the lower 4 bits
00008524  0C00 000A               1687      cmpi.b  #10,d0      ; compare D0 to 10
00008528  6502                    1688      bcs.b   .wn1        ; less than 10 so don't add 7
0000852A  5E00                    1689      addi.b  #07,d0      ; add 7
0000852C                          1690  .wn1:
0000852C  0600 0030               1691      addi.b  #'0',d0     ; add ASCII code for char zero
00008530  6100 0014               1692      bsr     putc        ; write the ASCII digit out
00008534  101F                    1693      move.b  (sp)+,d0    ; restore D0
00008536  4E75                    1694      rts
00008538                          1695  
00008538                          1696  *------------------------------------------------------------------------------
00008538                          1697  * Prints a newline (CR, LF)
00008538                          1698  * NOTE: the putString function must follow this function
00008538                          1699  *------------------------------------------------------------------------------
00008538                          1700  putCRLF:
00008538  41FA 0254               1701      lea     strNewline(PC), a0
0000853C                          1702  
0000853C                          1703  *------------------------------------------------------------------------------
0000853C                          1704  * Print a null terminated string
0000853C                          1705  * A0 holds the address of the first character of the null terminated string
0000853C                          1706  *------------------------------------------------------------------------------
0000853C                          1707  putString:
0000853C                          1708  .loop:
0000853C  1018                    1709      move.b  (a0)+, d0    * Read in character
0000853E  6704                    1710      beq.s   .end         * Check for the null
00008540                          1711      
00008540  6104                    1712      bsr.s   putc         * Otherwise write the character
00008542  60F8                    1713      bra.s   .loop        * And continue
00008544                          1714  .end:
00008544  4E75                    1715      rts
00008546                          1716  
00008546                          1717  *------------------------------------------------------------------------------
00008546                          1718  * Write a character to UART Port A, blocking if UART is not ready
00008546                          1719  * D0 = char to send
00008546                          1720  *------------------------------------------------------------------------------
00008546                          1721  putc:
00008546                 TRUE     1722      ifgt USE_REAL_UART
00008546                          1723      ; using real hardware
00008546                          1724      
00008546  0839 0002 00D00003      1725      btst.b    #2, SRA      * Check if transmitter ready bit is set
0000854E  67F6                    1726      beq     putc     
00008550  13C0 00D00007           1727      move.b  d0, TBA      * Transmit Character
00008556  4E75                    1728      rts
00008558                          1729      
00008558                          1730      endc
00008558                          1731      
00008558                 FALSE    1732      ifeq USE_REAL_UART
00008558                          1733      ; using Sim68K I/O window
00008558                          1734      endc
00008558                          1735  
00008558                 FALSE    1736      iflt USE_REAL_UART
00008558                          1737      ; using Sim68K COM port
00008558                          1738      endc
00008558                          1739  
00008558                          1740  *------------------------------------------------------------------------------
00008558                          1741  * Read a character from UART Port A - blocking call so will wait for character
00008558                          1742  * D0 = recevied char
00008558                          1743  *------------------------------------------------------------------------------
00008558                          1744  getc:
00008558                 TRUE     1745      ifgt USE_REAL_UART
00008558                          1746      ; using real hardware
00008558                          1747  
00008558  1039 00D00003           1748      move.b  SRA,d0          * get DUART status register
0000855E  0200 0001               1749      andi.b  #$01,d0         * mask all but the RxRDY bit
00008562  67F4                    1750      beq.s   getc
00008564                          1751  
00008564  4E71                    1752      nop
00008566  4E71                    1753      nop
00008568  4E71                    1754      nop
0000856A  4E71                    1755      nop
0000856C  1039 00D00007           1756      move.b  RBA, d0      * Read Character into D0
00008572  4E75                    1757      rts
00008574                          1758  
00008574                          1759      endc
00008574                          1760      
00008574                 FALSE    1761      ifeq USE_REAL_UART
00008574                          1762      ; using Sim68K I/O window
00008574                          1763      endc
00008574                          1764  
00008574                 FALSE    1765      iflt USE_REAL_UART
00008574                          1766      ; using Sim68K COM port
00008574                          1767      ; got a character?
00008574                          1768      endc
00008574                          1769  
00008574                          1770  *------------------------------------------------------------------------------
00008574                          1771  * String constants
00008574                          1772  *------------------------------------------------------------------------------
00008574                          1773  strBanner1:
00008574= 0A 0D                   1774      dc.b 10,13
00008576= 53 69 6D 70 6C 65 ...   1775      dc.b 'Simple RCBus 68000 ROM Monitor v1.3',10,13
0000859B= 52 4F 4D 3A 20 30 ...   1776      dc.b 'ROM: 0x000000 .. 0x01FFFF',10,13
000085B6= 52 41 4D 3A 20 30 ...   1777      dc.b 'RAM: 0x100000 .. 0x1FFFFF',10,13,0
000085D2                          1778  strCommands:
000085D2= 0A 0D 43 6F 6D 6D ...   1779      dc.b 10,13,'Commands: ',10,13
000085E0= 42 20 20 20 20 20 ...   1780      dc.b 'B     : Start EhBASIC v3.54',10,13
000085FD= 43 20 20 20 20 20 ...   1781      dc.b 'C     : Start CP/M-68K v1.3',10,13
0000861A= 44 6E 6E 6E 6E 20 ...   1782      dc.b 'Dnnnn : Display 256 bytes of memory starting at address nnnn',10,13
00008658= 47 6E 6E 6E 6E 20 ...   1783      dc.b 'Gnnnn : Execute code starting at address nnnn',10,13
00008687= 49 61 61 20 20 20 ...   1784      dc.b 'Iaa   : Read a byte from address aa in I/O space',10,13
000086B9= 4D 6E 6E 6E 6E 20 ...   1785      dc.b 'Mnnnn : Modify memory starting at address nnnn',10,13
000086E9= 4F 61 61 62 62 20 ...   1786      dc.b 'Oaabb : Write byte bb to address aa in I/O space',10,13
0000871B= 53 31 78 78 78 20 ...   1787      dc.b 'S1xxx : Download S1 Hex Record ',10,13          
0000873C= 53 32 78 78 78 20 ...   1788      dc.b 'S2xxx : Download S2 Hex Record ',10,13    
0000875D= 3F 20 20 20 20 20 ...   1789      dc.b '?     : Display this help',10,13
00008778= 00                      1790      dc.b 0
00008779                          1791  strPrompt:
00008779= 3E 20 00                1792      dc.b '> ',0
0000877C                          1793  strUnkCmd:
0000877C= 55 6E 6B 6E 6F 77 ...   1794      dc.b 'Unknown Command: ',0
0000878E                          1795  strNewline:
0000878E= 0A 0D 00                1796      dc.b 10,13,0
00008791                          1797  strColonSpace:
00008791= 3A 20 00                1798      dc.b ': ',0
00008794                          1799  strUninitInt:
00008794= 55 6E 68 61 6E 64 ...   1800      dc.b 'Unhandled interrupt.',10,13,0
000087AB                          1801  strUserReturn:
000087AB= 0A 0D 55 73 65 72 ...   1802      dc.b 10,13,'User program completed.',10,13,0
000087C7                          1803  strEasyTask1:
000087C7= 0A 0D 53 54 4F 50 ...   1804      dc.b    10,13,'STOP: EASy68K TRAP #15 - Task ',0
000087E8                          1805  strEasyTask2:
000087E8= 20 6E 6F 74 20 79 ...   1806      dc.b    ' not yet implemented',10,13,0
000087FF                          1807  strCPMErr1:
000087FF= 0A 0D 43 61 6E 6E ...   1808      dc.b    10,13,'Cannot boot CP/M-68K - CP/M-68K missing from EEPROM',10,13,0
00008837                          1809  strCPMErr2:
00008837= 0A 0D 43 61 6E 6E ...   1810      dc.b    10,13,'Cannot boot CP/M-68K - CP/M-68K BIOS missing from EEPROM',10,13,0
00008874                          1811  strCPMReturn:
00008874= 0A 0D 43 50 2F 4D ...   1812      dc.b    10,13,'CP/M-68K returned to Monitor. Press RESET to restart.',10,13,0
000088AE                          1813  strBASICErr1:
000088AE= 0A 0D 43 61 6E 6E ...   1814      dc.b    10,13,'Cannot boot EhBASIC - EhBASIC missing from EEPROM',10,13,0
000088E4                          1815  strBASICReturn:
000088E4= 0A 0D 45 68 42 41 ...   1816      dc.b    10,13,'EhBASIC returned to Monitor. Press RESET to restart.',10,13,0
0000891D                          1817      
0000891D                 FALSE    1818      iflt USE_REAL_UART
0000891D                          1819      ; using Sim68K COM port
0000891D                          1820  * PORTPARAMS dc.l    0         ; 9600,8,N,1
0000891D                          1821      endc
0000891D                          1822  
0000891D                          1823  *------------------------------------------------------------------------------
0000891D                          1824  * Monitor variables
0000891D                          1825  *------------------------------------------------------------------------------
001FF800                          1826      ORG     STACK_START
001FF800                          1827  msgASCIIDump:
001FF800                          1828      ds.b 20
001FF814                          1829  serBuff:   
001FF814                          1830      ds.b    8
001FF81C                          1831      
001FF81C                          1832      END    START            * last line of source

No errors detected
No warnings generated


SYMBOL TABLE INFORMATION
Symbol-name         Value
-------------------------
ACR                 D00009
AEMSG1              7762
AEMSG2              77A6
AV1MSG              77D8
AV2MSG              7814
AV3MSG              7850
AV4MSG              788C
AV5MSG              78C8
AV6MSG              7904
AV7MSG              7940
BAUD_1200           66
BAUD_2400           88
BAUD_38400          CC
BAUD_4800           99
BAUD_9600           BB
BAUD_RATE           CC
BCNT                D0001D
BEMSG1              797C
BEMSG2              79BB
BIOS_PRIV           1000
CCP_BSS_BASE        1FD800
CCP_PRIV            1000
CF_8BIT             1
CF_COMMAND          F8002F
CF_CYL_HI           F8002B
CF_CYL_LOW          F80029
CF_DATA             F80021
CF_ERROR            F80023
CF_FEATURES         F80023
CF_HEAD             F8002D
CF_LBA0007          F80027
CF_LBA0815          F80029
CF_LBA1623          F8002B
CF_LBA2427          F8002D
CF_LBAMODE          E0
CF_NOCACHE          82
CF_RD_SEC           20
CF_SECCOUNT         F80025
CF_SECTOR           F80027
CF_SET_FEAT         EF
CF_STATUS           F8002F
CF_WR_SEC           30
CHTOUPPER           834C
CHTOUPPER:DONE      835C
CIMSG               79ED
CMDBOOTCPM          8098
CMDBOOTCPM:BOOTCPM  80C0
CMDBOOTCPM:CHKBIOS  80AC
CMDBOOTCPM:FOREVER  80D0
CMDBOOTEHBASIC      8070
CMDBOOTEHBASIC:BOOTEHBASIC  8086
CMDBOOTEHBASIC:FOREVER  8096
CMDDISPMEMORY       80D2
CMDDOWNLOAD         8206
CMDDOWNLOAD:CDL_1   8274
CMDDOWNLOAD:CDL_2   828A
CMDDOWNLOAD:CDL_EOL  82B2
CMDDOWNLOAD:CDL_EOL89  82C4
CMDDOWNLOAD:CDL_S1  822A
CMDDOWNLOAD:CDL_S2  824E
CMDDOWNLOAD:CDL_X   82A6
CMDHELP             82DA
CMDIOREAD           811C
CMDIOWRITE          81BC
CMDMODIFYMEMORY     815E
CMDMODIFYMEMORY:CMM_1  8180
CMDMODIFYMEMORY:CMM_2  81B4
CMDRUN              80F4
CPM_BASE            400
CR                  D
CRA                 D00005
CRB                 D00015
CSRA                D00003
CSRB                D00013
DUART1              D00000
DUMPRAM             82E6
DUMPRAM:DR_1        82F4
DUMPRAM:DR_2        830C
EASY68KTASKTABLE    83E8
EASY68KTRAP15       84D8
EASYTASK0           8474
EASYTASK0:END       8486
EASYTASK0:LOOP      847A
EASYTASK1           848C
EASYTASK10          8450
EASYTASK11          8450
EASYTASK12          8450
EASYTASK13          84BC
EASYTASK13:END      84C6
EASYTASK13:LOOP     84BC
EASYTASK14          84CC
EASYTASK14:END      84D6
EASYTASK14:LOOP     84CC
EASYTASK15          8450
EASYTASK16          8450
EASYTASK17          8450
EASYTASK18          8450
EASYTASK19          8450
EASYTASK1:END       849E
EASYTASK1:LOOP      8492
EASYTASK2           8450
EASYTASK20          8450
EASYTASK21          8450
EASYTASK22          8450
EASYTASK23          8450
EASYTASK24          8450
EASYTASK25          8450
EASYTASK3           8450
EASYTASK4           8450
EASYTASK5           84A0
EASYTASK6           84A8
EASYTASK7           84B0
EASYTASK8           8450
EASYTASK9           8450
EASYTASKUNSUPPORTED  8450
EASYTASKUNSUPPORTED:INFLOOP  8472
ECNT                D0001F
EHBASIC_BASE        9000
GETC                8558
HANDLEADDRERR       7594
HANDLEAV1           7634
HANDLEAV2           7640
HANDLEAV3           764C
HANDLEAV4           7658
HANDLEAV5           7664
HANDLEAV6           7670
HANDLEAV7           767C
HANDLEBUSERR        7578
HANDLECHKINST       75C8
HANDLECLEANUP       7754
HANDLECLEANUP:INFLOOP  7760
HANDLEILLINST       75B0
HANDLELINEA         75F8
HANDLELINEF         7604
HANDLEPRIV          75E0
HANDLERES1          7610
HANDLERES10         7610
HANDLERES11         7610
HANDLERES2          7610
HANDLERES3          7610
HANDLERES4          7610
HANDLERES5          7610
HANDLERES6          7610
HANDLERES7          7610
HANDLERES8          7610
HANDLERES9          7610
HANDLESPUR          7628
HANDLETRACE         75EC
HANDLETRAP0         7688
HANDLETRAP1         7694
HANDLETRAP10        7700
HANDLETRAP11        770C
HANDLETRAP12        7718
HANDLETRAP13        7724
HANDLETRAP14        7730
HANDLETRAP15        773C
HANDLETRAP2         76A0
HANDLETRAP3         76AC
HANDLETRAP4         76B8
HANDLETRAP5         76C4
HANDLETRAP6         76D0
HANDLETRAP7         76DC
HANDLETRAP8         76E8
HANDLETRAP9         76F4
HANDLETRAPV         75D4
HANDLEUNINIT        761C
HANDLEUNUSED        7748
HANDLEZERODIV       75BC
HEXTOINT            8370
HEXTOINT:H2I_1      8370
HEXTOINT:H2I_2      8398
HEXTOINT:H2I_ERR    83A4
HEXTOINT:H2I_X      83A0
HEXTOINTECHO        83AA
HEXTOINTECHO:H2I_1  83AA
HEXTOINTECHO:H2I_2  83D6
HEXTOINTECHO:H2I_ERR  83E2
HEXTOINTECHO:H2I_X  83DE
IIMSG               7A1A
IMR                 D0000B
IO_BASE             F80000
IPR                 D0001B
ISR                 D0000B
IVR                 D00019
JMPADDRERR          7008
JMPAV1              70B8
JMPAV2              70C0
JMPAV3              70C8
JMPAV4              70D0
JMPAV5              70D8
JMPAV6              70E0
JMPAV7              70E8
JMPBUSERR           7000
JMPCHKINST          7020
JMPILLINST          7010
JMPLINEA            7040
JMPLINEF            7048
JMPPRIV             7030
JMPRES1             7050
JMPRES10            70A0
JMPRES11            70A8
JMPRES2             7058
JMPRES3             7060
JMPRES4             7070
JMPRES5             7078
JMPRES6             7080
JMPRES7             7088
JMPRES8             7090
JMPRES9             7098
JMPSPUR             70B0
JMPTRACE            7038
JMPTRAP0            70F0
JMPTRAP1            70F8
JMPTRAP10           7140
JMPTRAP11           7148
JMPTRAP12           7150
JMPTRAP13           7158
JMPTRAP14           7160
JMPTRAP15           7168
JMPTRAP2            7100
JMPTRAP3            7108
JMPTRAP4            7110
JMPTRAP5            7118
JMPTRAP6            7120
JMPTRAP7            7128
JMPTRAP8            7130
JMPTRAP9            7138
JMPTRAPV            7028
JMPUNINIT           7068
JMPUNUSED           7170
JMPZERODIV          7018
LAMSG               7A55
LF                  A
LFMSG               7A85
MAKEPRINTABLE       835E
MAKEPRINTABLE:MP_1  836A
MAKEPRINTABLE:MP_X  836E
MEM_BASE            F00000
MONLOOP             7FF6
MONLOOP_CRLF        806A
MONLOOP_NP          7FFE
MONSTART            7FE6
MON_BASE            7000
MON_PRIV            800
MRA                 D00001
MRB                 D00011
MSGASCIIDUMP        1FF800
OPCR                D0001B
PUTC                8546
PUTCRLF             8538
PUTSTRING           853C
PUTSTRING:END       8544
PUTSTRING:LOOP      853C
PVMSG               7AB5
RAMVECJUMP          0
RAM_BASE            100000
RAM_LEN             100000
RBA                 D00007
RBB                 D00017
RIMSG               7AF2
ROM2RAMIVT          7178
ROPR                D0001F
SC145               F80020
SC145ADDR           10
SERBUFF             1FF814
SIMSG               7B24
SOPR                D0001D
SRA                 D00003
SRB                 D00013
STACK_START         1FF800
START               7F78
START:COPY          7F90
STRBANNER1          8574
STRBASICERR1        88AE
STRBASICRETURN      88E4
STRCOLONSPACE       8791
STRCOMMANDS         85D2
STRCPMERR1          87FF
STRCPMERR2          8837
STRCPMRETURN        8874
STREASYTASK1        87C7
STREASYTASK2        87E8
STRNEWLINE          878E
STRPROMPT           8779
STRUNINITINT        8794
STRUNKCMD           877C
STRUSERRETURN       87AB
TBA                 D00007
TBB                 D00017
TR0MSG              7B8F
TR10MSG             7D79
TR11MSG             7DAB
TR12MSG             7DDD
TR13MSG             7E0F
TR14MSG             7E41
TR15MSG             7E73
TR1MSG              7BC0
TR2MSG              7BF1
TR3MSG              7C22
TR4MSG              7C53
TR5MSG              7C84
TR6MSG              7CB5
TR7MSG              7CE6
TR8MSG              7D17
TR9MSG              7D48
TRMSG               7B60
TVMSG               7EA5
UIMSG               7ED4
USERMSG             7F15
USE_REAL_UART       1
VEC_BASE            100000
VEC_SIZE            400
WRITEADDR24         8504
WRITEADDR32         84F8
WRITEBYTE           8516
WRITENIBBLE         851E
WRITENIBBLE:WN1     852C
WRITEWORD           850E
ZDMSG               7F43
