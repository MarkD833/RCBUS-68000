00009046 Starting Address
Assembler used: EASy68K Editor/Assembler v5.16.01
Created On: 02/05/2025 13:52:56

00000000                             1  ;************************************************************************************
00000000                             2  ;                                                                                   *
00000000                             3  ;   Enhanced BASIC for the Motorola MC680xx                                         *
00000000                             4  ;                                                                                   *
00000000                             5  ;   This version is for the RCBus-68000 board.                                      *
00000000                             6  ;   Based on the version by Jeff Tranter (tranter@pobox.com)                        *
00000000                             7  ;                                                                                   *
00000000                             8  ;************************************************************************************
00000000                             9  ;                                                                                   *
00000000                            10  ;   Copyright(C) 2002-12 by Lee Davison. This program may be freely distributed     *
00000000                            11  ;   for personal use only. All commercial rights are reserved.                      *
00000000                            12  ;                                                                                   *
00000000                            13  ;   More 68000 and other projects can be found on my website at ..                  *
00000000                            14  ;                                                                                   *
00000000                            15  ;    http://mycorner.no-ip.org/index.html                                           *
00000000                            16  ;                                                                                   *
00000000                            17  ;   mail : leeedavison@googlemail.com                                               *
00000000                            18  ;                                                                                   *
00000000                            19  ;************************************************************************************
00000000                            20  
00000000                            21      INCLUDE "..\asm-inc\memory.inc"
00000000                            22  
00000000  =00007000                 23  MON_BASE        EQU     $7000
00000000                            24  
00000000  =00009000                 25  EHBASIC_BASE    EQU     $9000
00000000                            26  
00000000  =00100000                 27  RAM_BASE        EQU     $100000
00000000  =00100000                 28  RAM_LEN         EQU     $100000
00000000                            29  
00000000  =00100000                 30  VEC_BASE        EQU     RAM_BASE
00000000  =00000400                 31  VEC_SIZE        EQU     $400         * table takes up 1024 bytes
00000000                            32  
00000000  =00F00000                 33  IO_BASE         EQU     $F00000     * I/O space base address = 00F0_0000
00000000                            34  
00000000  =00000400                 35  CPM_BASE        EQU     $0400       * CP/M-68K entry point
00000000                            36  
00000000  =001FD800                 37  CCP_BSS_BASE    EQU     $1FD800
00000000  =00001000                 38  CCP_PRIV        EQU     4096
00000000                            39  
00000000  =00000800                 40  MON_PRIV        EQU     2048
00000000                            41  
00000000  =00001000                 42  BIOS_PRIV       EQU     4096
00000000                            43  
00000000  =001FF800                 44  STACK_START     EQU     RAM_BASE+RAM_LEN-MON_PRIV
00000000  =001FF800                 45  -------------------- end include --------------------
00000000                            46  
00000000  =00009000                 47  ROM_START   EQU EHBASIC_BASE
00000000                            48  
00000000                            49  ; Ver 3.55 - MJD renamed ram_base, ram_addr, ram_size to ehram_base, ehram_addr,
00000000                            50  ;            ehram_size to deconflict with my own monitor variables.
00000000                            51  ; Ver 3.54
00000000                            52  
00000000                            53  ; Ver 3.54 adds experimental support for LOAD/SAVE using Hobbytronics
00000000                            54  ; USB Flash Drive Host Board
00000000                            55  ; Ver 3.53 fixes math error that affected exponentiation ("^") and
00000000                            56  ;  EXP() function. Thanks to joelang for fix.
00000000                            57  ; Ver 3.52 stops USING$() from reading beyond the end of the format string
00000000                            58  ; Ver 3.51 fixes the UCASE$() and LCASE$() functions for null strings
00000000                            59  ; Ver 3.50 unary minus in concatenate generates a type mismatch error
00000000                            60  ; Ver 3.49 doesn't tokenise 'DEF' or 'DEC' within a hex value
00000000                            61  ; Ver 3.48 allows scientific notation underflow in the USING$() function
00000000                            62  ; Ver 3.47 traps the use of array elements as the FOR loop variable
00000000                            63  ; Ver 3.46 updates function and function variable handling
00000000                            64  
00000000                            65  ;************************************************************************************
00000000                            66  ;
00000000                            67  ; Ver 3.45 makes the handling of non existant variables consistent and gives the
00000000                            68  ; option of not returning an error for a non existant variable. If this is the
00000000                            69  ; behaviour you want just change novar to some non zero value
00000000                            70  
00000000  =00000000                 71  novar       EQU 0                   ; non existant variables cause errors
00000000                            72  
00000000                            73  ; Set the symbol FLASH_SUPPORT to 1 if you want to enable experimental
00000000                            74  ; support for LOAD/SAVE using a Hobbytronics USB Flash Drive Host
00000000                            75  ; Board.
00000000                            76  
00000000  =00000000                 77  FLASH_SUPPORT   EQU     0
00000000                            78  
00000000                            79  ;************************************************************************************
00000000                            80  
00000000                            81  ; Ver 3.44 adds overflow indication to the USING$() function
00000000                            82  ; Ver 3.43 removes an undocumented feature of concatenating null strings
00000000                            83  ; Ver 3.42 reimplements backspace so that characters are overwritten with [SPACE]
00000000                            84  ; Ver 3.41 removes undocumented features of the USING$() function
00000000                            85  ; Ver 3.40 adds the USING$() function
00000000                            86  ; Ver 3.33 adds the file requester to LOAD and SAVE
00000000                            87  ; Ver 3.32 adds the optional ELSE clause to IF .. THEN
00000000                            88  
00000000                            89  ;************************************************************************************
00000000                            90  ;
00000000                            91  ; Version 3.25 adds the option to change the behaviour of INPUT so that a null
00000000                            92  ; response does not cause a program break. If this is the behaviour you want just
00000000                            93  ; change nobrk to some non zero value.
00000000                            94  
00000000  =00000000                 95  nobrk       EQU 0                   ; null response to INPUT causes a break
00000000                            96  
00000000                            97  
00000000                            98  ;************************************************************************************
00000000                            99  ;
00000000                           100  ; Version 3.xx replaces the fixed RAM addressing from previous versions with a RAM
00000000                           101  ; pointer in a3. this means that this could now be run as a task on a multitasking
00000000                           102  ; system where memory resources may change.
00000000                           103  
00000000                           104  
00000000                           105  ;************************************************************************************
00000000                           106  
00000000                           107  
00000000                           108  *   CPU 68000
00000000                           109  *   SUPMODE ON
00000000                           110  
00000000                           111  ; MJD I don't need the initial SP & START address from the exception vector table
00000000                           112  ;     as code_start will be callled from my ROM Monitor program.
00000000                           113  ;   ORG $00000000
00000000                           114  ;
00000000                           115  ;INIVEC:
00000000                           116      ;; 0-7
00000000                           117  ;   DC.L    ehram_addr+ehram_base   ; Reset: Initial SSP
00000000                           118  ;   DC.L    code_start          ; Reset: Initial PC
00000000                           119  
00000000                           120  
00000000                           121      INCLUDE "basic68k.inc"
00000000                           122  
00000000                           123  ; This lot is in RAM
00000000                           124  
00000000                           125              ORG     $0000           ; start of RAM
00000000                           126   
00000000                           127  ram_strt    ds.l    $100        ; allow 1K for the stack, this should be plenty
00000400                           128                                  ; for any BASIC program that doesn't do something
00000400                           129                                  ; silly, it could even be much less.
00000400                           130  
00000400                           131  ; MJD Renamed ram_base to ehram_base as ram_base is used by my monitor program.
00000400                           132  ehram_base
00000400                           133  LAB_WARM    ds.w    1           ; BASIC warm start entry point
00000402                           134  Wrmjpv      ds.l    1           ; BASIC warm start jump vector
00000406                           135  
00000406                           136  Usrjmp      ds.w    1           ; USR function JMP address
00000408                           137  Usrjpv      ds.l    1           ; USR function JMP vector
0000040C                           138  
0000040C                           139  ; system dependant i/o vectors
0000040C                           140  ; these are in RAM and are set at start-up
0000040C                           141  
0000040C                           142  V_INPT      ds.w    1           ; non halting scan input device entry point
0000040E                           143  V_INPTv     ds.l    1           ; non halting scan input device jump vector
00000412                           144  
00000412                           145  V_OUTP      ds.w    1           ; send byte to output device entry point
00000414                           146  V_OUTPv     ds.l    1           ; send byte to output device jump vector
00000418                           147  
00000418                           148  V_LOAD      ds.w    1           ; load BASIC program entry point
0000041A                           149  V_LOADv     ds.l    1           ; load BASIC program jump vector
0000041E                           150  
0000041E                           151  V_SAVE      ds.w    1           ; save BASIC program entry point
00000420                           152  V_SAVEv     ds.l    1           ; save BASIC program jump vector
00000424                           153  
00000424                           154  V_CTLC      ds.w    1           ; save CTRL-C check entry point
00000426                           155  V_CTLCv     ds.l    1           ; save CTRL-C check jump vector
0000042A                           156  
0000042A                           157  Itemp       ds.l    1           ; temporary integer (for GOTO etc)
0000042E                           158  
0000042E                           159  Smeml       ds.l    1           ; start of memory       (start of program)
00000432                           160  
00000432                           161  ; the program is stored as a series of lines each line having the following format
00000432                           162  ;
00000432                           163  ;       ds.l    1           ; pointer to the next line or $00000000 if [EOT]
00000432                           164  ;       ds.l    1           ; line number
00000432                           165  ;       ds.b    n           ; program bytes
00000432                           166  ;       dc.b    $00         ; [EOL] marker, there will be a second $00 byte, if
00000432                           167  ;                       ; needed, to pad the line to an even number of bytes
00000432                           168  
00000432                           169  Sfncl       ds.l    1           ; start of functions    (end of Program)
00000436                           170  
00000436                           171  ; the functions are stored as function name, function execute pointer and function
00000436                           172  ; variable name
00000436                           173  ;
00000436                           174  ;       ds.l    1           ; name
00000436                           175  ;       ds.l    1           ; execute pointer
00000436                           176  ;       ds.l    1           ; function variable
00000436                           177  
00000436                           178  Svarl       ds.l    1           ; start of variables    (end of functions)
0000043A                           179  
0000043A                           180  ; the variables are stored as variable name, variable value
0000043A                           181  ;
0000043A                           182  ;       ds.l    1           ; name
0000043A                           183  ;       ds.l    1           ; packed float or integer value
0000043A                           184  
0000043A                           185  Sstrl       ds.l    1           ; start of strings  (end of variables)
0000043E                           186  
0000043E                           187  ; the strings are stored as string name, string pointer and string length
0000043E                           188  ;
0000043E                           189  ;       ds.l    1           ; name
0000043E                           190  ;       ds.l    1           ; string pointer
0000043E                           191  ;       ds.w    1           ; string length
0000043E                           192  
0000043E                           193  Sarryl      ds.l    1           ; start of arrays       (end of strings)
00000442                           194  
00000442                           195  ; the arrays are stored as array name, array size, array dimensions count, array
00000442                           196  ; dimensions upper bounds and array elements
00000442                           197  ;
00000442                           198  ;       ds.l    1           ; name
00000442                           199  ;       ds.l    1           ; size including this header
00000442                           200  ;       ds.w    1           ; dimensions count
00000442                           201  ;       ds.w    1           ; 1st dimension upper bound
00000442                           202  ;       ds.w    1           ; 2nd dimension upper bound
00000442                           203  ;       ...             ; ...
00000442                           204  ;       ds.w    1           ; nth dimension upper bound
00000442                           205  ;
00000442                           206  ; then (i1+1)*(i2+1)...*(in+1) of either ..
00000442                           207  ;
00000442                           208  ;       ds.l    1           ; packed float or integer value
00000442                           209  ;
00000442                           210  ; .. if float or integer, or ..
00000442                           211  ;
00000442                           212  ;       ds.l    1           ; string pointer
00000442                           213  ;       ds.w    1           ; string length
00000442                           214  ;
00000442                           215  ; .. if string
00000442                           216  
00000442                           217  Earryl      ds.l    1           ; end of arrays     (start of free mem)
00000446                           218  Sstorl      ds.l    1           ; string storage        (moving down)
0000044A                           219  Ememl       ds.l    1           ; end of memory     (upper bound of RAM)
0000044E                           220  Sutill      ds.l    1           ; string utility ptr
00000452                           221  Clinel      ds.l    1           ; current line      (Basic line number)
00000456                           222  Blinel      ds.l    1           ; break line        (Basic line number)
0000045A                           223  
0000045A                           224  Cpntrl      ds.l    1           ; continue pointer
0000045E                           225  Dlinel      ds.l    1           ; current DATA line
00000462                           226  Dptrl       ds.l    1           ; DATA pointer
00000466                           227  Rdptrl      ds.l    1           ; read pointer
0000046A                           228  Varname     ds.l    1           ; current var name
0000046E                           229  Cvaral      ds.l    1           ; current var address
00000472                           230  Lvarpl      ds.l    1           ; variable pointer for LET and FOR/NEXT
00000476                           231  
00000476                           232  des_sk_e    ds.l    6           ; descriptor stack end address
0000048E                           233  des_sk                          ; descriptor stack start address
0000048E                           234                                  ; use a4 for the descriptor pointer
0000048E                           235              ds.w    1           
00000490                           236  Ibuffs      ds.l    $40         ; start of input buffer
00000590                           237  Ibuffe
00000590                           238                                  ; end of input buffer
00000590                           239  
00000590                           240  FAC1_m      ds.l    1           ; FAC1 mantissa1
00000594                           241  FAC1_e      ds.w    1           ; FAC1 exponent
00000596  =00000595                242  FAC1_s      EQU FAC1_e+1        ; FAC1 sign (b7)
00000596                           243              ds.w    1           
00000598                           244  
00000598                           245  FAC2_m      ds.l    1           ; FAC2 mantissa1
0000059C                           246  FAC2_e      ds.l    1           ; FAC2 exponent
000005A0  =0000059D                247  FAC2_s      EQU FAC2_e+1        ; FAC2 sign (b7)
000005A0  =0000059E                248  FAC_sc      EQU FAC2_e+2        ; FAC sign comparison, Acc#1 vs #2
000005A0  =0000059F                249  flag        EQU FAC2_e+3        ; flag byte for divide routine
000005A0                           250  
000005A0                           251  PRNlword    ds.l    1           ; PRNG seed long word
000005A4                           252  
000005A4                           253  ut1_pl      ds.l    1           ; utility pointer 1
000005A8                           254  
000005A8                           255  Asptl       ds.l    1           ; array size/pointer
000005AC                           256  Astrtl      ds.l    1           ; array start pointer
000005B0                           257  
000005B0  =000005AC                258  numexp      EQU Astrtl          ; string to float number exponent count
000005B0  =000005AD                259  expcnt      EQU Astrtl+1        ; string to float exponent count
000005B0                           260  
000005B0  =000005AF                261  expneg      EQU Astrtl+3        ; string to float eval exponent -ve flag
000005B0                           262  
000005B0                           263  func_l      ds.l    1           ; function pointer
000005B4                           264  
000005B4                           265  
000005B4                           266                                  ; these two need to be a word aligned pair !
000005B4                           267  Defdim      ds.w    1           ; default DIM flag
000005B6  =000005B4                268  cosout      EQU Defdim          ; flag which CORDIC output (re-use byte)
000005B6  =000005B5                269  Dtypef      EQU Defdim+1        ; data type flag, $80=string, $40=integer, $00=float
000005B6                           270  
000005B6                           271  
000005B6                           272  Binss       ds.l    4           ; number to bin string start (32 chrs)
000005C6                           273  
000005C6                           274  Decss       ds.l    1           ; number to decimal string start (16 chrs)
000005CA                           275              ds.w    1
000005CC                           276  Usdss       ds.w    1           ; unsigned decimal string start (10 chrs)
000005CE                           277  
000005CE                           278  Hexss       ds.l    2           ; number to hex string start (8 chrs)
000005D6                           279  
000005D6                           280  BHsend      ds.w    1           ; bin/decimal/hex string end
000005D8                           281  
000005D8                           282  
000005D8                           283  prstk       ds.b    1           ; stacked function index
000005D9                           284  
000005D9                           285  tpower      ds.b    1           ; remember CORDIC power
000005DA                           286  
000005DA                           287  Asrch       ds.b    1           ; scan-between-quotes flag, alt search character
000005DB                           288  
000005DB                           289  Dimcnt      ds.b    1           ; # of dimensions
000005DC                           290  
000005DC                           291  Breakf      ds.b    1           ; break flag, $00=END else=break
000005DD                           292  Oquote      ds.b    1           ; open quote flag (Flag: DATA; LIST; memory)
000005DE                           293  Gclctd      ds.b    1           ; garbage collected flag
000005DF                           294  Sufnxf      ds.b    1           ; subscript/FNX flag, 1xxx xxx = FN(0xxx xxx)
000005E0                           295  Imode       ds.b    1           ; input mode flag, $00=INPUT, $98=READ
000005E1                           296  
000005E1                           297  Cflag       ds.b    1           ; comparison evaluation flag
000005E2                           298  
000005E2                           299  TabSiz      ds.b    1           ; TAB step size
000005E3                           300  
000005E3                           301  comp_f      ds.b    1           ; compare function flag, bits 0,1 and 2 used
000005E4                           302                                  ; bit 2 set if >
000005E4                           303                                  ; bit 1 set if =
000005E4                           304                                  ; bit 0 set if <
000005E4                           305  
000005E4                           306  Nullct      ds.b    1           ; nulls output after each line
000005E5                           307  TPos        ds.b    1           ; BASIC terminal position byte
000005E6                           308  TWidth      ds.b    1           ; BASIC terminal width byte
000005E7                           309  Iclim       ds.b    1           ; input column limit
000005E8                           310  ccflag      ds.b    1           ; CTRL-C check flag
000005E9                           311  ccbyte      ds.b    1           ; CTRL-C last received byte
000005EA                           312  ccnull      ds.b    1           ; CTRL-C last received byte 'life' timer
000005EB                           313  
000005EC                           314      ORG   (*+1)&-2  Force Word alignment
000005EC                           315  
000005EC                           316  ; these variables for load/save routines
000005EC                           317  
000005EC                           318  ; ifne   FLASH_SUPPORT
000005EC                           319  ;
000005EC                           320  ;load_first      ds.b    1               ; Boolean indicating if first byte read
000005EC                           321  ;load_filename   ds.b    13              ; Hold LOAD/SAVE filename (DOS 8.3 format plus terminating null)
000005EC                           322  ;
000005EC                           323  ; endc
000005EC                           324  ;
000005EC                           325  ;       even            ; dummy even value and zero pad byte
000005EC                           326  
000005EC                           327  prg_strt
000005EC                           328  
000005EC                           329  ; MJD Renamed ram_addr to ehram_addr & ram_size to ehram_size as ram_size
000005EC                           330  ; is used by my monitor program.
000005EC                           331  ; Use these two lines when running from ROM
000005EC  =00100400                332  ehram_addr  EQU VEC_BASE+VEC_SIZE               ; RAM start address
000005EC  =000FF400                333  ehram_size  EQU RAM_LEN-VEC_SIZE-MON_PRIV       ; RAM size
000005EC                           334  
000005EC                           335  ; Use these two lines when running from RAM
000005EC                           336  ;ehram_addr EQU $04000      ; RAM start address
000005EC                           337  ;ehram_size EQU $04000      ; RAM size
000005EC                           338  -------------------- end include --------------------
000005EC                           339                                  ; RAM offset definitions
000005EC                           340  
000005EC                           341  ; Use this value to run out of ROM
000005EC                           342  ;   ORG     $00C000             ; past the vectors in a real system
000005EC                           343  ; Use this value to run out of RAM
00009000                           344      ORG     ROM_START           ; past the vectors in a real system
00009000  4EF9 00009046            345      JMP     code_start
00009006                           346      
00009006                           347  ;************************************************************************************
00009006                           348  ;
00009006                           349  ; the following code is simulator specific, change to suit your system
00009006                           350  ; Output character to the console from register d0.b
00009006                           351  
00009006                           352  VEC_OUT
00009006  48E7 C000                353      MOVEM.l d0-d1,-(sp)         * save d0, d1
0000900A  1200                     354      MOVE.b  d0,d1               * copy character
0000900C  7006                     355      MOVEQ       #6,d0               * character out
0000900E  4E4F                     356      TRAP        #15             * do I/O function
00009010  4CDF 0003                357      MOVEM.l (sp)+,d0-d1         * restore d0, d1
00009014  4E75                     358      RTS
00009016                           359  
00009016                           360  ;************************************************************************************
00009016                           361  ;
00009016                           362  ; input a character from the console into register d0
00009016                           363  ; else return Cb=0 if there's no character available
00009016                           364  
00009016                           365  VEC_IN
00009016  2F01                     366      MOVE.l  d1,-(sp)            * save d1
00009018  7007                     367      MOVEQ       #7,d0               * get status
0000901A  4E4F                     368      TRAP        #15             * do I/O function
0000901C  1001                     369      MOVE.b  d1,d0               * copy status
0000901E  6608                     370      BNE.s       RETCHR          * branch if character waiting
00009020                           371  
00009020  221F                     372      MOVE.l  (sp)+,d1            * restore d1
00009022  0000 0000                373      ORI.b       #$00,d0         * set z flag
00009026                           374  *   ANDI.b  #$FE,CCR            * clear carry, flag we not got byte
00009026                           375  *                           * done by ORI.b
00009026  4E75                     376      RTS
00009028                           377  
00009028                           378  RETCHR
00009028  7005                     379      MOVEQ       #5,d0               * get byte
0000902A  4E4F                     380      TRAP        #15             * do I/O function
0000902C  1001                     381      MOVE.b  d1,d0               * copy byte
0000902E  221F                     382      MOVE.l  (sp)+,d1            * restore d1
00009030  0000 0000                383      ORI.b       #$00,d0         * set z flag on received byte
00009034  003C 0001                384      ORI.b       #1,CCR          * set carry, flag we got a byte
00009038  4E75                     385      RTS
0000903A                           386  
0000903A                           387  ;************************************************************************************
0000903A                           388  ;
0000903A                           389  ; LOAD routine for the TS2 computer (not implemented)
0000903A                           390  
0000903A                           391  VEC_LD
0000903A  7E2E                     392         MOVEQ           #$2E,d7                        ; error code $2E "Not implemented" error
0000903C  6000 0122                393         BRA             LAB_XERR                       ; do error #d7, then warm start
00009040                           394  
00009040                           395  ;************************************************************************************
00009040                           396  ;
00009040                           397  ; SAVE routine for the TS2 computer (not implemented)
00009040                           398  
00009040                           399  VEC_SV
00009040  7E2E                     400         MOVEQ           #$2E,d7                        ; error code $2E "Not implemented" error
00009042  6000 011C                401         BRA             LAB_XERR                       ; do error #d7, then warm start
00009046                           402  
00009046                           403  
00009046                           404  ;************************************************************************************
00009046                           405  
00009046                           406  code_start
00009046                           407  ;                               ; Set up ACIA parameters
00009046                           408  ;        LEA.L   ACIA_1,A0      ; A0 points to console ACIA
00009046                           409  ;        MOVE.B  #$15,(A0)      ; Set up ACIA1 constants (no IRQ,
00009046                           410  ;                               ; RTS* low, 8 bit, no parity, 1 stop)
00009046                           411  ;        LEA.L   ACIA_2,A0      ; A0 points to aux. ACIA
00009046                           412  ;        MOVE.B  #$15,(A0)      ; Set up ACIA2 constants (no IRQ,
00009046                           413  ;                               ; RTS* low, 8 bit, no parity, 1 stop)
00009046                           414  
00009046                           415  ;   MOVEQ       #12,d0          * keyboard echo
00009046                           416  ;   MOVEQ       #0,d1               * turn off echo
00009046                           417  ;   TRAP        #15             * do I/O function
00009046                           418      
00009046                           419  ; to tell EhBASIC where and how much RAM it has pass the address in a0 and the size
00009046                           420  ; in d0. these values are at the end of the .inc file
00009046                           421  
00009046  207C 00100400            422      MOVEA.l #ehram_addr,a0          ; tell BASIC where RAM starts
0000904C  203C 000FF400            423      MOVE.l  #ehram_size,d0          ; tell BASIC how much RAM there is
00009052                           424  
00009052                           425  ; end of simulator specific code
00009052                           426  
00009052                           427  
00009052                           428  ;************************************************************************************
00009052                           429  ;************************************************************************************
00009052                           430  ;************************************************************************************
00009052                           431  ;************************************************************************************
00009052                           432  ;
00009052                           433  ; Register use :- (must improve this !!)
00009052                           434  ;
00009052                           435  ;   a6 -    temp Bpntr                  ; temporary BASIC execute pointer
00009052                           436  ;   a5 -    Bpntr                       ; BASIC execute (get byte) pointer
00009052                           437  ;   a4 -    des_sk                     ; descriptor stack pointer
00009052                           438  ;   a3 -    ram_strt                    ; start of RAM. all RAM references are offsets
00009052                           439  ;                               ; from this value
00009052                           440  ;
00009052                           441  
00009052                           442  ;************************************************************************************
00009052                           443  ;
00009052                           444  ; BASIC cold start entry point. assume entry with RAM address in a0 and RAM length
00009052                           445  ; in d0
00009052                           446  
00009052                           447  LAB_COLD
00009052                           448  ;   CMP.l       #$4000,d0           ; compare size with 16k
00009052                           449  ;   BGE.s       LAB_sizok           ; branch if >= 16k
00009052                           450  ;
00009052                           451  ;   MOVEQ   #5,d0                   ; error 5 - not enough RAM
00009052                           452  ;   move.b  #228,D7                 ; Go to TUTOR function
00009052                           453  ;   trap    #14                     ; Call TRAP14 handler
00009052                           454  ;
00009052                           455  ;LAB_sizok
00009052  2648                     456      MOVEA.l a0,a3                   ; copy RAM base to a3
00009054  D1C0                     457      ADDA.l  d0,a0                   ; a0 is top of RAM
00009056  2748 044A                458      MOVE.l  a0,Ememl(a3)            ; set end of mem
0000905A  2E7C 00100800            459      MOVE.l  #ehram_addr+ehram_base,sp   ; set stack to RAM start + 1k
00009060                           460  
00009060  303C 4EF9                461      MOVE.w  #$4EF9,d0               ; JMP opcode
00009064  204F                     462      MOVEA.l sp,a0                   ; point to start of vector table
00009066                           463  
00009066  30C0                     464      MOVE.w  d0,(a0)+                ; LAB_WARM
00009068  43FA FFE8                465      LEA     LAB_COLD(pc),a1         ; initial warm start vector
0000906C  20C9                     466      MOVE.l  a1,(a0)+                ; set vector
0000906E                           467  
0000906E  30C0                     468      MOVE.w  d0,(a0)+                ; Usrjmp
00009070  43FA 00DC                469      LEA     LAB_FCER(pc),a1         ; initial user function vector
00009074                           470                                      ; "Function call" error
00009074  20C9                     471      MOVE.l  a1,(a0)+                ; set vector
00009076                           472  
00009076  30C0                     473      MOVE.w  d0,(a0)+                ; V_INPT JMP opcode
00009078  43FA FF9C                474      LEA     VEC_IN(pc),a1           ; get byte from input device vector
0000907C  20C9                     475      MOVE.l  a1,(a0)+                ; set vector
0000907E                           476  
0000907E  30C0                     477      MOVE.w  d0,(a0)+                ; V_OUTP JMP opcode
00009080  43FA FF84                478      LEA     VEC_OUT(pc),a1          ; send byte to output device vector
00009084  20C9                     479      MOVE.l  a1,(a0)+                ; set vector
00009086                           480  
00009086  30C0                     481      MOVE.w  d0,(a0)+                ; V_LOAD JMP opcode
00009088  43FA FFB0                482      LEA     VEC_LD(pc),a1           ; load BASIC program vector
0000908C  20C9                     483      MOVE.l  a1,(a0)+                ; set vector
0000908E                           484  
0000908E  30C0                     485      MOVE.w  d0,(a0)+                ; V_SAVE JMP opcode
00009090  43FA FFAE                486      LEA     VEC_SV(pc),a1           ; save BASIC program vector
00009094  20C9                     487      MOVE.l  a1,(a0)+                ; set vector
00009096                           488  
00009096  30C0                     489      MOVE.w  d0,(a0)+                ; V_CTLC JMP opcode
00009098  43FA 2632                490      LEA     VEC_CC(pc),a1           ; save CTRL-C check vector
0000909C  20C9                     491      MOVE.l  a1,(a0)+                ; set vector
0000909E                           492  
0000909E                           493  ; set-up start values
0000909E                           494  
0000909E                           495  ;##LAB_GMEM
0000909E  7000                     496      MOVEQ   #$00,d0                 ; clear d0
000090A0  1740 05E4                497      MOVE.b  d0,Nullct(a3)           ; default NULL count
000090A4  1740 05E5                498      MOVE.b  d0,TPos(a3)             ; clear terminal position
000090A8  1740 05E8                499      MOVE.b  d0,ccflag(a3)           ; allow CTRL-C check
000090AC  3740 05EA                500      MOVE.w  d0,prg_strt-2(a3)           ; clear start word
000090B0  3740 05D6                501      MOVE.w  d0,BHsend(a3)           ; clear value to string end word
000090B4                           502  
000090B4  177C 0050 05E6           503      MOVE.b  #$50,TWidth(a3)         ; default terminal width byte for simulator
000090BA  177C 000E 05E2           504      MOVE.b  #$0E,TabSiz(a3)         ; save default tab size = 14
000090C0                           505  
000090C0  177C 0038 05E7           506      MOVE.b  #$38,Iclim(a3)          ; default limit for TAB = 14 for simulator
000090C6                           507  
000090C6  49EB 048E                508      LEA     des_sk(a3),a4           ; set descriptor stack start
000090CA                           509  
000090CA  41EB 05EC                510      LEA     prg_strt(a3),a0         ; get start of mem
000090CE  2748 042E                511      MOVE.l  a0,Smeml(a3)            ; save start of mem
000090D2                           512  
000090D2  6100 0322                513      BSR     LAB_1463                ; do "NEW" and "CLEAR"
000090D6  6100 08A2                514      BSR     LAB_CRLF                ; print CR/LF
000090DA  202B 044A                515      MOVE.l  Ememl(a3),d0            ; get end of mem
000090DE  90AB 042E                516      SUB.l       Smeml(a3),d0            ; subtract start of mem
000090E2                           517  
000090E2  6100 1BDE                518      BSR     LAB_295E                ; print d0 as unsigned integer (bytes free)
000090E6  41FA 3402                519      LEA     LAB_SMSG(pc),a0         ; point to start message
000090EA  6100 08EC                520      BSR     LAB_18C3                ; print null terminated string from memory
000090EE                           521  
000090EE  41FA 29E6                522      LEA     LAB_RSED(pc),a0         ; get pointer to value
000090F2  6100 1A76                523      BSR     LAB_UFAC                ; unpack memory (a0) into FAC1
000090F6                           524  
000090F6  41FA 0092                525      LEA     LAB_1274(pc),a0         ; get warm start vector
000090FA  2748 0402                526      MOVE.l  a0,Wrmjpv(a3)           ; set warm start vector
000090FE  6100 1FE4                527      BSR     LAB_RND                 ; initialise
00009102  4EEB 0400                528      JMP     LAB_WARM(a3)            ; go do warm start
00009106                           529  
00009106                           530  
00009106                           531  ;************************************************************************************
00009106                           532  ;
00009106                           533  ; do format error
00009106                           534  
00009106                           535  LAB_FOER
00009106  7E2C                     536      MOVEQ       #$2C,d7             ; error code $2C "Format" error
00009108  6056                     537      BRA.s       LAB_XERR                ; do error #d7, then warm start
0000910A                           538  
0000910A                           539  
0000910A                           540  ;************************************************************************************
0000910A                           541  ;
0000910A                           542  ; do address error
0000910A                           543  
0000910A                           544  LAB_ADER
0000910A  7E2A                     545      MOVEQ       #$2A,d7             ; error code $2A "Address" error
0000910C  6052                     546      BRA.s       LAB_XERR                ; do error #d7, then warm start
0000910E                           547  
0000910E                           548  
0000910E                           549  ;************************************************************************************
0000910E                           550  ;
0000910E                           551  ; do wrong dimensions error
0000910E                           552  
0000910E                           553  LAB_WDER
0000910E  7E28                     554      MOVEQ       #$28,d7             ; error code $28 "Wrong dimensions" error
00009110  604E                     555      BRA.s       LAB_XERR                ; do error #d7, then warm start
00009112                           556  
00009112                           557  
00009112                           558  ;************************************************************************************
00009112                           559  ;
00009112                           560  ; do undimensioned array error
00009112                           561  
00009112                           562  LAB_UDER
00009112  7E26                     563      MOVEQ       #$26,d7             ; error code $26 "undimensioned array" error
00009114  604A                     564      BRA.s       LAB_XERR                ; do error #d7, then warm start
00009116                           565  
00009116                           566  
00009116                           567  ;************************************************************************************
00009116                           568  ;
00009116                           569  ; do undefined variable error
00009116                           570  
00009116                           571  LAB_UVER
00009116                           572  
00009116  7E24                     573      MOVEQ       #$24,d7             ; error code $24 "undefined variable" error
00009118  6046                     574      BRA.s       LAB_XERR                ; do error #d7, then warm start
0000911A                           575  
0000911A                           576  
0000911A                           577  ;************************************************************************************
0000911A                           578  ;
0000911A                           579  ; do loop without do error
0000911A                           580  
0000911A                           581  LAB_LDER
0000911A  7E22                     582      MOVEQ       #$22,d7             ; error code $22 "LOOP without DO" error
0000911C  6042                     583      BRA.s       LAB_XERR                ; do error #d7, then warm start
0000911E                           584  
0000911E                           585  
0000911E                           586  ;************************************************************************************
0000911E                           587  ;
0000911E                           588  ; do undefined function error
0000911E                           589  
0000911E                           590  LAB_UFER
0000911E  7E20                     591      MOVEQ       #$20,d7             ; error code $20 "Undefined function" error
00009120  603E                     592      BRA.s       LAB_XERR                ; do error #d7, then warm start
00009122                           593  
00009122                           594  
00009122                           595  ;************************************************************************************
00009122                           596  ;
00009122                           597  ; do can't continue error
00009122                           598  
00009122                           599  LAB_CCER
00009122  7E1E                     600      MOVEQ       #$1E,d7             ; error code $1E "Can't continue" error
00009124  603A                     601      BRA.s       LAB_XERR                ; do error #d7, then warm start
00009126                           602  
00009126                           603  
00009126                           604  ;************************************************************************************
00009126                           605  ;
00009126                           606  ; do string too complex error
00009126                           607  
00009126                           608  LAB_SCER
00009126  7E1C                     609      MOVEQ       #$1C,d7             ; error code $1C "String too complex" error
00009128  6036                     610      BRA.s       LAB_XERR                ; do error #d7, then warm start
0000912A                           611  
0000912A                           612  
0000912A                           613  ;************************************************************************************
0000912A                           614  ;
0000912A                           615  ; do string too long error
0000912A                           616  
0000912A                           617  LAB_SLER
0000912A  7E1A                     618      MOVEQ       #$1A,d7             ; error code $1A "String too long" error
0000912C  6032                     619      BRA.s       LAB_XERR                ; do error #d7, then warm start
0000912E                           620  
0000912E                           621  
0000912E                           622  ;************************************************************************************
0000912E                           623  ;
0000912E                           624  ; do type missmatch error
0000912E                           625  
0000912E                           626  LAB_TMER
0000912E  7E18                     627      MOVEQ       #$18,d7             ; error code $18 "Type mismatch" error
00009130  602E                     628      BRA.s       LAB_XERR                ; do error #d7, then warm start
00009132                           629  
00009132                           630  
00009132                           631  ;************************************************************************************
00009132                           632  ;
00009132                           633  ; do illegal direct error
00009132                           634  
00009132                           635  LAB_IDER
00009132  7E16                     636      MOVEQ       #$16,d7             ; error code $16 "Illegal direct" error
00009134  602A                     637      BRA.s       LAB_XERR                ; do error #d7, then warm start
00009136                           638  
00009136                           639  
00009136                           640  ;************************************************************************************
00009136                           641  ;
00009136                           642  ; do divide by zero error
00009136                           643  
00009136                           644  LAB_DZER
00009136  7E14                     645      MOVEQ       #$14,d7             ; error code $14 "Divide by zero" error
00009138  6026                     646      BRA.s       LAB_XERR                ; do error #d7, then warm start
0000913A                           647  
0000913A                           648  
0000913A                           649  ;************************************************************************************
0000913A                           650  ;
0000913A                           651  ; do double dimension error
0000913A                           652  
0000913A                           653  LAB_DDER
0000913A  7E12                     654      MOVEQ       #$12,d7             ; error code $12 "Double dimension" error
0000913C  6022                     655      BRA.s       LAB_XERR                ; do error #d7, then warm start
0000913E                           656  
0000913E                           657  
0000913E                           658  ;************************************************************************************
0000913E                           659  ;
0000913E                           660  ; do array bounds error
0000913E                           661  
0000913E                           662  LAB_ABER
0000913E  7E10                     663      MOVEQ       #$10,d7             ; error code $10 "Array bounds" error
00009140  601E                     664      BRA.s       LAB_XERR                ; do error #d7, then warm start
00009142                           665  
00009142                           666  
00009142                           667  ;************************************************************************************
00009142                           668  ;
00009142                           669  ; do undefined satement error
00009142                           670  
00009142                           671  LAB_USER
00009142  7E0E                     672      MOVEQ       #$0E,d7             ; error code $0E "Undefined statement" error
00009144  601A                     673      BRA.s       LAB_XERR                ; do error #d7, then warm start
00009146                           674  
00009146                           675  
00009146                           676  ;************************************************************************************
00009146                           677  ;
00009146                           678  ; do out of memory error
00009146                           679  
00009146                           680  LAB_OMER
00009146  7E0C                     681      MOVEQ       #$0C,d7             ; error code $0C "Out of memory" error
00009148  6016                     682      BRA.s       LAB_XERR                ; do error #d7, then warm start
0000914A                           683  
0000914A                           684  
0000914A                           685  ;************************************************************************************
0000914A                           686  ;
0000914A                           687  ; do overflow error
0000914A                           688  
0000914A                           689  LAB_OFER
0000914A  7E0A                     690      MOVEQ       #$0A,d7             ; error code $0A "Overflow" error
0000914C  6012                     691      BRA.s       LAB_XERR                ; do error #d7, then warm start
0000914E                           692  
0000914E                           693  
0000914E                           694  ;************************************************************************************
0000914E                           695  ;
0000914E                           696  ; do function call error
0000914E                           697  
0000914E                           698  LAB_FCER
0000914E  7E08                     699      MOVEQ       #$08,d7             ; error code $08 "Function call" error
00009150  600E                     700      BRA.s       LAB_XERR                ; do error #d7, then warm start
00009152                           701  
00009152                           702  
00009152                           703  ;************************************************************************************
00009152                           704  ;
00009152                           705  ; do out of data error
00009152                           706  
00009152                           707  LAB_ODER
00009152  7E06                     708      MOVEQ       #$06,d7             ; error code $06 "Out of DATA" error
00009154  600A                     709      BRA.s       LAB_XERR                ; do error #d7, then warm start
00009156                           710  
00009156                           711  
00009156                           712  ;************************************************************************************
00009156                           713  ;
00009156                           714  ; do return without gosub error
00009156                           715  
00009156                           716  LAB_RGER
00009156  7E04                     717      MOVEQ       #$04,d7             ; error code $04 "RETURN without GOSUB" error
00009158  6006                     718      BRA.s       LAB_XERR                ; do error #d7, then warm start
0000915A                           719  
0000915A                           720  
0000915A                           721  ;************************************************************************************
0000915A                           722  ;
0000915A                           723  ; do syntax error
0000915A                           724  
0000915A                           725  LAB_SNER
0000915A  7E02                     726      MOVEQ       #$02,d7             ; error code $02 "Syntax" error
0000915C  6002                     727      BRA.s       LAB_XERR                ; do error #d7, then warm start
0000915E                           728  
0000915E                           729  
0000915E                           730  ;************************************************************************************
0000915E                           731  ;
0000915E                           732  ; do next without for error
0000915E                           733  
0000915E                           734  LAB_NFER
0000915E  7E00                     735      MOVEQ       #$00,d7             ; error code $00 "NEXT without FOR" error
00009160                           736  
00009160                           737  
00009160                           738  ;************************************************************************************
00009160                           739  ;
00009160                           740  ; do error #d7, then warm start
00009160                           741  
00009160                           742  LAB_XERR
00009160  6100 02CA                743      BSR     LAB_1491                ; flush stack & clear continue flag
00009164  6100 0814                744      BSR     LAB_CRLF                ; print CR/LF
00009168  43FA 2FF8                745      LEA     LAB_BAER(pc),a1         ; start of error message pointer table
0000916C  3E31 7000                746      MOVE.w  (a1,d7.w),d7            ; get error message offset
00009170  41F1 7000                747      LEA     (a1,d7.w),a0            ; get error message address
00009174  6100 0862                748      BSR     LAB_18C3                ; print null terminated string from memory
00009178  41FA 3333                749      LEA     LAB_EMSG(pc),a0         ; point to " Error" message
0000917C                           750  LAB_1269
0000917C  6100 085A                751      BSR     LAB_18C3                ; print null terminated string from memory
00009180  202B 0452                752      MOVE.l  Clinel(a3),d0           ; get current line
00009184  6B04                     753      BMI.s   LAB_1274                ; go do warm start if -ve # (was immediate mode)
00009186                           754  
00009186                           755                                      ; else print line number
00009186  6100 1B2E                756      BSR     LAB_2953                ; print " in line [LINE #]"
0000918A                           757  
0000918A                           758  ; BASIC warm start entry point, wait for Basic command
0000918A                           759  
0000918A                           760  LAB_1274
0000918A  41FA 3354                761      LEA     LAB_RMSG(pc),a0         ; point to "Ready" message
0000918E  6100 0848                762      BSR     LAB_18C3                ; go do print string
00009192                           763  
00009192                           764  ; wait for Basic command - no "Ready"
00009192                           765  
00009192                           766  LAB_127D
00009192  72FF                     767      MOVEQ   #-1,d1                  ; set to -1
00009194  2741 0452                768      MOVE.l  d1,Clinel(a3)           ; set current line #
00009198  1741 05DC                769      MOVE.b  d1,Breakf(a3)           ; set break flag
0000919C  4BEB 0490                770      LEA     Ibuffs(a3),a5           ; set basic execute pointer ready for new line
000091A0                           771  LAB_127E
000091A0  6100 00EC                772      BSR     LAB_1357                ; call for BASIC input
000091A4  6100 0BFE                773      BSR     LAB_GBYT                ; scan memory
000091A8  67F6                     774      BEQ.s   LAB_127E                ; loop while null
000091AA                           775  
000091AA                           776  ; got to interpret input line now ....
000091AA                           777  
000091AA  6508                     778      BCS.s   LAB_1295                ; branch if numeric character, handle new
000091AC                           779                                  ; BASIC line
000091AC                           780  
000091AC                           781                                  ; no line number so do immediate mode, a5
000091AC                           782                                  ; points to the buffer start
000091AC  6100 0156                783      BSR     LAB_13A6                ; crunch keywords into Basic tokens
000091B0                           784                                  ; crunch from (a5), output to (a0)
000091B0                           785                                  ; returns ..
000091B0                           786                                  ; d2 is length, d1 trashed, d0 trashed,
000091B0                           787                                  ; a1 trashed
000091B0  6000 03C6                788      BRA     LAB_15F6                ; go scan & interpret code
000091B4                           789  
000091B4                           790  
000091B4                           791  ;************************************************************************************
000091B4                           792  ;
000091B4                           793  ; handle a new BASIC line
000091B4                           794  
000091B4                           795  LAB_1295
000091B4  6100 0640                796      BSR     LAB_GFPN                ; get fixed-point number into temp integer & d1
000091B8  6100 014A                797      BSR     LAB_13A6                ; crunch keywords into Basic tokens
000091BC                           798                                  ; crunch from (a5), output to (a0)
000091BC                           799                                  ; returns .. d2 is length,
000091BC                           800                                  ; d1 trashed, d0 trashed, a1 trashed
000091BC  222B 042A                801      MOVE.l  Itemp(a3),d1            ; get required line #
000091C0  6100 0218                802      BSR     LAB_SSLN                ; search BASIC for d1 line number
000091C4                           803                                  ; returns pointer in a0
000091C4  6532                     804      BCS.s       LAB_12E6                ; branch if not found
000091C6                           805  
000091C6                           806                                  ; aroooogah! line # already exists! delete it
000091C6  2250                     807      MOVEA.l (a0),a1             ; get start of block (next line pointer)
000091C8  202B 0432                808      MOVE.l  Sfncl(a3),d0            ; get end of block (start of functions)
000091CC  9089                     809      SUB.l       a1,d0                   ; subtract start of block ( = bytes to move)
000091CE  E288                     810      LSR.l       #1,d0                   ; /2 (word move)
000091D0  5380                     811      SUBQ.l  #1,d0                   ; adjust for DBF loop
000091D2  4840                     812      SWAP        d0                  ; swap high word to low word
000091D4  2448                     813      MOVEA.l a0,a2                   ; copy destination
000091D6                           814  LAB_12AE
000091D6  4840                     815      SWAP        d0                  ; swap high word to low word
000091D8                           816  LAB_12B0
000091D8  34D9                     817      MOVE.w  (a1)+,(a2)+             ; copy word
000091DA  51C8 FFFC                818      DBF     d0,LAB_12B0             ; decrement low count and loop until done
000091DE                           819  
000091DE  4840                     820      SWAP        d0                  ; swap high word to low word
000091E0  51C8 FFF4                821      DBF     d0,LAB_12AE             ; decrement high count and loop until done
000091E4                           822  
000091E4  274A 0432                823      MOVE.l  a2,Sfncl(a3)            ; start of functions
000091E8  274A 0436                824      MOVE.l  a2,Svarl(a3)            ; save start of variables
000091EC  274A 043A                825      MOVE.l  a2,Sstrl(a3)            ; start of strings
000091F0  274A 043E                826      MOVE.l  a2,Sarryl(a3)           ; save start of arrays
000091F4  274A 0442                827      MOVE.l  a2,Earryl(a3)           ; save end of arrays
000091F8                           828  
000091F8                           829                                  ; got new line in buffer and no existing same #
000091F8                           830  LAB_12E6
000091F8  102B 0490                831      MOVE.b  Ibuffs(a3),d0           ; get byte from start of input buffer
000091FC  6764                     832      BEQ.s       LAB_1325                ; if null line go do line chaining
000091FE                           833  
000091FE                           834                                  ; got new line and it isn't empty line
000091FE  226B 0432                835      MOVEA.l Sfncl(a3),a1            ; get start of functions (end of block to move)
00009202  45F1 2008                836      LEA     8(a1,d2),a2             ; copy it, add line length and add room for
00009206                           837                                  ; pointer and line number
00009206                           838  
00009206  274A 0432                839      MOVE.l  a2,Sfncl(a3)            ; start of functions
0000920A  274A 0436                840      MOVE.l  a2,Svarl(a3)            ; save start of variables
0000920E  274A 043A                841      MOVE.l  a2,Sstrl(a3)            ; start of strings
00009212  274A 043E                842      MOVE.l  a2,Sarryl(a3)           ; save start of arrays
00009216  274A 0442                843      MOVE.l  a2,Earryl(a3)           ; save end of arrays
0000921A  276B 044A 0446           844      MOVE.l  Ememl(a3),Sstorl(a3)        ; copy end of mem to start of strings, clear
00009220                           845                                  ; strings
00009220                           846  
00009220  2209                     847      MOVE.l  a1,d1                   ; copy end of block to move
00009222  9288                     848      SUB.l       a0,d1                   ; subtract start of block to move
00009224  E289                     849      LSR.l       #1,d1                   ; /2 (word copy)
00009226  5381                     850      SUBQ.l  #1,d1                   ; correct for loop end on -1
00009228  4841                     851      SWAP        d1                  ; swap high word to low word
0000922A                           852  LAB_12FF
0000922A  4841                     853      SWAP        d1                  ; swap high word to low word
0000922C                           854  LAB_1301
0000922C  3521                     855      MOVE.w  -(a1),-(a2)             ; decrement pointers and copy word
0000922E  51C9 FFFC                856      DBF     d1,LAB_1301             ; decrement & loop
00009232                           857  
00009232  4841                     858      SWAP        d1                  ; swap high word to low word
00009234  51C9 FFF4                859      DBF     d1,LAB_12FF             ; decrement high count and loop until done
00009238                           860  
00009238                           861  ; space is opened up, now copy the crunched line from the input buffer into the space
00009238                           862  
00009238  43EB 0490                863      LEA     Ibuffs(a3),a1           ; source is input buffer
0000923C  2448                     864      MOVEA.l a0,a2                   ; copy destination
0000923E  72FF                     865      MOVEQ       #-1,d1              ; set to allow re-chaining
00009240  24C1                     866      MOVE.l  d1,(a2)+                ; set next line pointer (allow re-chaining)
00009242  24EB 042A                867      MOVE.l  Itemp(a3),(a2)+         ; save line number
00009246  E24A                     868      LSR.w       #1,d2                   ; /2 (word copy)
00009248  5342                     869      SUBQ.w  #1,d2                   ; correct for loop end on -1
0000924A                           870  LAB_1303
0000924A  34D9                     871      MOVE.w  (a1)+,(a2)+             ; copy word
0000924C  51CA FFFC                872      DBF     d2,LAB_1303             ; decrement & loop
00009250                           873  
00009250  6010                     874      BRA.s       LAB_1325                ; go test for end of prog
00009252                           875  
00009252                           876  ; rebuild chaining of BASIC lines
00009252                           877  
00009252                           878  LAB_132E
00009252  5048                     879      ADDQ.w  #8,a0                   ; point to first code byte of line, there is
00009254                           880                                  ; always 1 byte + [EOL] as null entries are
00009254                           881                                  ; deleted
00009254                           882  LAB_1330
00009254  4A18                     883      TST.b       (a0)+                   ; test byte 
00009256  66FC                     884      BNE.s       LAB_1330                ; loop if not [EOL]
00009258                           885  
00009258                           886                                  ; was [EOL] so get next line start
00009258  3208                     887      MOVE.w  a0,d1                   ; past pad byte(s)
0000925A  0241 0001                888      ANDI.w  #1,d1                   ; mask odd bit
0000925E  D0C1                     889      ADD.w       d1,a0                   ; add back to ensure even
00009260  2288                     890      MOVE.l  a0,(a1)             ; save next line pointer to current line
00009262                           891  LAB_1325
00009262  2248                     892      MOVEA.l a0,a1                   ; copy pointer for this line
00009264  4A90                     893      TST.l       (a0)                    ; test pointer to next line
00009266  66EA                     894      BNE.s       LAB_132E                ; not end of program yet so we must
00009268                           895                                  ; go and fix the pointers
00009268                           896  
00009268  6100 0198                897      BSR     LAB_1477                ; reset execution to start, clear variables
0000926C                           898                                  ; and flush stack
0000926C  6000 FF24                899      BRA     LAB_127D                ; now we just wait for Basic command, no "Ready"
00009270                           900  
00009270                           901  
00009270                           902  ;************************************************************************************
00009270                           903  ;
00009270                           904  ; receive a line from the keyboard
00009270                           905                                  ; character $08 as delete key, BACKSPACE on
00009270                           906                                  ; standard keyboard
00009270                           907  LAB_134B
00009270  6100 0780                908      BSR     LAB_PRNA                ; go print the character
00009274  7020                     909      MOVEQ       #' ',d0             ; load [SPACE]
00009276  6100 077A                910      BSR     LAB_PRNA                ; go print
0000927A  7008                     911      MOVEQ       #$08,d0             ; load [BACKSPACE]
0000927C  6100 0774                912      BSR     LAB_PRNA                ; go print
00009280  5341                     913      SUBQ.w  #$01,d1             ; decrement the buffer index (delete)
00009282  6010                     914      BRA.s       LAB_1359                ; re-enter loop
00009284                           915  
00009284                           916  ; print "? " and get BASIC input
00009284                           917  ; return a0 pointing to the buffer start
00009284                           918  
00009284                           919  LAB_INLN
00009284  6100 076A                920      BSR     LAB_18E3                ; print "?" character
00009288  7020                     921      MOVEQ       #' ',d0             ; load " "
0000928A  6100 0766                922      BSR     LAB_PRNA                ; go print
0000928E                           923  
0000928E                           924  ; call for BASIC input (main entry point)
0000928E                           925  ; return a0 pointing to the buffer start
0000928E                           926  
0000928E                           927  LAB_1357
0000928E  7200                     928      MOVEQ       #$00,d1             ; clear buffer index
00009290  41EB 0490                929      LEA     Ibuffs(a3),a0           ; set buffer base pointer
00009294                           930  LAB_1359
00009294  4EAB 040C                931      JSR     V_INPT(a3)              ; call scan input device
00009298  64FA                     932      BCC.s       LAB_1359                ; loop if no byte
0000929A                           933  
0000929A  67F8                     934      BEQ.s       LAB_1359                ; loop if null byte
0000929C                           935  
0000929C  B03C 0007                936      CMP.b       #$07,d0             ; compare with [BELL]
000092A0  6718                     937      BEQ.s       LAB_1378                ; branch if [BELL]
000092A2                           938  
000092A2  B03C 000D                939      CMP.b       #$0D,d0             ; compare with [CR]
000092A6  6700 06CC                940      BEQ     LAB_1866                ; do CR/LF exit if [CR]
000092AA                           941  
000092AA  4A41                     942      TST.w       d1                  ; set flags on buffer index
000092AC  6606                     943      BNE.s       LAB_1374                ; branch if not empty
000092AE                           944  
000092AE                           945  ; the next two lines ignore any non printing character and [SPACE] if the input buffer
000092AE                           946  ; is empty
000092AE                           947  
000092AE  B03C 0020                948      CMP.b       #' ',d0             ; compare with [SP]+1
000092B2  63E0                     949      BLS.s       LAB_1359                ; if < ignore character
000092B4                           950  
000092B4                           951  ;## CMP.b       #' '+1,d0               ; compare with [SP]+1
000092B4                           952  ;## BCS.s       LAB_1359                ; if < ignore character
000092B4                           953  
000092B4                           954  LAB_1374
000092B4  B03C 0008                955      CMP.b       #$08,d0             ; compare with [BACKSPACE]
000092B8  67B6                     956      BEQ.s       LAB_134B                ; go delete last character
000092BA                           957  
000092BA                           958  LAB_1378
000092BA  B27C 00FF                959      CMP.w       #(Ibuffe-Ibuffs-1),d1       ; compare character count with max-1
000092BE  640C                     960      BCC.s       LAB_138E                ; skip store & do [BELL] if buffer full
000092C0                           961  
000092C0  1180 1000                962      MOVE.b  d0,(a0,d1.w)            ; else store in buffer
000092C4  5241                     963      ADDQ.w  #$01,d1             ; increment index
000092C6                           964  LAB_137F
000092C6  6100 072A                965      BSR     LAB_PRNA                ; go print the character
000092CA  60C8                     966      BRA.s       LAB_1359                ; always loop for next character
000092CC                           967  
000092CC                           968  ; announce buffer full
000092CC                           969  
000092CC                           970  LAB_138E
000092CC  7007                     971      MOVEQ       #$07,d0             ; [BELL] character into d0
000092CE  60F6                     972      BRA.s       LAB_137F                ; go print the [BELL] but ignore input character
000092D0                           973  
000092D0                           974  
000092D0                           975  ;************************************************************************************
000092D0                           976  ;
000092D0                           977  ; copy a hex value without crunching
000092D0                           978  
000092D0                           979  LAB_1392
000092D0  1180 2000                980      MOVE.b  d0,(a0,d2.w)            ; save the byte to the output
000092D4  5242                     981      ADDQ.w  #1,d2                   ; increment the buffer save index
000092D6                           982  
000092D6  5241                     983      ADDQ.w  #1,d1                   ; increment the buffer read index
000092D8  1035 1000                984      MOVE.b  (a5,d1.w),d0            ; get a byte from the input buffer
000092DC  6700 0094                985      BEQ     LAB_13EC                ; if [EOL] go save it without crunching
000092E0                           986  
000092E0  B03C 0020                987      CMP.b       #' ',d0             ; compare the character with " "
000092E4  67EA                     988      BEQ.s       LAB_1392                ; if [SPACE] just go save it and get another
000092E6                           989  
000092E6  B03C 0030                990      CMP.b       #'0',d0             ; compare the character with "0"
000092EA  654A                     991      BCS.s       LAB_13C6                ; if < "0" quit the hex save loop
000092EC                           992  
000092EC  B03C 0039                993      CMP.b       #'9',d0             ; compare with "9"
000092F0  63DE                     994      BLS.s       LAB_1392                ; if it is "0" to "9" save it and get another
000092F2                           995  
000092F2  7ADF                     996      MOVEQ       #-33,d5             ; mask xx0x xxxx, ASCII upper case
000092F4  CA00                     997      AND.b       d0,d5                   ; mask the character
000092F6                           998  
000092F6  BA3C 0041                999      CMP.b       #'A',d5             ; compare with "A"
000092FA  6540                    1000      BCS.s       LAB_13CC                ; if < "A" quit the hex save loop
000092FC                          1001  
000092FC  BA3C 0046               1002      CMP.b       #'F',d5             ; compare with "F"
00009300  63CE                    1003      BLS.s       LAB_1392                ; if it is "A" to "F" save it and get another
00009302                          1004  
00009302  6038                    1005      BRA.s       LAB_13CC                ; else continue crunching
00009304                          1006  
00009304                          1007  ; crunch keywords into Basic tokens
00009304                          1008  ; crunch from (a5), output to (a0)
00009304                          1009  ; returns ..
00009304                          1010  ; d4 trashed
00009304                          1011  ; d3 trashed
00009304                          1012  ; d2 is length
00009304                          1013  ; d1 trashed
00009304                          1014  ; d0 trashed
00009304                          1015  ; a1 trashed
00009304                          1016  
00009304                          1017  ; this is the improved BASIC crunch routine and is 10 to 100 times faster than the
00009304                          1018  ; old list search
00009304                          1019  
00009304                          1020  LAB_13A6
00009304  7200                    1021      MOVEQ       #0,d1                   ; clear the read index
00009306  2401                    1022      MOVE.l  d1,d2                   ; clear the save index
00009308  1741 05DD               1023      MOVE.b  d1,Oquote(a3)           ; clear the open quote/DATA flag
0000930C                          1024  LAB_13AC
0000930C  7000                    1025      MOVEQ       #0,d0                   ; clear word
0000930E  1035 1000               1026      MOVE.b  (a5,d1.w),d0            ; get byte from input buffer
00009312  675E                    1027      BEQ.s       LAB_13EC                ; if null save byte then continue crunching
00009314                          1028  
00009314  B03C 005F               1029      CMP.b       #'_',d0             ; compare with "_"
00009318  6458                    1030      BCC.s       LAB_13EC                ; if >= "_" save byte then continue crunching
0000931A                          1031  
0000931A  B03C 003C               1032      CMP.b       #'<',d0             ; compare with "<"
0000931E  641C                    1033      BCC.s       LAB_13CC                ; if >= "<" go crunch
00009320                          1034  
00009320  B03C 0030               1035      CMP.b       #'0',d0             ; compare with "0"
00009324  644C                    1036      BCC.s       LAB_13EC                ; if >= "0" save byte then continue crunching
00009326                          1037  
00009326  1740 05DA               1038      MOVE.b  d0,Asrch(a3)            ; save buffer byte as search character
0000932A  B03C 0022               1039      CMP.b       #$22,d0             ; is it quote character?
0000932E  6776                    1040      BEQ.s       LAB_1410                ; branch if so (copy quoted string)
00009330                          1041  
00009330  B03C 0024               1042      CMP.b       #'$',d0             ; is it the hex value character?
00009334  679A                    1043      BEQ.s       LAB_1392                ; if so go copy a hex value
00009336                          1044  
00009336                          1045  LAB_13C6
00009336  B03C 002A               1046      CMP.b       #'*',d0             ; compare with "*"
0000933A  6536                    1047      BCS.s       LAB_13EC                ; if <= "*" save byte then continue crunching
0000933C                          1048  
0000933C                          1049                                  ; crunch rest
0000933C                          1050  LAB_13CC
0000933C  082B 0006 05DD          1051      BTST.b  #6,Oquote(a3)           ; test open quote/DATA token flag
00009342  662E                    1052      BNE.s       LAB_13EC                ; branch if b6 of Oquote set (was DATA)
00009344                          1053                                  ; go save byte then continue crunching
00009344                          1054  
00009344  0400 002A               1055      SUB.b       #$2A,d0             ; normalise byte
00009348  D040                    1056      ADD.w       d0,d0                   ; *2 makes word offset (high byte=$00)
0000934A  43FA 2C18               1057      LEA     TAB_CHRT(pc),a1         ; get keyword offset table address
0000934E  3031 0000               1058      MOVE.w  (a1,d0.w),d0            ; get offset into keyword table
00009352  6B6E                    1059      BMI.s       LAB_141F                ; branch if no keywords for character
00009354                          1060  
00009354  43FA 2FA4               1061      LEA     TAB_STAR(pc),a1         ; get keyword table address
00009358  D2C0                    1062      ADDA.w  d0,a1                   ; add keyword offset
0000935A  76FF                    1063      MOVEQ       #-1,d3              ; clear index
0000935C  3801                    1064      MOVE.w  d1,d4                   ; copy read index
0000935E                          1065  LAB_13D6
0000935E  5243                    1066      ADDQ.w  #1,d3                   ; increment table index
00009360  1031 3000               1067      MOVE.b  (a1,d3.w),d0            ; get byte from table
00009364                          1068  LAB_13D8
00009364  6B0A                    1069      BMI.s       LAB_13EA                ; branch if token, save token and continue
00009366                          1070                                  ; crunching
00009366                          1071  
00009366  5244                    1072      ADDQ.w  #1,d4                   ; increment read index
00009368  B035 4000               1073      CMP.b       (a5,d4.w),d0            ; compare byte from input buffer
0000936C  67F0                    1074      BEQ.s       LAB_13D6                ; loop if character match
0000936E                          1075  
0000936E  6040                    1076      BRA.s       LAB_1417                ; branch if no match
00009370                          1077  
00009370                          1078  LAB_13EA
00009370  3204                    1079      MOVE.w  d4,d1                   ; update read index
00009372                          1080  LAB_13EC
00009372  1180 2000               1081      MOVE.b  d0,(a0,d2.w)            ; save byte to output
00009376  5242                    1082      ADDQ.w  #1,d2                   ; increment buffer save index
00009378  5241                    1083      ADDQ.w  #1,d1                   ; increment buffer read index
0000937A  4A00                    1084      TST.b       d0                  ; set flags
0000937C  674A                    1085      BEQ.s       LAB_142A                ; branch if was null [EOL]
0000937E                          1086  
0000937E                          1087                                  ; d0 holds token or byte here
0000937E  0400 003A               1088      SUB.b       #$3A,d0             ; subtract ":"
00009382  6706                    1089      BEQ.s       LAB_13FF                ; branch if it was ":" (is now $00)
00009384                          1090  
00009384                          1091                                  ; d0 now holds token-$3A
00009384  B03C 0049               1092      CMP.b       #(TK_DATA-$3A),d0           ; compare with DATA token - $3A
00009388  6604                    1093      BNE.s       LAB_1401                ; branch if not DATA
0000938A                          1094  
0000938A                          1095                                  ; token was : or DATA
0000938A                          1096  LAB_13FF
0000938A  1740 05DD               1097      MOVE.b  d0,Oquote(a3)           ; save token-$3A ($00 for ":", TK_DATA-$3A for
0000938E                          1098                                  ; DATA)
0000938E                          1099  LAB_1401
0000938E  0400 0055               1100      SUB.b       #(TK_REM-$3A),d0            ; subtract REM token offset
00009392  6600 FF78               1101      BNE     LAB_13AC                ; If wasn't REM then go crunch rest of line
00009396                          1102  
00009396  1740 05DA               1103      MOVE.b  d0,Asrch(a3)            ; else was REM so set search for [EOL]
0000939A                          1104  
0000939A                          1105                                  ; loop for REM, "..." etc.
0000939A                          1106  LAB_1408
0000939A  1035 1000               1107      MOVE.b  (a5,d1.w),d0            ; get byte from input buffer
0000939E  67D2                    1108      BEQ.s       LAB_13EC                ; branch if null [EOL]
000093A0                          1109  
000093A0  B02B 05DA               1110      CMP.b       Asrch(a3),d0            ; compare with stored character
000093A4  67CC                    1111      BEQ.s       LAB_13EC                ; branch if match (end quote, REM, :, or DATA)
000093A6                          1112  
000093A6                          1113                                  ; entry for copy string in quotes, don't crunch
000093A6                          1114  LAB_1410
000093A6  1180 2000               1115      MOVE.b  d0,(a0,d2.w)            ; save byte to output
000093AA  5242                    1116      ADDQ.w  #1,d2                   ; increment buffer save index
000093AC  5241                    1117      ADDQ.w  #1,d1                   ; increment buffer read index
000093AE  60EA                    1118      BRA.s       LAB_1408                ; loop
000093B0                          1119  
000093B0                          1120  ; not found keyword this go so find the end of this word in the table
000093B0                          1121  
000093B0                          1122  LAB_1417
000093B0  3801                    1123      MOVE.w  d1,d4                   ; reset read pointer
000093B2                          1124  LAB_141B
000093B2  5243                    1125      ADDQ.w  #1,d3                   ; increment keyword table pointer, flag
000093B4                          1126                                  ; unchanged
000093B4  1031 3000               1127      MOVE.b  (a1,d3.w),d0            ; get keyword table byte
000093B8  6AF8                    1128      BPL.s       LAB_141B                ; if not end of keyword go do next byte
000093BA                          1129  
000093BA  5243                    1130      ADDQ.w  #1,d3                   ; increment keyword table pointer flag
000093BC                          1131                                  ; unchanged
000093BC  1031 3000               1132      MOVE.b  (a1,d3.w),d0            ; get keyword table byte
000093C0  66A2                    1133      BNE.s       LAB_13D8                ; go test next word if not zero byte (table end)
000093C2                          1134  
000093C2                          1135                                  ; reached end of table with no match
000093C2                          1136  LAB_141F
000093C2  1035 1000               1137      MOVE.b  (a5,d1.w),d0            ; restore byte from input buffer
000093C6  60AA                    1138      BRA.s       LAB_13EC                ; go save byte in output and continue crunching
000093C8                          1139  
000093C8                          1140                                  ; reached [EOL]
000093C8                          1141  LAB_142A
000093C8  7000                    1142      MOVEQ       #0,d0                   ; ensure longword clear
000093CA  0102                    1143      BTST        d0,d2                   ; test odd bit (fastest)
000093CC  6706                    1144      BEQ.s       LAB_142C                ; branch if no bytes to fill
000093CE                          1145  
000093CE  1180 2000               1146      MOVE.b  d0,(a0,d2.w)            ; clear next byte
000093D2  5242                    1147      ADDQ.w  #1,d2                   ; increment buffer save index
000093D4                          1148  LAB_142C
000093D4  2180 2000               1149      MOVE.l  d0,(a0,d2.w)            ; clear next line pointer, EOT in immediate mode
000093D8  4E75                    1150      RTS
000093DA                          1151  
000093DA                          1152  
000093DA                          1153  ;************************************************************************************
000093DA                          1154  ;
000093DA                          1155  ; search Basic for d1 line number from start of mem
000093DA                          1156  
000093DA                          1157  LAB_SSLN
000093DA  206B 042E               1158      MOVEA.l Smeml(a3),a0            ; get start of program mem
000093DE  6002                    1159      BRA.s       LAB_SCLN                ; go search for required line from a0
000093E0                          1160  
000093E0                          1161  LAB_145F
000093E0  2040                    1162      MOVEA.l d0,a0                   ; copy next line pointer
000093E2                          1163  
000093E2                          1164  ; search Basic for d1 line number from a0
000093E2                          1165  ; returns Cb=0 if found
000093E2                          1166  ; returns a0 pointer to found or next higher (not found) line
000093E2                          1167  
000093E2                          1168  LAB_SCLN
000093E2  2018                    1169      MOVE.l  (a0)+,d0                ; get next line pointer and point to line #
000093E4  6708                    1170      BEQ.s       LAB_145E                ; is end marker so we're done, do 'no line' exit
000093E6                          1171  
000093E6  B290                    1172      CMP.l       (a0),d1             ; compare this line # with required line #
000093E8  6EF6                    1173      BGT.s       LAB_145F                ; loop if required # > this #
000093EA                          1174  
000093EA  5948                    1175      SUBQ.w  #4,a0                   ; adjust pointer, flags not changed
000093EC  4E75                    1176      RTS
000093EE                          1177  
000093EE                          1178  LAB_145E
000093EE  5948                    1179      SUBQ.w  #4,a0                   ; adjust pointer, flags not changed
000093F0  5380                    1180      SUBQ.l  #1,d0                   ; make end program found = -1, set carry
000093F2  4E75                    1181      RTS
000093F4                          1182  
000093F4                          1183  
000093F4                          1184  ;************************************************************************************
000093F4                          1185  ;
000093F4                          1186  ; perform NEW
000093F4                          1187  
000093F4                          1188  LAB_NEW
000093F4  664E                    1189      BNE.s       RTS_005             ; exit if not end of statement (do syntax error)
000093F6                          1190  
000093F6                          1191  LAB_1463
000093F6  206B 042E               1192      MOVEA.l Smeml(a3),a0            ; point to start of program memory
000093FA  7000                    1193      MOVEQ       #0,d0                   ; clear longword
000093FC  20C0                    1194      MOVE.l  d0,(a0)+                ; clear first line, next line pointer
000093FE  2748 0432               1195      MOVE.l  a0,Sfncl(a3)            ; set start of functions
00009402                          1196  
00009402                          1197  ; reset execution to start, clear variables and flush stack
00009402                          1198  
00009402                          1199  LAB_1477
00009402  2A6B 042E               1200      MOVEA.l Smeml(a3),a5            ; reset BASIC execute pointer
00009406  534D                    1201      SUBQ.w  #1,a5                   ; -1 (as end of previous line)
00009408                          1202  
00009408                          1203  ; "CLEAR" command gets here
00009408                          1204  
00009408                          1205  LAB_147A
00009408  276B 044A 0446          1206      MOVE.l  Ememl(a3),Sstorl(a3)        ; save end of mem as bottom of string space
0000940E  202B 0432               1207      MOVE.l  Sfncl(a3),d0            ; get start of functions
00009412  2740 0436               1208      MOVE.l  d0,Svarl(a3)            ; start of variables
00009416  2740 043A               1209      MOVE.l  d0,Sstrl(a3)            ; start of strings
0000941A  2740 043E               1210      MOVE.l  d0,Sarryl(a3)           ; set start of arrays
0000941E  2740 0442               1211      MOVE.l  d0,Earryl(a3)           ; set end of arrays
00009422                          1212  LAB_1480
00009422  7000                    1213      MOVEQ       #0,d0                   ; set Zb
00009424  1740 05EA               1214      MOVE.b  d0,ccnull(a3)           ; clear get byte countdown
00009428  6100 01D0               1215      BSR     LAB_RESTORE             ; perform RESTORE command
0000942C                          1216  
0000942C                          1217  ; flush stack & clear continue flag
0000942C                          1218  
0000942C                          1219  LAB_1491
0000942C  49EB 048E               1220      LEA     des_sk(a3),a4           ; reset descriptor stack pointer
00009430                          1221  
00009430  201F                    1222      MOVE.l  (sp)+,d0                ; pull return address
00009432  2E7C 00100800           1223      MOVE.l  #ehram_addr+ehram_base,sp   ; set stack to RAM start + 1k, flush stack
00009438  2F00                    1224      MOVE.l  d0,-(sp)                ; restore return address
0000943A                          1225  
0000943A  7000                    1226      MOVEQ       #0,d0                   ; clear longword
0000943C  2740 045A               1227      MOVE.l  d0,Cpntrl(a3)           ; clear continue pointer
00009440  1740 05DF               1228      MOVE.b  d0,Sufnxf(a3)           ; clear subscript/FNX flag
00009444                          1229  RTS_005
00009444  4E75                    1230      RTS
00009446                          1231  
00009446                          1232  
00009446                          1233  ;************************************************************************************
00009446                          1234  ;
00009446                          1235  ; perform CLEAR
00009446                          1236  
00009446                          1237  LAB_CLEAR
00009446  67C0                    1238      BEQ.s       LAB_147A                ; if no following byte go do "CLEAR"
00009448                          1239  
00009448  4E75                    1240      RTS                         ; was following byte (go do syntax error)
0000944A                          1241  
0000944A                          1242  
0000944A                          1243  ;************************************************************************************
0000944A                          1244  ;
0000944A                          1245  ; perform LIST [n][-m]
0000944A                          1246  
0000944A                          1247  LAB_LIST
0000944A  6512                    1248      BCS.s       LAB_14BD                ; branch if next character numeric (LIST n...)
0000944C                          1249  
0000944C  72FF                    1250      MOVEQ       #-1,d1              ; set end to $FFFFFFFF
0000944E  2741 042A               1251      MOVE.l  d1,Itemp(a3)            ; save to Itemp
00009452                          1252  
00009452  7200                    1253      MOVEQ       #0,d1                   ; set start to $00000000
00009454  4A00                    1254      TST.b       d0                  ; test next byte
00009456  670A                    1255      BEQ.s       LAB_14C0                ; branch if next character [NULL] (LIST)
00009458                          1256  
00009458  B03C 00B3               1257      CMP.b       #TK_MINUS,d0            ; compare with token for -
0000945C  66E6                    1258      BNE.s       RTS_005             ; exit if not - (LIST -m)
0000945E                          1259  
0000945E                          1260                                  ; LIST [[n]-[m]] this sets the n, if present,
0000945E                          1261                                  ; as the start and end
0000945E                          1262  LAB_14BD
0000945E  6100 0396               1263      BSR     LAB_GFPN                ; get fixed-point number into temp integer & d1
00009462                          1264  LAB_14C0
00009462  6100 FF76               1265      BSR     LAB_SSLN                ; search BASIC for d1 line number
00009466                          1266                                  ; (pointer in a0)
00009466  6100 093C               1267      BSR     LAB_GBYT                ; scan memory
0000946A  6716                    1268      BEQ.s       LAB_14D4                ; branch if no more characters
0000946C                          1269  
0000946C                          1270                                  ; this bit checks the - is present
0000946C  B03C 00B3               1271      CMP.b       #TK_MINUS,d0            ; compare with token for -
00009470  66D2                    1272      BNE.s       RTS_005             ; return if not "-" (will be Syntax error)
00009472                          1273  
00009472  72FF                    1274      MOVEQ       #-1,d1              ; set end to $FFFFFFFF
00009474  2741 042A               1275      MOVE.l  d1,Itemp(a3)            ; save Itemp
00009478                          1276  
00009478                          1277                                  ; LIST [n]-[m] the - was there so see if
00009478                          1278                                  ; there is an m to set as the end value
00009478  6100 0928               1279      BSR     LAB_IGBY                ; increment & scan memory
0000947C  6704                    1280      BEQ.s       LAB_14D4                ; branch if was [NULL] (LIST n-)
0000947E                          1281  
0000947E  6100 0376               1282      BSR     LAB_GFPN                ; get fixed-point number into temp integer & d1
00009482                          1283  LAB_14D4
00009482  177C 0000 05DD          1284      MOVE.b  #$00,Oquote(a3)         ; clear open quote flag
00009488  6100 04F0               1285      BSR     LAB_CRLF                ; print CR/LF
0000948C  2018                    1286      MOVE.l  (a0)+,d0                ; get next line pointer
0000948E  67B4                    1287      BEQ.s       RTS_005             ; if null all done so exit
00009490                          1288  
00009490  2240                    1289      MOVEA.l d0,a1                   ; copy next line pointer
00009492  6100 012C               1290      BSR     LAB_1629                ; do CRTL-C check vector
00009496                          1291  
00009496  2018                    1292      MOVE.l  (a0)+,d0                ; get this line #
00009498  B0AB 042A               1293      CMP.l       Itemp(a3),d0            ; compare end line # with this line #
0000949C  62A6                    1294      BHI.s       RTS_005             ; if this line greater all done so exit
0000949E                          1295  
0000949E                          1296  LAB_14E2
0000949E  48E7 00C0               1297      MOVEM.l a0-a1,-(sp)             ; save registers
000094A2  6100 181E               1298      BSR     LAB_295E                ; print d0 as unsigned integer
000094A6  4CDF 0300               1299      MOVEM.l (sp)+,a0-a1             ; restore registers
000094AA  7020                    1300      MOVEQ       #$20,d0             ; space is the next character
000094AC                          1301  LAB_150C
000094AC  6100 0544               1302      BSR     LAB_PRNA                ; go print the character
000094B0  B03C 0022               1303      CMP.b       #$22,d0             ; was it " character
000094B4  6606                    1304      BNE.s       LAB_1519                ; branch if not
000094B6                          1305  
000094B6                          1306                                  ; we're either entering or leaving quotes
000094B6  0A2B 00FF 05DD          1307      EOR.b       #$FF,Oquote(a3)         ; toggle open quote flag
000094BC                          1308  LAB_1519
000094BC  1018                    1309      MOVE.b  (a0)+,d0                ; get byte and increment pointer
000094BE  6608                    1310      BNE.s       LAB_152E                ; branch if not [EOL] (go print)
000094C0                          1311  
000094C0                          1312                                  ; was [EOL]
000094C0  2049                    1313      MOVEA.l a1,a0                   ; copy next line pointer
000094C2  2008                    1314      MOVE.l  a0,d0                   ; copy to set flags
000094C4  66BC                    1315      BNE.s       LAB_14D4                ; go do next line if not [EOT]
000094C6                          1316  
000094C6  4E75                    1317      RTS
000094C8                          1318  
000094C8                          1319  LAB_152E
000094C8  6AE2                    1320      BPL.s       LAB_150C                ; just go print it if not token byte
000094CA                          1321  
000094CA                          1322                                  ; else it was a token byte so maybe uncrunch it
000094CA  4A2B 05DD               1323      TST.b       Oquote(a3)              ; test the open quote flag
000094CE  6BDC                    1324      BMI.s       LAB_150C                ; just go print character if open quote set
000094D0                          1325  
000094D0                          1326                                  ; else uncrunch BASIC token
000094D0  45FA 2AFC               1327      LEA     LAB_KEYT(pc),a2         ; get keyword table address
000094D4  727F                    1328      MOVEQ       #$7F,d1             ; mask into d1
000094D6  C200                    1329      AND.b       d0,d1                   ; copy and mask token
000094D8  E549                    1330      LSL.w       #2,d1                   ; *4
000094DA  45F2 1000               1331      LEA     (a2,d1.w),a2            ; get keyword entry address
000094DE  101A                    1332      MOVE.b  (a2)+,d0                ; get byte from keyword table
000094E0  6100 0510               1333      BSR     LAB_PRNA                ; go print the first character
000094E4  7200                    1334      MOVEQ       #0,d1                   ; clear d1
000094E6  121A                    1335      MOVE.b  (a2)+,d1                ; get remaining length byte from keyword table
000094E8  6BD2                    1336      BMI.s       LAB_1519                ; if -ve done so go get next byte
000094EA                          1337  
000094EA  3012                    1338      MOVE.w  (a2),d0             ; get offset to rest
000094EC  45FA 2E0C               1339      LEA     TAB_STAR(pc),a2         ; get keyword table address
000094F0  45F2 0000               1340      LEA     (a2,d0.w),a2            ; get address of rest
000094F4                          1341  LAB_1540
000094F4  101A                    1342      MOVE.b  (a2)+,d0                ; get byte from keyword table
000094F6  6100 04FA               1343      BSR     LAB_PRNA                ; go print the character
000094FA  51C9 FFF8               1344      DBF     d1,LAB_1540             ; decrement and loop if more to do
000094FE                          1345  
000094FE  60BC                    1346      BRA.s       LAB_1519                ; go get next byte
00009500                          1347  
00009500                          1348  
00009500                          1349  ;************************************************************************************
00009500                          1350  ;
00009500                          1351  ; perform FOR
00009500                          1352  
00009500                          1353  LAB_FOR
00009500  6100 0396               1354      BSR     LAB_LET             ; go do LET
00009504                          1355  
00009504  202B 0472               1356      MOVE.l  Lvarpl(a3),d0           ; get the loop variable pointer
00009508  B0AB 043A               1357      CMP.l       Sstrl(a3),d0            ; compare it with the end of vars memory
0000950C  6C00 FC20               1358      BGE     LAB_TMER                ; if greater go do type mismatch error
00009510                          1359  
00009510                          1360  ; test for not less than the start of variables memory if needed
00009510                          1361  ;
00009510                          1362  ;   CMP.l       Svarl(a3),d0            ; compare it with the start of variables memory
00009510                          1363  ;   BLT     LAB_TMER                ; if not variables memory do type mismatch error
00009510                          1364  
00009510                          1365  ;   MOVEQ       #28,d0              ; we need 28 bytes !
00009510                          1366  ;   BSR.s       LAB_1212                ; check room on stack for d0 bytes
00009510                          1367  
00009510  6100 0214               1368      BSR     LAB_SNBS                ; scan for next BASIC statement ([:] or [EOL])
00009514                          1369                                  ; returns a0 as pointer to [:] or [EOL]
00009514  2E88                    1370      MOVE.l  a0,(sp)             ; push onto stack (and dump the return address)
00009516  2F2B 0452               1371      MOVE.l  Clinel(a3),-(sp)            ; push current line onto stack
0000951A                          1372  
0000951A  70AA                    1373      MOVEQ       #TK_TO-$100,d0          ; set "TO" token
0000951C  6100 087C               1374      BSR     LAB_SCCA                ; scan for CHR$(d0) else syntax error/warm start
00009520  6100 070A               1375      BSR     LAB_CTNM                ; check if source is numeric, else type mismatch
00009524  1F2B 05B5               1376      MOVE.b  Dtypef(a3),-(sp)            ; push the FOR variable data type onto stack
00009528  6100 0700               1377      BSR     LAB_EVNM                ; evaluate expression and check is numeric else
0000952C                          1378                                  ; do type mismatch
0000952C                          1379  
0000952C  2F2B 0590               1380      MOVE.l  FAC1_m(a3),-(sp)            ; push TO value mantissa
00009530  3F2B 0594               1381      MOVE.w  FAC1_e(a3),-(sp)            ; push TO value exponent and sign
00009534                          1382  
00009534  277C 80000000 0590      1383      MOVE.l  #$80000000,FAC1_m(a3)       ; set default STEP size mantissa
0000953C  377C 8100 0594          1384      MOVE.w  #$8100,FAC1_e(a3)           ; set default STEP size exponent and sign
00009542                          1385  
00009542  6100 0860               1386      BSR     LAB_GBYT                ; scan memory
00009546  B03C 00AF               1387      CMP.b       #TK_STEP,d0             ; compare with STEP token
0000954A  6608                    1388      BNE.s       LAB_15B3                ; jump if not "STEP"
0000954C                          1389  
0000954C                          1390                                  ; was STEP token so ....
0000954C  6100 0854               1391      BSR     LAB_IGBY                ; increment & scan memory
00009550  6100 06D8               1392      BSR     LAB_EVNM                ; evaluate expression & check is numeric
00009554                          1393                                  ; else do type mismatch
00009554                          1394  LAB_15B3
00009554  2F2B 0590               1395      MOVE.l  FAC1_m(a3),-(sp)            ; push STEP value mantissa
00009558  3F2B 0594               1396      MOVE.w  FAC1_e(a3),-(sp)            ; push STEP value exponent and sign
0000955C                          1397  
0000955C  2F2B 0472               1398      MOVE.l  Lvarpl(a3),-(sp)            ; push variable pointer for FOR/NEXT
00009560  3F3C 0081               1399      MOVE.w  #TK_FOR,-(sp)           ; push FOR token on stack
00009564                          1400  
00009564  6018                    1401      BRA.s       LAB_15C2                ; go do interpreter inner loop
00009566                          1402  
00009566                          1403  LAB_15DC                            ; have reached [EOL]+1
00009566  300D                    1404      MOVE.w  a5,d0                   ; copy BASIC execute pointer
00009568  C07C 0001               1405      AND.w       #1,d0                   ; and make line start address even
0000956C  DAC0                    1406      ADD.w       d0,a5                   ; add to BASIC execute pointer
0000956E  201D                    1407      MOVE.l  (a5)+,d0                ; get next line pointer
00009570  6700 FC18               1408      BEQ     LAB_1274                ; if null go to immediate mode, no "BREAK"
00009574                          1409                                  ; message (was immediate or [EOT] marker)
00009574                          1410  
00009574  275D 0452               1411      MOVE.l  (a5)+,Clinel(a3)            ; save (new) current line #
00009578                          1412  LAB_15F6
00009578  6100 082A               1413      BSR     LAB_GBYT                ; get BASIC byte
0000957C  611A                    1414      BSR.s       LAB_15FF                ; go interpret BASIC code from (a5)
0000957E                          1415  
0000957E                          1416  ; interpreter inner loop (re)entry point
0000957E                          1417  
0000957E                          1418  LAB_15C2
0000957E  6140                    1419      BSR.s       LAB_1629                ; do CRTL-C check vector
00009580  4A2B 0452               1420      TST.b       Clinel(a3)              ; test current line #, is -ve for immediate mode
00009584  6B04                    1421      BMI.s       LAB_15D1                ; branch if immediate mode
00009586                          1422  
00009586  274D 045A               1423      MOVE.l  a5,Cpntrl(a3)           ; save BASIC execute pointer as continue pointer
0000958A                          1424  LAB_15D1
0000958A  101D                    1425      MOVE.b  (a5)+,d0                ; get this byte & increment pointer
0000958C  67D8                    1426      BEQ.s       LAB_15DC                ; loop if [EOL]
0000958E                          1427  
0000958E  B03C 003A               1428      CMP.b       #$3A,d0             ; compare with ":"
00009592  67E4                    1429      BEQ.s       LAB_15F6                ; loop if was statement separator
00009594                          1430  
00009594  6000 FBC4               1431      BRA     LAB_SNER                ; else syntax error, then warm start
00009598                          1432  
00009598                          1433  
00009598                          1434  ;************************************************************************************
00009598                          1435  ;
00009598                          1436  ; interpret BASIC code from (a5)
00009598                          1437  
00009598                          1438  LAB_15FF
00009598  6700 008C               1439      BEQ     RTS_006             ; exit if zero [EOL]
0000959C                          1440  
0000959C                          1441  LAB_1602
0000959C  0A00 0080               1442      EORI.b  #$80,d0             ; normalise token
000095A0  6B00 02F6               1443      BMI     LAB_LET             ; if not token, go do implied LET
000095A4                          1444  
000095A4  B03C 0028               1445      CMP.b       #(TK_TAB-$80),d0            ; compare normalised token with TAB
000095A8  6400 FBB0               1446      BCC     LAB_SNER                ; branch if d0>=TAB, syntax error/warm start
000095AC                          1447                                  ; only tokens before TAB can start a statement
000095AC                          1448  
000095AC  4880                    1449      EXT.w       d0                  ; byte to word (clear high byte)
000095AE  D040                    1450      ADD.w       d0,d0                   ; *2
000095B0  41FA 287A               1451      LEA     LAB_CTBL(pc),a0         ; get vector table base address
000095B4  3030 0000               1452      MOVE.w  (a0,d0.w),d0            ; get offset to vector
000095B8  4870 0000               1453      PEA     (a0,d0.w)               ; push vector
000095BC  6000 07E4               1454      BRA     LAB_IGBY                ; get following byte & execute vector
000095C0                          1455  
000095C0                          1456  
000095C0                          1457  ;************************************************************************************
000095C0                          1458  ;
000095C0                          1459  ; CTRL-C check jump. this is called as a subroutine but exits back via a jump if a
000095C0                          1460  ; key press is detected.
000095C0                          1461  
000095C0                          1462  LAB_1629
000095C0  4EEB 0424               1463      JMP     V_CTLC(a3)              ; ctrl c check vector
000095C4                          1464  
000095C4                          1465  ; if there was a key press it gets back here .....
000095C4                          1466  
000095C4                          1467  LAB_1636
000095C4  B03C 0003               1468      CMP.b       #$03,d0             ; compare with CTRL-C
000095C8  670C                    1469      BEQ.s       LAB_163B                ; STOP if was CTRL-C
000095CA                          1470  
000095CA                          1471  LAB_1639
000095CA  4E75                    1472      RTS
000095CC                          1473  
000095CC                          1474  
000095CC                          1475  ;************************************************************************************
000095CC                          1476  ;
000095CC                          1477  ; perform END
000095CC                          1478  
000095CC                          1479  LAB_END
000095CC  66FC                    1480      BNE.s       LAB_1639                ; exit if something follows STOP
000095CE  177C 0000 05DC          1481      MOVE.b  #0,Breakf(a3)           ; clear break flag, indicate program end
000095D4                          1482  
000095D4                          1483  
000095D4                          1484  ;************************************************************************************
000095D4                          1485  ;
000095D4                          1486  ; perform STOP
000095D4                          1487  
000095D4                          1488  LAB_STOP
000095D4  66F4                    1489      BNE.s       LAB_1639                ; exit if something follows STOP
000095D6                          1490  
000095D6                          1491  LAB_163B
000095D6  43EB 0590               1492      LEA     Ibuffe(a3),a1           ; get buffer end
000095DA  BBC9                    1493      CMPA.l  a1,a5                   ; compare execute address with buffer end
000095DC  650A                    1494      BCS.s       LAB_164F                ; branch if BASIC pointer is in buffer
000095DE                          1495                                  ; can't continue in immediate mode
000095DE                          1496  
000095DE                          1497                                  ; else...
000095DE  274D 045A               1498      MOVE.l  a5,Cpntrl(a3)           ; save BASIC execute pointer as continue pointer
000095E2                          1499  LAB_1647
000095E2  276B 0452 0456          1500      MOVE.l  Clinel(a3),Blinel(a3)       ; save break line
000095E8                          1501  LAB_164F
000095E8  584F                    1502      ADDQ.w  #4,sp                   ; dump return address, don't return to execute
000095EA                          1503                                  ; loop
000095EA  102B 05DC               1504      MOVE.b  Breakf(a3),d0           ; get break flag
000095EE  6700 FB9A               1505      BEQ     LAB_1274                ; go do warm start if was program end
000095F2                          1506  
000095F2  41FA 2EB1               1507      LEA     LAB_BMSG(pc),a0         ; point to "Break"
000095F6  6000 FB84               1508      BRA     LAB_1269                ; print "Break" and do warm start
000095FA                          1509  
000095FA                          1510  
000095FA                          1511  ;************************************************************************************
000095FA                          1512  ;
000095FA                          1513  ; perform RESTORE
000095FA                          1514  
000095FA                          1515  LAB_RESTORE
000095FA  206B 042E               1516      MOVEA.l Smeml(a3),a0            ; copy start of memory
000095FE  6720                    1517      BEQ.s       LAB_1624                ; branch if next character null (RESTORE)
00009600                          1518  
00009600  6100 01F4               1519      BSR     LAB_GFPN                ; get fixed-point number into temp integer & d1
00009604  B2AB 0452               1520      CMP.l       Clinel(a3),d1           ; compare current line # with required line #
00009608  630E                    1521      BLS.s       LAB_GSCH                ; branch if >= (start search from beginning)
0000960A                          1522  
0000960A  204D                    1523      MOVEA.l a5,a0                   ; copy BASIC execute pointer
0000960C                          1524  LAB_RESs
0000960C  4A18                    1525      TST.b       (a0)+                   ; test next byte & increment pointer
0000960E  66FC                    1526      BNE.s       LAB_RESs                ; loop if not EOL
00009610                          1527  
00009610  3008                    1528      MOVE.w  a0,d0                   ; copy pointer
00009612  C07C 0001               1529      AND.w       #1,d0                   ; mask odd bit
00009616  D0C0                    1530      ADD.w       d0,a0                   ; add pointer
00009618                          1531                                  ; search for line in Itemp from (a0)
00009618                          1532  LAB_GSCH
00009618  6100 FDC8               1533      BSR     LAB_SCLN                ; search for d1 line number from a0
0000961C                          1534                                  ; returns Cb=0 if found
0000961C  6500 FB24               1535      BCS     LAB_USER                ; go do "Undefined statement" error if not found
00009620                          1536  
00009620                          1537  LAB_1624
00009620  4A20                    1538      TST.b       -(a0)                   ; decrement pointer (faster)
00009622  2748 0462               1539      MOVE.l  a0,Dptrl(a3)            ; save DATA pointer
00009626                          1540  RTS_006
00009626  4E75                    1541      RTS
00009628                          1542  
00009628                          1543  
00009628                          1544  ;************************************************************************************
00009628                          1545  ;
00009628                          1546  ; perform NULL
00009628                          1547  
00009628                          1548  LAB_NULL
00009628  6100 10E4               1549      BSR     LAB_GTBY                ; get byte parameter, result in d0 and Itemp
0000962C  1740 05E4               1550      MOVE.b  d0,Nullct(a3)           ; save new NULL count
00009630  4E75                    1551      RTS
00009632                          1552  
00009632                          1553  
00009632                          1554  ;************************************************************************************
00009632                          1555  ;
00009632                          1556  ; perform CONT
00009632                          1557  
00009632                          1558  LAB_CONT
00009632  6600 FB26               1559      BNE     LAB_SNER                ; if following byte exit to do syntax error
00009636                          1560  
00009636  4A2B 0452               1561      TST.b       Clinel(a3)              ; test current line #, is -ve for immediate mode
0000963A  6A00 FAE6               1562      BPL     LAB_CCER                ; if running go do can't continue error
0000963E                          1563  
0000963E  202B 045A               1564      MOVE.l  Cpntrl(a3),d0           ; get continue pointer
00009642  6700 FADE               1565      BEQ     LAB_CCER                ; go do can't continue error if we can't
00009646                          1566  
00009646                          1567                                  ; we can continue so ...
00009646  2A40                    1568      MOVEA.l d0,a5                   ; save continue pointer as BASIC execute pointer
00009648  276B 0456 0452          1569      MOVE.l  Blinel(a3),Clinel(a3)       ; set break line as current line
0000964E  4E75                    1570      RTS
00009650                          1571  
00009650                          1572  
00009650                          1573  ;************************************************************************************
00009650                          1574  ;
00009650                          1575  ; perform RUN
00009650                          1576  
00009650                          1577  LAB_RUN
00009650  660C                    1578      BNE.s       LAB_RUNn                ; if following byte do RUN n
00009652                          1579  
00009652  6100 FDAE               1580      BSR     LAB_1477                ; execution to start, clear vars & flush stack
00009656  274D 045A               1581      MOVE.l  a5,Cpntrl(a3)           ; save as continue pointer
0000965A  6000 FF22               1582      BRA     LAB_15C2                ; go do interpreter inner loop
0000965E                          1583                                  ; (can't RTS, we flushed the stack!)
0000965E                          1584  
0000965E                          1585  LAB_RUNn
0000965E  6100 FDA8               1586      BSR     LAB_147A                ; go do "CLEAR"
00009662  601C                    1587      BRA.s       LAB_16B0                ; get n and do GOTO n
00009664                          1588  
00009664                          1589  
00009664                          1590  ;************************************************************************************
00009664                          1591  ;
00009664                          1592  ; perform DO
00009664                          1593  
00009664                          1594  LAB_DO
00009664                          1595  ;   MOVE.l  #$05,d0             ; need 5 bytes for DO
00009664                          1596  ;   BSR.s       LAB_1212                ; check room on stack for A bytes
00009664  2F0D                    1597      MOVE.l  a5,-(sp)                ; push BASIC execute pointer on stack
00009666  2F2B 0452               1598      MOVE.l  Clinel(a3),-(sp)            ; push current line on stack
0000966A  3F3C 009C               1599      MOVE.w  #TK_DO,-(sp)            ; push token for DO on stack
0000966E  487A FF0E               1600      PEA     LAB_15C2(pc)            ; set return address
00009672  6000 0730               1601      BRA     LAB_GBYT                ; scan memory & return to interpreter inner loop
00009676                          1602  
00009676                          1603  
00009676                          1604  ;************************************************************************************
00009676                          1605  ;
00009676                          1606  ; perform GOSUB
00009676                          1607  
00009676                          1608  LAB_GOSUB
00009676                          1609  ;   MOVE.l  #10,d0              ; need 10 bytes for GOSUB
00009676                          1610  ;   BSR.s       LAB_1212                ; check room on stack for d0 bytes
00009676  2F0D                    1611      MOVE.l  a5,-(sp)                ; push BASIC execute pointer
00009678  2F2B 0452               1612      MOVE.l  Clinel(a3),-(sp)            ; push current line
0000967C  3F3C 008D               1613      MOVE.w  #TK_GOSUB,-(sp)         ; push token for GOSUB
00009680                          1614  LAB_16B0
00009680  6100 0722               1615      BSR     LAB_GBYT                ; scan memory
00009684  487A FEF8               1616      PEA     LAB_15C2(pc)            ; return to interpreter inner loop after GOTO n
00009688                          1617  
00009688                          1618  ; this PEA is needed because either we just cleared the stack and have nowhere to return
00009688                          1619  ; to or, in the case of GOSUB, we have just dropped a load on the stack and the address
00009688                          1620  ; we whould have returned to is buried. This burried return address will be unstacked by
00009688                          1621  ; the corresponding RETURN command
00009688                          1622  
00009688                          1623  
00009688                          1624  ;************************************************************************************
00009688                          1625  ;
00009688                          1626  ; perform GOTO
00009688                          1627  
00009688                          1628  LAB_GOTO
00009688  6100 016C               1629      BSR     LAB_GFPN                ; get fixed-point number into temp integer & d1
0000968C  206B 042E               1630      MOVEA.l Smeml(a3),a0            ; get start of memory
00009690  B2AB 0452               1631      CMP.l       Clinel(a3),d1           ; compare current line with wanted #
00009694  630E                    1632      BLS.s       LAB_16D0                ; branch if current # => wanted #
00009696                          1633  
00009696  204D                    1634      MOVEA.l a5,a0                   ; copy BASIC execute pointer
00009698                          1635  LAB_GOTs
00009698  4A18                    1636      TST.b       (a0)+                   ; test next byte & increment pointer
0000969A  66FC                    1637      BNE.s       LAB_GOTs                ; loop if not EOL
0000969C                          1638  
0000969C  3008                    1639      MOVE.w  a0,d0                   ; past pad byte(s)
0000969E  C07C 0001               1640      AND.w       #1,d0                   ; mask odd bit
000096A2  D0C0                    1641      ADD.w       d0,a0                   ; add to pointer
000096A4                          1642  
000096A4                          1643  LAB_16D0
000096A4  6100 FD3C               1644      BSR     LAB_SCLN                ; search for d1 line number from a0
000096A8                          1645                                  ; returns Cb=0 if found
000096A8  6500 FA98               1646      BCS     LAB_USER                ; if carry set go do "Undefined statement" error
000096AC                          1647  
000096AC  2A48                    1648      MOVEA.l a0,a5                   ; copy to basic execute pointer
000096AE  534D                    1649      SUBQ.w  #1,a5                   ; decrement pointer
000096B0  274D 045A               1650      MOVE.l  a5,Cpntrl(a3)           ; save as continue pointer
000096B4  4E75                    1651      RTS
000096B6                          1652  
000096B6                          1653  
000096B6                          1654  ;************************************************************************************
000096B6                          1655  ;
000096B6                          1656  ; perform LOOP
000096B6                          1657  
000096B6                          1658  LAB_LOOP
000096B6  0C6F 009C 0004          1659      CMP.w       #TK_DO,4(sp)            ; compare token on stack with DO token
000096BC  6600 FA5C               1660      BNE     LAB_LDER                ; branch if no matching DO
000096C0                          1661  
000096C0  1E00                    1662      MOVE.b  d0,d7                   ; copy following token (byte)
000096C2  672E                    1663      BEQ.s       LoopAlways              ; if no following token loop forever
000096C4                          1664  
000096C4  BE3C 003A               1665      CMP.b       #':',d7             ; compare with ":"
000096C8  6728                    1666      BEQ.s       LoopAlways              ; if no following token loop forever
000096CA                          1667  
000096CA  0407 00B0               1668      SUB.b       #TK_UNTIL,d7            ; subtract token for UNTIL
000096CE  6708                    1669      BEQ.s       DoRest              ; branch if was UNTIL
000096D0                          1670  
000096D0  5307                    1671      SUBQ.b  #1,d7                   ; decrement result
000096D2  6600 FA86               1672      BNE     LAB_SNER                ; if not WHILE go do syntax error & warm start
000096D6                          1673                                  ; only if the token was WHILE will this fail
000096D6                          1674  
000096D6  7EFF                    1675      MOVEQ       #-1,d7              ; set invert result longword
000096D8                          1676  DoRest
000096D8  6100 06C8               1677      BSR     LAB_IGBY                ; increment & scan memory
000096DC  6100 0564               1678      BSR     LAB_EVEX                ; evaluate expression
000096E0  4A2B 0594               1679      TST.b       FAC1_e(a3)              ; test FAC1 exponent
000096E4  6706                    1680      BEQ.s       DoCmp                   ; if = 0 go do straight compare
000096E6                          1681  
000096E6  177C 00FF 0594          1682      MOVE.b  #$FF,FAC1_e(a3)         ; else set all bits
000096EC                          1683  DoCmp
000096EC  BF2B 0594               1684      EOR.b       d7,FAC1_e(a3)           ; EOR with invert byte
000096F0  6614                    1685      BNE.s       LoopDone                ; if <> 0 clear stack & back to interpreter loop
000096F2                          1686  
000096F2                          1687                                  ; loop condition wasn't met so do it again
000096F2                          1688  LoopAlways
000096F2  276F 0006 0452          1689      MOVE.l  6(sp),Clinel(a3)            ; copy DO current line
000096F8  2A6F 000A               1690      MOVE.l  10(sp),a5               ; save BASIC execute pointer
000096FC                          1691  
000096FC  41FA FE80               1692      LEA     LAB_15C2(pc),a0         ; get return address
00009700  2E88                    1693      MOVE.l  a0,(sp)             ; dump the call to this routine and set the
00009702                          1694                                  ; return address
00009702  6000 06A0               1695      BRA     LAB_GBYT                ; scan memory and return to interpreter inner
00009706                          1696                                  ; loop
00009706                          1697  
00009706                          1698                                  ; clear stack & back to interpreter loop
00009706                          1699  LoopDone
00009706  4FEF 000E               1700      LEA     14(sp),sp               ; dump structure and call from stack
0000970A  6014                    1701      BRA.s       LAB_DATA                ; go perform DATA (find : or [EOL])
0000970C                          1702  
0000970C                          1703  
0000970C                          1704  ;************************************************************************************
0000970C                          1705  ;
0000970C                          1706  ; perform RETURN
0000970C                          1707  
0000970C                          1708  LAB_RETURN
0000970C  6616                    1709      BNE.s       RTS_007             ; exit if following token to allow syntax error
0000970E                          1710  
0000970E  0C6F 008D 0004          1711      CMP.w       #TK_GOSUB,4(sp)         ; compare token from stack with GOSUB
00009714  6600 FA40               1712      BNE     LAB_RGER                ; do RETURN without GOSUB error if no matching
00009718                          1713                                  ; GOSUB
00009718                          1714  
00009718  5C4F                    1715      ADDQ.w  #6,sp                   ; dump calling address & token
0000971A  275F 0452               1716      MOVE.l  (sp)+,Clinel(a3)            ; pull current line
0000971E  2A5F                    1717      MOVE.l  (sp)+,a5                ; pull BASIC execute pointer
00009720                          1718                                  ; now do perform "DATA" statement as we could be
00009720                          1719                                  ; returning into the middle of an ON <var> GOSUB
00009720                          1720                                  ; n,m,p,q line (the return address used by the
00009720                          1721                                  ; DATA statement is the one pushed before the
00009720                          1722                                  ; GOSUB was executed!)
00009720                          1723  
00009720                          1724  
00009720                          1725  ;************************************************************************************
00009720                          1726  ;
00009720                          1727  ; perform DATA
00009720                          1728  
00009720                          1729  LAB_DATA
00009720  6104                    1730      BSR.s       LAB_SNBS                ; scan for next BASIC statement ([:] or [EOL])
00009722                          1731                                  ; returns a0 as pointer to [:] or [EOL]
00009722  2A48                    1732      MOVEA.l a0,a5                   ; skip rest of statement
00009724                          1733  RTS_007
00009724  4E75                    1734      RTS
00009726                          1735  
00009726                          1736  
00009726                          1737  ;************************************************************************************
00009726                          1738  ;
00009726                          1739  ; scan for next BASIC statement ([:] or [EOL])
00009726                          1740  ; returns a0 as pointer to [:] or [EOL]
00009726                          1741  
00009726                          1742  LAB_SNBS
00009726  204D                    1743      MOVEA.l a5,a0                   ; copy BASIC execute pointer
00009728  7222                    1744      MOVEQ       #$22,d1             ; set string quote character
0000972A  743A                    1745      MOVEQ       #$3A,d2             ; set look for character = ":"
0000972C  6008                    1746      BRA.s       LAB_172D                ; go do search
0000972E                          1747  
0000972E                          1748  LAB_172C
0000972E  B400                    1749      CMP.b       d0,d2                   ; compare with ":"
00009730  6708                    1750      BEQ.s       RTS_007a                ; exit if found
00009732                          1751  
00009732  B200                    1752      CMP.b       d0,d1                   ; compare with '"'
00009734  670C                    1753      BEQ.s       LAB_1725                ; if found go search for [EOL]
00009736                          1754  
00009736                          1755  LAB_172D
00009736  1018                    1756      MOVE.b  (a0)+,d0                ; get next byte
00009738  66F4                    1757      BNE.s       LAB_172C                ; loop if not null [EOL]
0000973A                          1758  
0000973A                          1759  RTS_007a
0000973A  5348                    1760      SUBQ.w  #1,a0                   ; correct pointer
0000973C  4E75                    1761      RTS
0000973E                          1762  
0000973E                          1763  LAB_1723
0000973E  B200                    1764      CMP.b       d0,d1                   ; compare with '"'
00009740  67F4                    1765      BEQ.s       LAB_172D                ; if found go search for ":" or [EOL]
00009742                          1766  
00009742                          1767  LAB_1725
00009742  1018                    1768      MOVE.b  (a0)+,d0                ; get next byte
00009744  66F8                    1769      BNE.s       LAB_1723                ; loop if not null [EOL]
00009746                          1770  
00009746  60F2                    1771      BRA.s       RTS_007a                ; correct pointer & return
00009748                          1772  
00009748                          1773  
00009748                          1774  ;************************************************************************************
00009748                          1775  ;
00009748                          1776  ; perform IF
00009748                          1777  
00009748                          1778  LAB_IF
00009748  6100 04F8               1779      BSR     LAB_EVEX                ; evaluate expression
0000974C  6100 0656               1780      BSR     LAB_GBYT                ; scan memory
00009750  B03C 00AD               1781      CMP.b       #TK_THEN,d0             ; compare with THEN token
00009754  6714                    1782      BEQ.s       LAB_174B                ; if it was THEN then continue
00009756                          1783  
00009756                          1784                                  ; wasn't IF .. THEN so must be IF .. GOTO
00009756  B03C 0089               1785      CMP.b       #TK_GOTO,d0             ; compare with GOTO token
0000975A  6600 F9FE               1786      BNE     LAB_SNER                ; if not GOTO token do syntax error/warm start
0000975E                          1787  
0000975E                          1788                                  ; was GOTO so check for GOTO <n>
0000975E  204D                    1789      MOVE.l  a5,a0                   ; save the execute pointer
00009760  6100 0640               1790      BSR     LAB_IGBY                ; scan memory, test for a numeric character
00009764  2A48                    1791      MOVE.l  a0,a5                   ; restore the execute pointer
00009766  6400 F9F2               1792      BCC     LAB_SNER                ; if not numeric do syntax error/warm start
0000976A                          1793  
0000976A                          1794  LAB_174B
0000976A  102B 0594               1795      MOVE.b  FAC1_e(a3),d0           ; get FAC1 exponent
0000976E  671E                    1796      BEQ.s       LAB_174E                ; if result was zero go look for an ELSE
00009770                          1797  
00009770  6100 0630               1798      BSR     LAB_IGBY                ; increment & scan memory
00009774  6500 FF12               1799      BCS     LAB_GOTO                ; if numeric do GOTO n
00009778                          1800                                  ; a GOTO <n> will never return to the IF
00009778                          1801                                  ; statement so there is no need to return
00009778                          1802                                  ; to this code
00009778                          1803  
00009778  B03C 008E               1804      CMP.b       #TK_RETURN,d0           ; compare with RETURN token
0000977C  6700 FE1E               1805      BEQ     LAB_1602                ; if RETURN then interpret BASIC code from (a5)
00009780                          1806                                  ; and don't return here
00009780                          1807  
00009780  6100 FE16               1808      BSR     LAB_15FF                ; else interpret BASIC code from (a5)
00009784                          1809  
00009784                          1810  ; the IF was executed and there may be a following ELSE so the code needs to return
00009784                          1811  ; here to check and ignore the ELSE if present
00009784                          1812  
00009784  1015                    1813      MOVE.b  (a5),d0             ; get the next basic byte
00009786  B03C 00A9               1814      CMP.b       #TK_ELSE,d0             ; compare it with the token for ELSE
0000978A  6794                    1815      BEQ     LAB_DATA                ; if ELSE ignore the following statement
0000978C                          1816  
0000978C                          1817  ; there was no ELSE so continue execution of IF <expr> THEN <stat> [: <stat>]. any
0000978C                          1818  ; following ELSE will, correctly, cause a syntax error
0000978C                          1819  
0000978C  4E75                    1820      RTS                         ; else return to interpreter inner loop
0000978E                          1821  
0000978E                          1822  ; perform ELSE after IF
0000978E                          1823  
0000978E                          1824  LAB_174E
0000978E  101D                    1825      MOVE.b  (a5)+,d0                ; faster increment past THEN
00009790  163C 00A9               1826      MOVE.b      #TK_ELSE,d3             ; set search for ELSE token
00009794  183C 008B               1827      MOVE.b      #TK_IF,d4               ; set search for IF token
00009798  7A00                    1828      MOVEQ       #0,d5                   ; clear the nesting depth
0000979A                          1829  LAB_1750
0000979A  101D                    1830      MOVE.b  (a5)+,d0                ; get next BASIC byte & increment ptr
0000979C  6720                    1831      BEQ.s       LAB_1754                ; if EOL correct the pointer and return
0000979E                          1832  
0000979E  B004                    1833      CMP.b       d4,d0                   ; compare with "IF" token
000097A0  6604                    1834      BNE.s       LAB_1752                ; skip if not nested IF
000097A2                          1835  
000097A2  5245                    1836      ADDQ.w  #1,d5                   ; else increment the nesting depth ..
000097A4  60F4                    1837      BRA.s       LAB_1750                ; .. and continue looking
000097A6                          1838  
000097A6                          1839  LAB_1752
000097A6  B003                    1840      CMP.b       d3,d0                   ; compare with ELSE token
000097A8  66F0                    1841      BNE.s       LAB_1750                ; if not ELSE continue looking
000097AA                          1842  
000097AA                          1843  LAB_1756
000097AA  51CD FFEE               1844      DBF     d5,LAB_1750             ; loop if still nested
000097AE                          1845  
000097AE                          1846  ; found the matching ELSE, now do <{n|statement}>
000097AE                          1847  
000097AE  6100 05F4               1848      BSR     LAB_GBYT                ; scan memory
000097B2  6500 FED4               1849      BCS     LAB_GOTO                ; if numeric do GOTO n
000097B6                          1850                                  ; code will return to the interpreter loop
000097B6                          1851                                  ; at the tail end of the GOTO <n>
000097B6                          1852  
000097B6  6000 FDE0               1853      BRA     LAB_15FF                ; else interpret BASIC code from (a5)
000097BA                          1854                                  ; code will return to the interpreter loop
000097BA                          1855                                  ; at the tail end of the <statement>
000097BA                          1856  
000097BA                          1857  
000097BA                          1858  ;************************************************************************************
000097BA                          1859  ;
000097BA                          1860  ; perform REM, skip (rest of) line
000097BA                          1861  
000097BA                          1862  LAB_REM
000097BA  4A1D                    1863      TST.b       (a5)+                   ; test byte & increment pointer
000097BC  66FC                    1864      BNE.s       LAB_REM             ; loop if not EOL
000097BE                          1865  
000097BE                          1866  LAB_1754
000097BE  534D                    1867      SUBQ.w  #1,a5                   ; correct the execute pointer
000097C0  4E75                    1868      RTS
000097C2                          1869  
000097C2                          1870  
000097C2                          1871  ;************************************************************************************
000097C2                          1872  ;
000097C2                          1873  ; perform ON
000097C2                          1874  
000097C2                          1875  LAB_ON
000097C2  6100 0F4A               1876      BSR     LAB_GTBY                ; get byte parameter, result in d0 and Itemp
000097C6  1400                    1877      MOVE.b  d0,d2                   ; copy byte
000097C8  6100 05DA               1878      BSR     LAB_GBYT                ; restore BASIC byte
000097CC  3F00                    1879      MOVE.w  d0,-(sp)                ; push GOTO/GOSUB token
000097CE  B03C 008D               1880      CMP.b       #TK_GOSUB,d0            ; compare with GOSUB token
000097D2  6708                    1881      BEQ.s       LAB_176C                ; branch if GOSUB
000097D4                          1882  
000097D4  B03C 0089               1883      CMP.b       #TK_GOTO,d0             ; compare with GOTO token
000097D8  6600 F980               1884      BNE     LAB_SNER                ; if not GOTO do syntax error, then warm start
000097DC                          1885  
000097DC                          1886  ; next character was GOTO or GOSUB
000097DC                          1887  
000097DC                          1888  LAB_176C
000097DC  5302                    1889      SUBQ.b  #1,d2                   ; decrement index (byte value)
000097DE  6606                    1890      BNE.s       LAB_1773                ; branch if not zero
000097E0                          1891  
000097E0  301F                    1892      MOVE.w  (sp)+,d0                ; pull GOTO/GOSUB token
000097E2  6000 FDB8               1893      BRA     LAB_1602                ; go execute it
000097E6                          1894  
000097E6                          1895  LAB_1773
000097E6  6100 05BA               1896      BSR     LAB_IGBY                ; increment & scan memory
000097EA  610A                    1897      BSR.s       LAB_GFPN                ; get fixed-point number into temp integer & d1
000097EC                          1898                                  ; (skip this n)
000097EC  B03C 002C               1899      CMP.b       #$2C,d0             ; compare next character with ","
000097F0  67EA                    1900      BEQ.s       LAB_176C                ; loop if ","
000097F2                          1901  
000097F2  301F                    1902      MOVE.w  (sp)+,d0                ; pull GOTO/GOSUB token (run out of options)
000097F4  4E75                    1903      RTS                         ; and exit
000097F6                          1904  
000097F6                          1905  
000097F6                          1906  ;************************************************************************************
000097F6                          1907  ;
000097F6                          1908  ; get fixed-point number into temp integer & d1
000097F6                          1909  ; interpret number from (a5), leave (a5) pointing to byte after #
000097F6                          1910  
000097F6                          1911  LAB_GFPN
000097F6  7200                    1912      MOVEQ       #$00,d1             ; clear integer register
000097F8  2001                    1913      MOVE.l  d1,d0                   ; clear d0
000097FA  6100 05A8               1914      BSR     LAB_GBYT                ; scan memory, Cb=1 if "0"-"9", & get byte
000097FE  642E                    1915      BCC.s       LAB_1786                ; return if carry clear, chr was not "0"-"9"
00009800                          1916  
00009800  2F02                    1917      MOVE.l  d2,-(sp)                ; save d2
00009802                          1918  LAB_1785
00009802  2401                    1919      MOVE.l  d1,d2                   ; copy integer register
00009804  D281                    1920      ADD.l       d1,d1                   ; *2
00009806  6500 F952               1921      BCS     LAB_SNER                ; if overflow do syntax error, then warm start
0000980A                          1922  
0000980A  D281                    1923      ADD.l       d1,d1                   ; *4
0000980C  6500 F94C               1924      BCS     LAB_SNER                ; if overflow do syntax error, then warm start
00009810                          1925  
00009810  D282                    1926      ADD.l       d2,d1                   ; *1 + *4
00009812  6500 F946               1927      BCS     LAB_SNER                ; if overflow do syntax error, then warm start
00009816                          1928  
00009816  D281                    1929      ADD.l       d1,d1                   ; *10
00009818  6500 F940               1930      BCS     LAB_SNER                ; if overflow do syntax error, then warm start
0000981C                          1931  
0000981C  0400 0030               1932      SUB.b       #$30,d0             ; subtract $30 from byte
00009820  D280                    1933      ADD.l       d0,d1                   ; add to integer register, the top 24 bits are
00009822                          1934                                  ; always clear
00009822  6900 F936               1935      BVS     LAB_SNER                ; if overflow do syntax error, then warm start
00009826                          1936                                  ; this makes the maximum line number 2147483647
00009826  6100 057A               1937      BSR     LAB_IGBY                ; increment & scan memory
0000982A  65D6                    1938      BCS.s       LAB_1785                ; loop for next character if "0"-"9"
0000982C                          1939  
0000982C  241F                    1940      MOVE.l  (sp)+,d2                ; restore d2
0000982E                          1941  LAB_1786
0000982E  2741 042A               1942      MOVE.l  d1,Itemp(a3)            ; save Itemp
00009832  4E75                    1943      RTS
00009834                          1944  
00009834                          1945  
00009834                          1946  ;************************************************************************************
00009834                          1947  ;
00009834                          1948  ; perform DEC
00009834                          1949  
00009834                          1950  LAB_DEC
00009834  3F3C 8180               1951      MOVE.w  #$8180,-(sp)            ; set -1 sign/exponent
00009838  600A                    1952      BRA.s       LAB_17B7                ; go do DEC
0000983A                          1953  
0000983A                          1954  
0000983A                          1955  ;************************************************************************************
0000983A                          1956  ;
0000983A                          1957  ; perform INC
0000983A                          1958  
0000983A                          1959  LAB_INC
0000983A  3F3C 8100               1960      MOVE.w  #$8100,-(sp)            ; set 1 sign/exponent
0000983E  6004                    1961      BRA.s       LAB_17B7                ; go do INC
00009840                          1962  
00009840                          1963                                  ; was "," so another INCR variable to do
00009840                          1964  LAB_17B8
00009840  6100 0560               1965      BSR     LAB_IGBY                ; increment and scan memory
00009844                          1966  LAB_17B7
00009844  6100 076E               1967      BSR     LAB_GVAR                ; get variable address in a0
00009848                          1968  
00009848  6732                    1969      BEQ.s       LAB_INCT                ; if variable not found skip the inc/dec
0000984A  4A2B 05B5               1970      TST.b       Dtypef(a3)              ; test data type, $80=string, $40=integer,
0000984E                          1971                                  ; $00=float
0000984E  6B00 F8DE               1972      BMI     LAB_TMER                ; if string do "Type mismatch" error/warm start
00009852                          1973  
00009852  6636                    1974      BNE.s       LAB_INCI                ; go do integer INC/DEC
00009854                          1975  
00009854  2748 0472               1976      MOVE.l  a0,Lvarpl(a3)           ; save var address
00009858  6100 1310               1977      BSR     LAB_UFAC                ; unpack memory (a0) into FAC1
0000985C  277C 80000000 0598      1978      MOVE.l  #$80000000,FAC2_m(a3)       ; set FAC2 mantissa for 1
00009864  3017                    1979      MOVE.w  (sp),d0             ; move exponent & sign to d0
00009866  3740 059C               1980      MOVE.w  d0,FAC2_e(a3)           ; move exponent & sign to FAC2
0000986A  176B 0595 059E          1981      MOVE.b  FAC1_s(a3),FAC_sc(a3)       ; make sign compare = FAC1 sign
00009870  B12B 059E               1982      EOR.b       d0,FAC_sc(a3)           ; make sign compare (FAC1_s EOR FAC2_s)
00009874  6100 1010               1983      BSR     LAB_ADD             ; add FAC2 to FAC1
00009878  6100 130C               1984      BSR     LAB_PFAC                ; pack FAC1 into variable (Lvarpl)
0000987C                          1985  LAB_INCT
0000987C  6100 0526               1986      BSR     LAB_GBYT                ; scan memory
00009880  0C00 002C               1987      CMPI.b  #$2C,d0             ; compare with ","
00009884  67BA                    1988      BEQ.s       LAB_17B8                ; continue if "," (another variable to do)
00009886                          1989  
00009886  544F                    1990      ADDQ.w  #2,sp                   ; else dump sign & exponent
00009888  4E75                    1991      RTS
0000988A                          1992  
0000988A                          1993  LAB_INCI
0000988A  4A2F 0001               1994      TST.b       1(sp)                   ; test sign
0000988E  6604                    1995      BNE.s       LAB_DECI                ; branch if DEC
00009890                          1996  
00009890  5290                    1997      ADDQ.l  #1,(a0)             ; increment variable
00009892  60E8                    1998      BRA.s       LAB_INCT                ; go scan for more
00009894                          1999  
00009894                          2000  LAB_DECI
00009894  5390                    2001      SUBQ.l  #1,(a0)             ; decrement variable
00009896  60E4                    2002      BRA.s       LAB_INCT                ; go scan for more
00009898                          2003  
00009898                          2004  
00009898                          2005  ;************************************************************************************
00009898                          2006  ;
00009898                          2007  ; perform LET
00009898                          2008  
00009898                          2009  LAB_LET
00009898  6100 0716               2010      BSR     LAB_SVAR                ; search for or create a variable
0000989C                          2011                                  ; return the variable address in a0
0000989C  2748 0472               2012      MOVE.l  a0,Lvarpl(a3)           ; save variable address
000098A0  1F2B 05B5               2013      MOVE.b  Dtypef(a3),-(sp)            ; push var data type, $80=string, $40=integer,
000098A4                          2014                                  ; $00=float
000098A4  70BD                    2015      MOVEQ       #TK_EQUAL-$100,d0           ; get = token
000098A6  6100 04F2               2016      BSR     LAB_SCCA                ; scan for CHR$(d0), else do syntax error/warm
000098AA                          2017                                  ; start
000098AA  6100 0396               2018      BSR     LAB_EVEX                ; evaluate expression
000098AE  102B 05B5               2019      MOVE.b  Dtypef(a3),d0           ; copy expression data type
000098B2  175F 05B5               2020      MOVE.b  (sp)+,Dtypef(a3)            ; pop variable data type
000098B6  E318                    2021      ROL.b       #1,d0                   ; set carry if expression type = string
000098B8  6100 0374               2022      BSR     LAB_CKTM                ; type match check, set C for string
000098BC  6700 12C8               2023      BEQ     LAB_PFAC                ; if number pack FAC1 into variable Lvarpl & RET
000098C0                          2024  
000098C0                          2025  ; string LET
000098C0                          2026  
000098C0                          2027  LAB_17D5
000098C0  246B 0472               2028      MOVEA.l Lvarpl(a3),a2           ; get pointer to variable
000098C4                          2029  LAB_17D6
000098C4  206B 0590               2030      MOVEA.l FAC1_m(a3),a0           ; get descriptor pointer
000098C8  2250                    2031      MOVEA.l (a0),a1             ; get string pointer
000098CA  B3EB 0446               2032      CMP.l       Sstorl(a3),a1           ; compare string memory start with string
000098CE                          2033                                  ; pointer
000098CE  6516                    2034      BCS.s       LAB_1811                ; if it was in program memory assign the value
000098D0                          2035                                  ; and exit
000098D0                          2036  
000098D0  B1EB 0432               2037      CMPA.l  Sfncl(a3),a0            ; compare functions start with descriptor
000098D4                          2038                                  ; pointer
000098D4  6510                    2039      BCS.s       LAB_1811                ; branch if >= (string is on stack)
000098D6                          2040  
000098D6                          2041                                  ; string is variable$ make space and copy string
000098D6                          2042  LAB_1810
000098D6  7200                    2043      MOVEQ       #0,d1                   ; clear length
000098D8  3228 0004               2044      MOVE.w  4(a0),d1                ; get string length
000098DC  2050                    2045      MOVEA.l (a0),a0             ; get string pointer
000098DE  6100 0B08               2046      BSR     LAB_20C9                ; copy string
000098E2  206B 0590               2047      MOVEA.l FAC1_m(a3),a0           ; get descriptor pointer back
000098E6                          2048                                  ; clean stack & assign value to string variable
000098E6                          2049  LAB_1811
000098E6  B9C8                    2050      CMPA.l  a0,a4                   ; is string on the descriptor stack
000098E8  6602                    2051      BNE.s       LAB_1813                ; skip pop if not
000098EA                          2052  
000098EA  5C4C                    2053      ADDQ.w  #$06,a4             ; else update stack pointer
000098EC                          2054  LAB_1813
000098EC  24D8                    2055      MOVE.l  (a0)+,(a2)+             ; save pointer to variable
000098EE  3490                    2056      MOVE.w  (a0),(a2)               ; save length to variable
000098F0                          2057  RTS_008
000098F0  4E75                    2058      RTS
000098F2                          2059  
000098F2                          2060  
000098F2                          2061  ;************************************************************************************
000098F2                          2062  ;
000098F2                          2063  ; perform GET
000098F2                          2064  
000098F2                          2065  LAB_GET
000098F2  6100 06BC               2066      BSR     LAB_SVAR                ; search for or create a variable
000098F6                          2067                                  ; return the variable address in a0
000098F6  2748 0472               2068      MOVE.l  a0,Lvarpl(a3)           ; save variable address as GET variable
000098FA  4A2B 05B5               2069      TST.b       Dtypef(a3)              ; test data type, $80=string, $40=integer,
000098FE                          2070                                  ; $00=float
000098FE  6B0C                    2071      BMI.s       LAB_GETS                ; go get string character
00009900                          2072  
00009900                          2073                                  ; was numeric get
00009900  6100 1DF0               2074      BSR     INGET                   ; get input byte
00009904  6100 09BE               2075      BSR     LAB_1FD0                ; convert d0 to unsigned byte in FAC1
00009908  6000 127C               2076      BRA     LAB_PFAC                ; pack FAC1 into variable (Lvarpl) & return
0000990C                          2077  
0000990C                          2078  LAB_GETS
0000990C  7200                    2079      MOVEQ       #$00,d1             ; assume no byte
0000990E  2041                    2080      MOVE.l  d1,a0                   ; assume null string
00009910  6100 1DE0               2081      BSR     INGET                   ; get input byte
00009914  6408                    2082      BCC.s       LAB_NoSt                ; branch if no byte received
00009916                          2083  
00009916  7201                    2084      MOVEQ       #$01,d1             ; string is single byte
00009918  6100 0B00               2085      BSR     LAB_2115                ; make string space d1 bytes long
0000991C                          2086                                  ; return a0 = pointer, other registers unchanged
0000991C                          2087  
0000991C  1080                    2088      MOVE.b  d0,(a0)             ; save byte in string (byte IS string!)
0000991E                          2089  LAB_NoSt
0000991E  6100 0AE0               2090      BSR     LAB_RTST                ; push string on descriptor stack
00009922                          2091                                  ; a0 = pointer, d1 = length
00009922                          2092  
00009922  609C                    2093      BRA.s       LAB_17D5                ; do string LET & return
00009924                          2094  
00009924                          2095  
00009924                          2096  ;************************************************************************************
00009924                          2097  ;
00009924                          2098  ; PRINT
00009924                          2099  
00009924                          2100  LAB_1829
00009924  6100 00B6               2101      BSR     LAB_18C6                ; print string from stack
00009928                          2102  LAB_182C
00009928  6100 047A               2103      BSR     LAB_GBYT                ; scan memory
0000992C                          2104  
0000992C                          2105  ; perform PRINT
0000992C                          2106  
0000992C                          2107  LAB_PRINT
0000992C  674C                    2108      BEQ.s       LAB_CRLF                ; if nothing following just print CR/LF
0000992E                          2109  
0000992E                          2110  LAB_1831
0000992E  B03C 00A8               2111      CMP.b       #TK_TAB,d0              ; compare with TAB( token
00009932  6766                    2112      BEQ.s       LAB_18A2                ; go do TAB/SPC
00009934                          2113  
00009934  B03C 00AC               2114      CMP.b       #TK_SPC,d0              ; compare with SPC( token
00009938  6760                    2115      BEQ.s       LAB_18A2                ; go do TAB/SPC
0000993A                          2116  
0000993A  B03C 002C               2117      CMP.b       #',',d0             ; compare with ","
0000993E  6742                    2118      BEQ.s       LAB_188B                ; go do move to next TAB mark
00009940                          2119  
00009940  B03C 003B               2120      CMP.b       #';',d0             ; compare with ";"
00009944  6700 0088               2121      BEQ     LAB_18BD                ; if ";" continue with PRINT processing
00009948                          2122  
00009948  6100 02F8               2123      BSR     LAB_EVEX                ; evaluate expression
0000994C  4A2B 05B5               2124      TST.b       Dtypef(a3)              ; test data type, $80=string, $40=integer,
00009950                          2125                                  ; $00=float
00009950  6BD2                    2126      BMI.s       LAB_1829                ; branch if string
00009952                          2127  
00009952                          2128  ; replace the two lines above with this code
00009952                          2129  
00009952                          2130  ;   MOVE.b  Dtypef(a3),d0           ; get data type flag, $80=string, $00=numeric
00009952                          2131  ;   BMI.s       LAB_1829                ; branch if string
00009952                          2132  
00009952  6100 13B4               2133      BSR     LAB_2970                ; convert FAC1 to string
00009956  6100 0A62               2134      BSR     LAB_20AE                ; print " terminated string to FAC1 stack
0000995A                          2135  
0000995A                          2136  ; don't check fit if terminal width byte is zero
0000995A                          2137  
0000995A  7000                    2138      MOVEQ       #0,d0                   ; clear d0
0000995C  102B 05E6               2139      MOVE.b  TWidth(a3),d0           ; get terminal width byte
00009960  670E                    2140      BEQ.s       LAB_185E                ; skip check if zero
00009962                          2141  
00009962  902C 0007               2142      SUB.b       7(a4),d0                ; subtract string length
00009966  902B 05E5               2143      SUB.b       TPos(a3),d0             ; subtract terminal position
0000996A  6400 0004               2144      BCC     LAB_185E                ; branch if less than terminal width
0000996E                          2145  
0000996E  610A                    2146      BSR.s       LAB_CRLF                ; else print CR/LF
00009970                          2147  LAB_185E
00009970  616A                    2148      BSR.s       LAB_18C6                ; print string from stack
00009972  60B4                    2149      BRA.s       LAB_182C                ; always go continue processing line
00009974                          2150  
00009974                          2151  
00009974                          2152  ;************************************************************************************
00009974                          2153  ;
00009974                          2154  ; CR/LF return to BASIC from BASIC input handler
00009974                          2155  ; leaves a0 pointing to the buffer start
00009974                          2156  
00009974                          2157  LAB_1866
00009974  11BC 0000 1000          2158      MOVE.b  #$00,(a0,d1.w)          ; null terminate input
0000997A                          2159  
0000997A                          2160  ; print CR/LF
0000997A                          2161  
0000997A                          2162  LAB_CRLF
0000997A  700D                    2163      MOVEQ       #$0D,d0             ; load [CR]
0000997C  6174                    2164      BSR.s       LAB_PRNA                ; go print the character
0000997E  700A                    2165      MOVEQ       #$0A,d0             ; load [LF]
00009980  6070                    2166      BRA.s       LAB_PRNA                ; go print the character & return
00009982                          2167  
00009982                          2168  LAB_188B
00009982  142B 05E5               2169      MOVE.b  TPos(a3),d2             ; get terminal position
00009986  B42B 05E7               2170      CMP.b       Iclim(a3),d2            ; compare with input column limit
0000998A  6504                    2171      BCS.s       LAB_1898                ; branch if less than Iclim
0000998C                          2172  
0000998C  61EC                    2173      BSR.s       LAB_CRLF                ; else print CR/LF (next line)
0000998E  603E                    2174      BRA.s       LAB_18BD                ; continue with PRINT processing
00009990                          2175  
00009990                          2176  LAB_1898
00009990  942B 05E2               2177      SUB.b       TabSiz(a3),d2           ; subtract TAB size
00009994  64FA                    2178      BCC.s       LAB_1898                ; loop if result was >= 0
00009996                          2179  
00009996  4402                    2180      NEG.b       d2                  ; twos complement it
00009998  6022                    2181      BRA.s       LAB_18B7                ; print d2 spaces
0000999A                          2182  
0000999A                          2183                                  ; do TAB/SPC
0000999A                          2184  LAB_18A2
0000999A  3F00                    2185      MOVE.w  d0,-(sp)                ; save token
0000999C  6100 0D6C               2186      BSR     LAB_SGBY                ; increment and get byte, result in d0 and Itemp
000099A0  3400                    2187      MOVE.w  d0,d2                   ; copy byte
000099A2  6100 0400               2188      BSR     LAB_GBYT                ; get basic byte back
000099A6  B03C 0029               2189      CMP.b       #$29,d0             ; is next character ")"
000099AA  6600 F7AE               2190      BNE     LAB_SNER                ; if not do syntax error, then warm start
000099AE                          2191  
000099AE  301F                    2192      MOVE.w  (sp)+,d0                ; get token back
000099B0  B03C 00A8               2193      CMP.b       #TK_TAB,d0              ; was it TAB ?
000099B4  6606                    2194      BNE.s       LAB_18B7                ; branch if not (was SPC)
000099B6                          2195  
000099B6                          2196                                  ; calculate TAB offset
000099B6  942B 05E5               2197      SUB.b       TPos(a3),d2             ; subtract terminal position
000099BA  6312                    2198      BLS.s       LAB_18BD                ; branch if result was <= 0
000099BC                          2199                                  ; can't TAB backwards or already there
000099BC                          2200  
000099BC                          2201                                  ; print d2.b spaces
000099BC                          2202  LAB_18B7
000099BC  7000                    2203      MOVEQ       #0,d0                   ; clear longword
000099BE  5300                    2204      SUBQ.b  #1,d0                   ; make d0 = $FF
000099C0  C480                    2205      AND.l       d0,d2                   ; mask for byte only
000099C2  670A                    2206      BEQ.s       LAB_18BD                ; branch if zero
000099C4                          2207  
000099C4  7020                    2208      MOVEQ       #$20,d0             ; load " "
000099C6  5302                    2209      SUBQ.b  #1,d2                   ; adjust for DBF loop
000099C8                          2210  LAB_18B8
000099C8  6128                    2211      BSR.s       LAB_PRNA                ; go print
000099CA  51CA FFFC               2212      DBF     d2,LAB_18B8             ; decrement count and loop if not all done
000099CE                          2213  
000099CE                          2214                                  ; continue with PRINT processing
000099CE                          2215  LAB_18BD
000099CE  6100 03D2               2216      BSR     LAB_IGBY                ; increment & scan memory
000099D2  6600 FF5A               2217      BNE     LAB_1831                ; if byte continue executing PRINT
000099D6                          2218  
000099D6  4E75                    2219      RTS                         ; exit if nothing more to print
000099D8                          2220  
000099D8                          2221  
000099D8                          2222  ;************************************************************************************
000099D8                          2223  ;
000099D8                          2224  ; print null terminated string from a0
000099D8                          2225  
000099D8                          2226  LAB_18C3
000099D8  6100 09E0               2227      BSR     LAB_20AE                ; print terminated string to FAC1/stack
000099DC                          2228  
000099DC                          2229  ; print string from stack
000099DC                          2230  
000099DC                          2231  LAB_18C6
000099DC  6100 0BD0               2232      BSR     LAB_22B6                ; pop string off descriptor stack or from memory
000099E0                          2233                                  ; returns with d0 = length, a0 = pointer
000099E0  670C                    2234      BEQ.s       RTS_009             ; exit (RTS) if null string
000099E2                          2235  
000099E2  3200                    2236      MOVE.w  d0,d1                   ; copy length & set Z flag
000099E4  5341                    2237      SUBQ.w  #1,d1                   ; -1 for BF loop
000099E6                          2238  LAB_18CD
000099E6  1018                    2239      MOVE.b  (a0)+,d0                ; get byte from string
000099E8  6108                    2240      BSR.s       LAB_PRNA                ; go print the character
000099EA  51C9 FFFA               2241      DBF     d1,LAB_18CD             ; decrement count and loop if not done yet
000099EE                          2242  
000099EE                          2243  RTS_009
000099EE  4E75                    2244      RTS
000099F0                          2245  
000099F0                          2246  
000099F0                          2247  ;************************************************************************************
000099F0                          2248  ;
000099F0                          2249  ; print "?" character
000099F0                          2250  
000099F0                          2251  LAB_18E3
000099F0  703F                    2252      MOVEQ       #$3F,d0             ; load "?" character
000099F2                          2253  
000099F2                          2254  
000099F2                          2255  ;************************************************************************************
000099F2                          2256  ;
000099F2                          2257  ; print character in d0, includes the null handler and infinite line length code
000099F2                          2258  ; changes no registers
000099F2                          2259  
000099F2                          2260  LAB_PRNA
000099F2  2F01                    2261      MOVE.l  d1,-(sp)                ; save d1
000099F4  B03C 0020               2262      CMP.b       #$20,d0             ; compare with " "
000099F8  6528                    2263      BCS.s       LAB_18F9                ; branch if less, non printing character
000099FA                          2264  
000099FA                          2265                                  ; don't check fit if terminal width byte is zero
000099FA  122B 05E6               2266      MOVE.b  TWidth(a3),d1           ; get terminal width
000099FE  6610                    2267      BNE.s       LAB_18F0                ; branch if not zero (not infinite length)
00009A00                          2268  
00009A00                          2269                                  ; is "infinite line" so check TAB position
00009A00  122B 05E5               2270      MOVE.b  TPos(a3),d1             ; get position
00009A04  922B 05E2               2271      SUB.b       TabSiz(a3),d1           ; subtract TAB size
00009A08  6614                    2272      BNE.s       LAB_18F7                ; skip reset if different
00009A0A                          2273  
00009A0A  1741 05E5               2274      MOVE.b  d1,TPos(a3)             ; else reset position
00009A0E  600E                    2275      BRA.s       LAB_18F7                ; go print character
00009A10                          2276  
00009A10                          2277  LAB_18F0
00009A10  B22B 05E5               2278      CMP.b       TPos(a3),d1             ; compare with terminal character position
00009A14  6608                    2279      BNE.s       LAB_18F7                ; branch if not at end of line
00009A16                          2280  
00009A16  2F00                    2281      MOVE.l  d0,-(sp)                ; save d0
00009A18  6100 FF60               2282      BSR     LAB_CRLF                ; else print CR/LF
00009A1C  201F                    2283      MOVE.l  (sp)+,d0                ; restore d0
00009A1E                          2284  LAB_18F7
00009A1E  522B 05E5               2285      ADDQ.b  #$01,TPos(a3)           ; increment terminal position
00009A22                          2286  LAB_18F9
00009A22  4EAB 0412               2287      JSR     V_OUTP(a3)              ; output byte via output vector
00009A26  B03C 000D               2288      CMP.b       #$0D,d0             ; compare with [CR]
00009A2A  6618                    2289      BNE.s       LAB_188A                ; branch if not [CR]
00009A2C                          2290  
00009A2C                          2291                                  ; else print nullct nulls after the [CR]
00009A2C  7200                    2292      MOVEQ       #$00,d1             ; clear d1
00009A2E  122B 05E4               2293      MOVE.b  Nullct(a3),d1           ; get null count
00009A32  670C                    2294      BEQ.s       LAB_1886                ; branch if no nulls
00009A34                          2295  
00009A34  7000                    2296      MOVEQ       #$00,d0             ; load [NULL]
00009A36                          2297  LAB_1880
00009A36  4EAB 0412               2298      JSR     V_OUTP(a3)              ; go print the character
00009A3A  51C9 FFFA               2299      DBF     d1,LAB_1880             ; decrement count and loop if not all done
00009A3E                          2300  
00009A3E  700D                    2301      MOVEQ       #$0D,d0             ; restore the character
00009A40                          2302  LAB_1886
00009A40  1741 05E5               2303      MOVE.b  d1,TPos(a3)             ; clear terminal position
00009A44                          2304  LAB_188A
00009A44  221F                    2305      MOVE.l  (sp)+,d1                ; restore d1
00009A46  4E75                    2306      RTS
00009A48                          2307  
00009A48                          2308  
00009A48                          2309  ;************************************************************************************
00009A48                          2310  ;
00009A48                          2311  ; handle bad input data
00009A48                          2312  
00009A48                          2313  LAB_1904
00009A48  2A5F                    2314      MOVEA.l (sp)+,a5                ; restore execute pointer
00009A4A  4A2B 05E0               2315      TST.b       Imode(a3)               ; test input mode flag, $00=INPUT, $98=READ
00009A4E  6A0A                    2316      BPL.s       LAB_1913                ; branch if INPUT (go do redo)
00009A50                          2317  
00009A50  276B 045E 0452          2318      MOVE.l  Dlinel(a3),Clinel(a3)       ; save DATA line as current line
00009A56  6000 F6D6               2319      BRA     LAB_TMER                ; do type mismatch error, then warm start
00009A5A                          2320  
00009A5A                          2321                                  ; mode was INPUT
00009A5A                          2322  LAB_1913
00009A5A  41FA 2A72               2323      LEA     LAB_REDO(pc),a0         ; point to redo message
00009A5E  6100 FF78               2324      BSR     LAB_18C3                ; print null terminated string from memory
00009A62  2A6B 045A               2325      MOVEA.l Cpntrl(a3),a5           ; save continue pointer as BASIC execute pointer
00009A66  4E75                    2326      RTS
00009A68                          2327  
00009A68                          2328  
00009A68                          2329  ;************************************************************************************
00009A68                          2330  ;
00009A68                          2331  ; perform INPUT
00009A68                          2332  
00009A68                          2333  LAB_INPUT
00009A68  6100 0862               2334      BSR     LAB_CKRN                ; check not direct (back here if ok)
00009A6C  B03C 0022               2335      CMP.b       #'"',d0             ; compare the next byte with open quote
00009A70  660E                    2336      BNE.s       LAB_1934                ; if no prompt string just go get the input
00009A72                          2337  
00009A72  6100 0306               2338      BSR     LAB_1BC1                ; print "..." string
00009A76  703B                    2339      MOVEQ       #';',d0             ; set the search character to ";"
00009A78  6100 0320               2340      BSR     LAB_SCCA                ; scan for CHR$(d0), else do syntax error/warm
00009A7C                          2341                                  ; start
00009A7C  6100 FF5E               2342      BSR     LAB_18C6                ; print string from Sutill/Sutilh
00009A80                          2343                                  ; finished the prompt, now read the data
00009A80                          2344  LAB_1934
00009A80  6100 F802               2345      BSR     LAB_INLN                ; print "? " and get BASIC input
00009A84                          2346                                  ; return a0 pointing to the buffer start
00009A84  7000                    2347      MOVEQ       #0,d0                   ; flag INPUT
00009A86  4A10                    2348      TST.b       (a0)                    ; test first byte from buffer
00009A88  660A                    2349      BNE.s       LAB_1953                ; branch if not null input
00009A8A                          2350  
00009A8A  6000 FB56               2351      BRA     LAB_1647                ; go do BREAK exit
00009A8E                          2352  
00009A8E                          2353  
00009A8E                          2354  ;************************************************************************************
00009A8E                          2355  ;
00009A8E                          2356  ; perform READ
00009A8E                          2357  
00009A8E                          2358  LAB_READ
00009A8E  206B 0462               2359      MOVEA.l Dptrl(a3),a0            ; get the DATA pointer
00009A92  7098                    2360      MOVEQ       #$98-$100,d0            ; flag READ
00009A94                          2361  LAB_1953
00009A94  1740 05E0               2362      MOVE.b  d0,Imode(a3)            ; set input mode flag, $00=INPUT, $98=READ
00009A98  2748 0466               2363      MOVE.l  a0,Rdptrl(a3)           ; save READ pointer
00009A9C                          2364  
00009A9C                          2365                                  ; READ or INPUT the next variable from list
00009A9C                          2366  LAB_195B
00009A9C  6100 0512               2367      BSR     LAB_SVAR                ; search for or create a variable
00009AA0                          2368                                  ; return the variable address in a0
00009AA0  2748 0472               2369      MOVE.l  a0,Lvarpl(a3)           ; save variable address as LET variable
00009AA4  2F0D                    2370      MOVE.l  a5,-(sp)                ; save BASIC execute pointer
00009AA6                          2371  LAB_1961
00009AA6  2A6B 0466               2372      MOVEA.l Rdptrl(a3),a5           ; set READ pointer as BASIC execute pointer
00009AAA  6100 02F8               2373      BSR     LAB_GBYT                ; scan memory
00009AAE  661E                    2374      BNE.s       LAB_1986                ; if not null go get the value
00009AB0                          2375  
00009AB0                          2376                                  ; the pointer was to a null entry
00009AB0  4A2B 05E0               2377      TST.b       Imode(a3)               ; test input mode flag, $00=INPUT, $98=READ
00009AB4  6B72                    2378      BMI.s       LAB_19DD                ; branch if READ (go find the next statement)
00009AB6                          2379  
00009AB6                          2380                                  ; else the mode was INPUT so get more
00009AB6  6100 FF38               2381      BSR     LAB_18E3                ; print a "?" character
00009ABA  6100 F7C8               2382      BSR     LAB_INLN                ; print "? " and get BASIC input
00009ABE                          2383                                  ; return a0 pointing to the buffer start
00009ABE  4A10                    2384      TST.b       (a0)                    ; test the first byte from the buffer
00009AC0  6604                    2385      BNE.s       LAB_1984                ; if not null input go handle it
00009AC2                          2386  
00009AC2  6000 FB1E               2387      BRA     LAB_1647                ; else go do the BREAK exit
00009AC6                          2388  
00009AC6                          2389  LAB_1984
00009AC6  2A48                    2390      MOVEA.l a0,a5                   ; set the execute pointer to the buffer
00009AC8  534D                    2391      SUBQ.w  #1,a5                   ; decrement the execute pointer
00009ACA                          2392  
00009ACA                          2393  LAB_1985
00009ACA  6100 02D6               2394      BSR     LAB_IGBY                ; increment & scan memory
00009ACE                          2395  LAB_1986
00009ACE  4A2B 05B5               2396      TST.b       Dtypef(a3)              ; test data type, $80=string, $40=integer,
00009AD2                          2397                                  ; $00=float
00009AD2  6A20                    2398      BPL.s       LAB_19B0                ; branch if numeric
00009AD4                          2399  
00009AD4                          2400                                  ; else get string
00009AD4  1400                    2401      MOVE.b  d0,d2                   ; save search character
00009AD6  B03C 0022               2402      CMP.b       #$22,d0             ; was it " ?
00009ADA  6706                    2403      BEQ.s       LAB_1999                ; branch if so
00009ADC                          2404  
00009ADC  743A                    2405      MOVEQ       #':',d2             ; set new search character
00009ADE  702C                    2406      MOVEQ       #',',d0             ; other search character is ","
00009AE0  534D                    2407      SUBQ.w  #1,a5                   ; decrement BASIC execute pointer
00009AE2                          2408  LAB_1999
00009AE2  524D                    2409      ADDQ.w  #1,a5                   ; increment BASIC execute pointer
00009AE4  1600                    2410      MOVE.b  d0,d3                   ; set second search character
00009AE6  204D                    2411      MOVEA.l a5,a0                   ; BASIC execute pointer is source
00009AE8                          2412  
00009AE8  6100 08D4               2413      BSR     LAB_20B4                ; print d2/d3 terminated string to FAC1 stack
00009AEC                          2414                                  ; d2 = Srchc, d3 = Asrch, a0 is source
00009AEC  2A4A                    2415      MOVEA.l a2,a5                   ; copy end of string to BASIC execute pointer
00009AEE  6100 FDD0               2416      BSR     LAB_17D5                ; go do string LET
00009AF2  6010                    2417      BRA.s       LAB_19B6                ; go check string terminator
00009AF4                          2418  
00009AF4                          2419                                  ; get numeric INPUT
00009AF4                          2420  LAB_19B0
00009AF4  1F2B 05B5               2421      MOVE.b  Dtypef(a3),-(sp)            ; save variable data type
00009AF8  6100 1DA2               2422      BSR     LAB_2887                ; get FAC1 from string
00009AFC  175F 05B5               2423      MOVE.b  (sp)+,Dtypef(a3)            ; restore variable data type
00009B00  6100 1084               2424      BSR     LAB_PFAC                ; pack FAC1 into (Lvarpl)
00009B04                          2425  LAB_19B6
00009B04  6100 029E               2426      BSR     LAB_GBYT                ; scan memory
00009B08  670A                    2427      BEQ.s       LAB_19C2                ; branch if null (last entry)
00009B0A                          2428  
00009B0A  B03C 002C               2429      CMP.b       #',',d0             ; else compare with ","
00009B0E  6600 FF38               2430      BNE     LAB_1904                ; if not "," go handle bad input data
00009B12                          2431  
00009B12  524D                    2432      ADDQ.w  #1,a5                   ; else was "," so point to next chr
00009B14                          2433                                  ; got good input data
00009B14                          2434  LAB_19C2
00009B14  274D 0466               2435      MOVE.l  a5,Rdptrl(a3)           ; save the read pointer for now
00009B18  2A5F                    2436      MOVEA.l (sp)+,a5                ; restore the execute pointer
00009B1A  6100 0288               2437      BSR     LAB_GBYT                ; scan the memory
00009B1E  6736                    2438      BEQ.s       LAB_1A03                ; if null go do extra ignored message
00009B20                          2439  
00009B20  487A FF7A               2440      PEA     LAB_195B(pc)            ; set return address
00009B24  6000 0272               2441      BRA     LAB_1C01                ; scan for "," else do syntax error/warm start
00009B28                          2442                                  ; then go INPUT next variable from list
00009B28                          2443  
00009B28                          2444                                  ; find next DATA statement or do "Out of Data"
00009B28                          2445                                  ; error
00009B28                          2446  LAB_19DD
00009B28  6100 FBFC               2447      BSR     LAB_SNBS                ; scan for next BASIC statement ([:] or [EOL])
00009B2C                          2448                                  ; returns a0 as pointer to [:] or [EOL]
00009B2C  2A48                    2449      MOVEA.l a0,a5                   ; add index, now = pointer to [EOL]/[EOS]
00009B2E  524D                    2450      ADDQ.w  #1,a5                   ; pointer to next character
00009B30  B03C 003A               2451      CMP.b       #':',d0             ; was it statement end?
00009B34  6712                    2452      BEQ.s       LAB_19F6                ; branch if [:]
00009B36                          2453  
00009B36                          2454                                  ; was [EOL] so find next line
00009B36                          2455  
00009B36  320D                    2456      MOVE.w  a5,d1                   ; past pad byte(s)
00009B38  C27C 0001               2457      AND.w       #1,d1                   ; mask odd bit
00009B3C  DAC1                    2458      ADD.w       d1,a5                   ; add pointer
00009B3E  241D                    2459      MOVE.l  (a5)+,d2                ; get next line pointer
00009B40  6700 F610               2460      BEQ     LAB_ODER                ; branch if end of program
00009B44                          2461  
00009B44  275D 045E               2462      MOVE.l  (a5)+,Dlinel(a3)            ; save current DATA line
00009B48                          2463  LAB_19F6
00009B48  6100 025A               2464      BSR     LAB_GBYT                ; scan memory
00009B4C  B03C 0083               2465      CMP.b       #TK_DATA,d0             ; compare with "DATA" token
00009B50  6700 FF78               2466      BEQ     LAB_1985                ; was "DATA" so go do next READ
00009B54                          2467  
00009B54  60D2                    2468      BRA.s       LAB_19DD                ; go find next statement if not "DATA"
00009B56                          2469  
00009B56                          2470  ; end of INPUT/READ routine
00009B56                          2471  
00009B56                          2472  LAB_1A03
00009B56  206B 0466               2473      MOVEA.l Rdptrl(a3),a0           ; get temp READ pointer
00009B5A  4A2B 05E0               2474      TST.b       Imode(a3)               ; get input mode flag, $00=INPUT, $98=READ
00009B5E  6A06                    2475      BPL.s       LAB_1A0E                ; branch if INPUT
00009B60                          2476  
00009B60  2748 0462               2477      MOVE.l  a0,Dptrl(a3)            ; else save temp READ pointer as DATA pointer
00009B64  4E75                    2478      RTS
00009B66                          2479  
00009B66                          2480                                  ; we were getting INPUT
00009B66                          2481  LAB_1A0E
00009B66  4A10                    2482      TST.b       (a0)                    ; test next byte
00009B68  6602                    2483      BNE.s       LAB_1A1B                ; error if not end of INPUT
00009B6A                          2484  
00009B6A  4E75                    2485      RTS
00009B6C                          2486                                  ; user typed too much
00009B6C                          2487  LAB_1A1B
00009B6C  41FA 2950               2488      LEA     LAB_IMSG(pc),a0         ; point to extra ignored message
00009B70  6000 FE66               2489      BRA     LAB_18C3                ; print null terminated string from memory & RTS
00009B74                          2490  
00009B74                          2491  
00009B74                          2492  ;************************************************************************************
00009B74                          2493  ;
00009B74                          2494  ; perform NEXT
00009B74                          2495  
00009B74                          2496  LAB_NEXT
00009B74  6610                    2497      BNE.s       LAB_1A46                ; branch if NEXT var
00009B76                          2498  
00009B76  584F                    2499      ADDQ.w  #4,sp                   ; back past return address
00009B78  0C57 0081               2500      CMP.w       #TK_FOR,(sp)            ; is FOR token on stack?
00009B7C  6600 F5E0               2501      BNE     LAB_NFER                ; if not do NEXT without FOR err/warm start
00009B80                          2502  
00009B80  206F 0002               2503      MOVEA.l 2(sp),a0                ; get stacked FOR variable pointer
00009B84  601C                    2504      BRA.s       LAB_11BD                ; branch always (no variable to search for)
00009B86                          2505  
00009B86                          2506  ; NEXT var
00009B86                          2507  
00009B86                          2508  LAB_1A46
00009B86  6100 042C               2509      BSR     LAB_GVAR                ; get variable address in a0
00009B8A  584F                    2510      ADDQ.w  #4,sp                   ; back past return address
00009B8C  303C 0081               2511      MOVE.w  #TK_FOR,d0              ; set for FOR token
00009B90  721C                    2512      MOVEQ       #$1C,d1             ; set for FOR use size
00009B92  6002                    2513      BRA.s       LAB_11A6                ; enter loop for next variable search
00009B94                          2514  
00009B94                          2515  LAB_11A5
00009B94  DFC1                    2516      ADDA.l  d1,sp                   ; add FOR stack use size
00009B96                          2517  LAB_11A6
00009B96  B057                    2518      CMP.w       (sp),d0             ; is FOR token on stack?
00009B98  6600 F5C4               2519      BNE     LAB_NFER                ; if not found do NEXT without FOR error and
00009B9C                          2520                                  ; warm start
00009B9C                          2521  
00009B9C                          2522                                  ; was FOR token
00009B9C  B1EF 0002               2523      CMPA.l  2(sp),a0                ; compare var pointer with stacked var pointer
00009BA0  66F2                    2524      BNE.s       LAB_11A5                ; loop if no match found
00009BA2                          2525  
00009BA2                          2526  LAB_11BD
00009BA2  376F 0006 059C          2527      MOVE.w  6(sp),FAC2_e(a3)            ; get STEP value exponent and sign
00009BA8  276F 0008 0598          2528      MOVE.l  8(sp),FAC2_m(a3)            ; get STEP value mantissa
00009BAE                          2529  
00009BAE  176F 0012 05B5          2530      MOVE.b  18(sp),Dtypef(a3)           ; restore FOR variable data type
00009BB4  6100 021E               2531      BSR     LAB_1C19                ; check type and unpack (a0)
00009BB8                          2532  
00009BB8  176B 059D 059E          2533      MOVE.b  FAC2_s(a3),FAC_sc(a3)       ; save FAC2 sign as sign compare
00009BBE  102B 0595               2534      MOVE.b  FAC1_s(a3),d0           ; get FAC1 sign
00009BC2  B12B 059E               2535      EOR.b       d0,FAC_sc(a3)           ; EOR to create sign compare
00009BC6                          2536  
00009BC6  2748 0472               2537      MOVE.l  a0,Lvarpl(a3)           ; save variable pointer
00009BCA  6100 0CBA               2538      BSR     LAB_ADD             ; add STEP value to FOR variable
00009BCE  176F 0012 05B5          2539      MOVE.b  18(sp),Dtypef(a3)           ; restore FOR variable data type (again)
00009BD4  6100 0FB0               2540      BSR     LAB_PFAC                ; pack FAC1 into FOR variable (Lvarpl)
00009BD8                          2541  
00009BD8  376F 000C 059C          2542      MOVE.w  12(sp),FAC2_e(a3)           ; get TO value exponent and sign
00009BDE  276F 000E 0598          2543      MOVE.l  14(sp),FAC2_m(a3)           ; get TO value mantissa
00009BE4                          2544  
00009BE4  176B 059D 059E          2545      MOVE.b  FAC2_s(a3),FAC_sc(a3)       ; save FAC2 sign as sign compare
00009BEA  102B 0595               2546      MOVE.b  FAC1_s(a3),d0           ; get FAC1 sign
00009BEE  B12B 059E               2547      EOR.b       d0,FAC_sc(a3)           ; EOR to create sign compare
00009BF2                          2548  
00009BF2  6100 103C               2549      BSR     LAB_27FA                ; compare FAC1 with FAC2 (TO value)
00009BF6                          2550                                  ; returns d0=+1 if FAC1 > FAC2
00009BF6                          2551                                  ; returns d0= 0 if FAC1 = FAC2
00009BF6                          2552                                  ; returns d0=-1 if FAC1 < FAC2
00009BF6                          2553  
00009BF6  322F 0006               2554      MOVE.w  6(sp),d1                ; get STEP value exponent and sign
00009BFA  B141                    2555      EOR.w       d0,d1                   ; EOR compare result with STEP exponent and sign
00009BFC                          2556  
00009BFC  4A00                    2557      TST.b       d0                  ; test for =
00009BFE  6704                    2558      BEQ.s       LAB_1A90                ; branch if = (loop INcomplete)
00009C00                          2559  
00009C00  4A01                    2560      TST.b       d1                  ; test result
00009C02  6A0E                    2561      BPL.s       LAB_1A9B                ; branch if > (loop complete)
00009C04                          2562  
00009C04                          2563                                  ; loop back and do it all again
00009C04                          2564  LAB_1A90
00009C04  276F 0014 0452          2565      MOVE.l  20(sp),Clinel(a3)           ; reset current line
00009C0A  2A6F 0018               2566      MOVE.l  24(sp),a5               ; reset BASIC execute pointer
00009C0E  6000 F96E               2567      BRA     LAB_15C2                ; go do interpreter inner loop
00009C12                          2568  
00009C12                          2569                                  ; loop complete so carry on
00009C12                          2570  LAB_1A9B
00009C12  DEFC 001C               2571      ADDA.w  #28,sp              ; add 28 to dump FOR structure
00009C16  6100 018C               2572      BSR     LAB_GBYT                ; scan memory
00009C1A  B03C 002C               2573      CMP.b       #$2C,d0             ; compare with ","
00009C1E  6600 F95E               2574      BNE     LAB_15C2                ; if not "," go do interpreter inner loop
00009C22                          2575  
00009C22                          2576                                  ; was "," so another NEXT variable to do
00009C22  6100 017E               2577      BSR     LAB_IGBY                ; else increment & scan memory
00009C26  6100 FF5E               2578      BSR     LAB_1A46                ; do NEXT (var)
00009C2A                          2579  
00009C2A                          2580  
00009C2A                          2581  ;************************************************************************************
00009C2A                          2582  ;
00009C2A                          2583  ; evaluate expression & check is numeric, else do type mismatch
00009C2A                          2584  
00009C2A                          2585  LAB_EVNM
00009C2A  6116                    2586      BSR.s       LAB_EVEX                ; evaluate expression
00009C2C                          2587  
00009C2C                          2588  
00009C2C                          2589  ;************************************************************************************
00009C2C                          2590  ;
00009C2C                          2591  ; check if source is numeric, else do type mismatch
00009C2C                          2592  
00009C2C                          2593  LAB_CTNM
00009C2C  B040                    2594      CMP.w       d0,d0                   ; required type is numeric so clear carry
00009C2E                          2595  
00009C2E                          2596  
00009C2E                          2597  ;************************************************************************************
00009C2E                          2598  ;
00009C2E                          2599  ; type match check, set C for string, clear C for numeric
00009C2E                          2600  
00009C2E                          2601  LAB_CKTM
00009C2E  082B 0007 05B5          2602      BTST.b  #7,Dtypef(a3)           ; test data type flag, don't change carry
00009C34  6606                    2603      BNE.s       LAB_1ABA                ; branch if data type is string
00009C36                          2604  
00009C36                          2605                                  ; else data type was numeric
00009C36  6500 F4F6               2606      BCS     LAB_TMER                ; if required type is string do type mismatch
00009C3A                          2607                                  ; error
00009C3A                          2608  
00009C3A  4E75                    2609      RTS
00009C3C                          2610                                  ; data type was string, now check required type
00009C3C                          2611  LAB_1ABA
00009C3C  6400 F4F0               2612      BCC     LAB_TMER                ; if required type is numeric do type mismatch
00009C40                          2613                                  ; error
00009C40  4E75                    2614      RTS
00009C42                          2615  
00009C42                          2616  
00009C42                          2617  ;************************************************************************************
00009C42                          2618  ;
00009C42                          2619  ; this routine evaluates any type of expression. first it pushes an end marker so
00009C42                          2620  ; it knows when the expression has been evaluated, this is a precedence value of zero.
00009C42                          2621  ; next the first value is evaluated, this can be an in line value, either numeric or
00009C42                          2622  ; string, a variable or array element of any type, a function or even an expression
00009C42                          2623  ; in parenthesis. this value is kept in FAC_1
00009C42                          2624  ; after the value is evaluated a test is made on the next BASIC program byte, if it
00009C42                          2625  ; is a comparrison operator i.e. "<", "=" or ">", then the corresponding bit is set
00009C42                          2626  ; in the comparison evaluation flag. this test loops until no more comparrison operators
00009C42                          2627  ; are found or more than one of any type is found. in the last case an error is generated
00009C42                          2628  
00009C42                          2629  ; evaluate expression
00009C42                          2630  
00009C42                          2631  LAB_EVEX
00009C42  534D                    2632      SUBQ.w  #1,a5                   ; decrement BASIC execute pointer
00009C44                          2633  LAB_EVEZ
00009C44  7200                    2634      MOVEQ       #0,d1                   ; clear precedence word
00009C46  1741 05B5               2635      MOVE.b  d1,Dtypef(a3)           ; clear the data type, $80=string, $40=integer,
00009C4A                          2636                                  ; $00=float
00009C4A  601C                    2637      BRA.s       LAB_1ACD                ; enter loop
00009C4C                          2638  
00009C4C                          2639  ; get vector, set up operator then continue evaluation
00009C4C                          2640  
00009C4C                          2641  LAB_1B43
00009C4C  41FA 22C6               2642      LEA     LAB_OPPT(pc),a0         ; point to operator vector table
00009C50  3030 1002               2643      MOVE.w  2(a0,d1.w),d0           ; get vector offset
00009C54  4870 0000               2644      PEA     (a0,d0.w)               ; push vector
00009C58                          2645  
00009C58  2F2B 0590               2646      MOVE.l  FAC1_m(a3),-(sp)            ; push FAC1 mantissa
00009C5C  3F2B 0594               2647      MOVE.w  FAC1_e(a3),-(sp)            ; push sign and exponent
00009C60  1F2B 05E3               2648      MOVE.b  comp_f(a3),-(sp)            ; push comparison evaluation flag
00009C64                          2649  
00009C64  3230 1000               2650      MOVE.w  (a0,d1.w),d1            ; get precedence value
00009C68                          2651  LAB_1ACD
00009C68  3F01                    2652      MOVE.w  d1,-(sp)                ; push precedence value
00009C6A  6100 00E4               2653      BSR     LAB_GVAL                ; get value from line
00009C6E  177C 0000 05E3          2654      MOVE.b  #$00,comp_f(a3)         ; clear compare function flag
00009C74                          2655  LAB_1ADB
00009C74  6100 012E               2656      BSR     LAB_GBYT                ; scan memory
00009C78                          2657  LAB_1ADE
00009C78  0400 00BC               2658      SUB.b       #TK_GT,d0               ; subtract token for > (lowest compare function)
00009C7C  652A                    2659      BCS.s       LAB_1AFA                ; branch if < TK_GT
00009C7E                          2660  
00009C7E  B03C 0003               2661      CMP.b       #$03,d0             ; compare with ">" to "<" tokens
00009C82  650A                    2662      BCS.s       LAB_1AE0                ; branch if <= TK_SGN (is compare function)
00009C84                          2663  
00009C84  4A2B 05E3               2664      TST.b       comp_f(a3)              ; test compare function flag
00009C88  6660                    2665      BNE.s       LAB_1B2A                ; branch if compare function
00009C8A                          2666  
00009C8A  6000 0086               2667      BRA     LAB_1B78                ; go do functions
00009C8E                          2668  
00009C8E                          2669                                  ; was token for > = or < (d0 = 0, 1 or 2)
00009C8E                          2670  LAB_1AE0
00009C8E  7201                    2671      MOVEQ       #1,d1                   ; set to 0000 0001
00009C90  E121                    2672      ASL.b       d0,d1                   ; 1 if >, 2 if =, 4 if <
00009C92  102B 05E3               2673      MOVE.b  comp_f(a3),d0           ; copy old compare function flag
00009C96  B32B 05E3               2674      EOR.b       d1,comp_f(a3)           ; EOR in this compare function bit
00009C9A  B02B 05E3               2675      CMP.b       comp_f(a3),d0           ; compare old with new compare function flag
00009C9E  6400 F4BA               2676      BCC     LAB_SNER                ; if new <= old comp_f do syntax error and warm
00009CA2                          2677                                  ; start, there was more than one <, = or >
00009CA2  6100 00FE               2678      BSR     LAB_IGBY                ; increment & scan memory
00009CA6  60D0                    2679      BRA.s       LAB_1ADE                ; go do next character
00009CA8                          2680  
00009CA8                          2681                                  ; token is < ">" or > "<" tokens
00009CA8                          2682  LAB_1AFA
00009CA8  4A2B 05E3               2683      TST.b       comp_f(a3)              ; test compare function flag
00009CAC  663C                    2684      BNE.s       LAB_1B2A                ; branch if compare function
00009CAE                          2685  
00009CAE                          2686                                  ; was < TK_GT so is operator or lower
00009CAE  0600 000A               2687      ADD.b   #(TK_GT-TK_PLUS),d0         ; add # of operators (+ -   ; / ^ AND OR EOR)
00009CB2  645E                    2688      BCC.s       LAB_1B78                ; branch if < + operator
00009CB4                          2689  
00009CB4  6608                    2690      BNE.s       LAB_1B0B                ; branch if not + token
00009CB6                          2691  
00009CB6  4A2B 05B5               2692      TST.b       Dtypef(a3)              ; test data type, $80=string, $40=integer,
00009CBA                          2693                                  ; $00=float
00009CBA  6B00 087E               2694      BMI     LAB_224D                ; type is string & token was +
00009CBE                          2695  
00009CBE                          2696  LAB_1B0B
00009CBE  7200                    2697      MOVEQ       #0,d1                   ; clear longword
00009CC0  D000                    2698      ADD.b       d0,d0                   ; *2
00009CC2  D000                    2699      ADD.b       d0,d0                   ; *4
00009CC4  1200                    2700      MOVE.b  d0,d1                   ; copy to index
00009CC6                          2701  LAB_1B13
00009CC6  301F                    2702      MOVE.w  (sp)+,d0                ; pull previous precedence
00009CC8  41FA 224A               2703      LEA     LAB_OPPT(pc),a0         ; set pointer to operator table
00009CCC  B070 1000               2704      CMP.w       (a0,d1.w),d0            ; compare with this opperator precedence
00009CD0  6446                    2705      BCC.s       LAB_1B7D                ; branch if previous precedence (d0) >=
00009CD2                          2706  
00009CD2  6100 FF58               2707      BSR     LAB_CTNM                ; check if source is numeric, else type mismatch
00009CD6                          2708  LAB_1B1C
00009CD6  3F00                    2709      MOVE.w  d0,-(sp)                ; save precedence
00009CD8                          2710  LAB_1B1D
00009CD8  6100 FF72               2711      BSR     LAB_1B43                ; get vector, set-up operator and continue
00009CDC                          2712                                  ; evaluation
00009CDC  301F                    2713      MOVE.w  (sp)+,d0                ; restore precedence
00009CDE  222B 05D8               2714      MOVE.l  prstk(a3),d1            ; get stacked function pointer
00009CE2  6A22                    2715      BPL.s       LAB_1B3C                ; branch if stacked values
00009CE4                          2716  
00009CE4  3000                    2717      MOVE.w  d0,d0                   ; copy precedence (set flags)
00009CE6  672E                    2718      BEQ.s       LAB_1B7B                ; exit if done
00009CE8                          2719  
00009CE8  603C                    2720      BRA.s       LAB_1B86                ; else pop FAC2 & return (do function)
00009CEA                          2721  
00009CEA                          2722                                  ; was compare function (< = >)
00009CEA                          2723  LAB_1B2A
00009CEA  102B 05B5               2724      MOVE.b  Dtypef(a3),d0           ; get data type flag
00009CEE  122B 05E3               2725      MOVE.b  comp_f(a3),d1           ; get compare function flag
00009CF2  D000                    2726      ADD.b       d0,d0                   ; string bit flag into X bit
00009CF4  D301                    2727      ADDX.b  d1,d1                   ; shift compare function flag
00009CF6                          2728  
00009CF6  177C 0000 05B5          2729      MOVE.b  #0,Dtypef(a3)           ; clear data type flag, $00=float
00009CFC  1741 05E3               2730      MOVE.b  d1,comp_f(a3)           ; save new compare function flag
00009D00  534D                    2731      SUBQ.w  #1,a5                   ; decrement BASIC execute pointer
00009D02  7230                    2732      MOVEQ       #(TK_LT-TK_PLUS)*4,d1       ; set offset to last operator entry
00009D04  60C0                    2733      BRA.s       LAB_1B13                ; branch always
00009D06                          2734  
00009D06                          2735  LAB_1B3C
00009D06  41FA 220C               2736      LEA     LAB_OPPT(pc),a0         ; point to function vector table
00009D0A  B070 1000               2737      CMP.w       (a0,d1.w),d0            ; compare with this opperator precedence
00009D0E  6416                    2738      BCC.s       LAB_1B86                ; branch if d0 >=, pop FAC2 & return
00009D10                          2739  
00009D10  60C4                    2740      BRA.s       LAB_1B1C                ; branch always
00009D12                          2741  
00009D12                          2742  ; do functions
00009D12                          2743  
00009D12                          2744  LAB_1B78
00009D12  72FF                    2745      MOVEQ       #-1,d1              ; flag all done
00009D14  301F                    2746      MOVE.w  (sp)+,d0                ; pull precedence word
00009D16                          2747  LAB_1B7B
00009D16  6732                    2748      BEQ.s       LAB_1B9D                ; exit if done
00009D18                          2749  
00009D18                          2750  LAB_1B7D
00009D18  B07C 0064               2751      CMP.w       #$64,d0             ; compare previous precedence with $64
00009D1C  6704                    2752      BEQ.s       LAB_1B84                ; branch if was $64 (< function can be string)
00009D1E                          2753  
00009D1E  6100 FF0C               2754      BSR     LAB_CTNM                ; check if source is numeric, else type mismatch
00009D22                          2755  LAB_1B84
00009D22  2741 05D8               2756      MOVE.l  d1,prstk(a3)            ; save current operator index
00009D26                          2757  
00009D26                          2758                                  ; pop FAC2 & return
00009D26                          2759  LAB_1B86
00009D26  101F                    2760      MOVE.b  (sp)+,d0                ; pop comparison evaluation flag
00009D28  1200                    2761      MOVE.b  d0,d1                   ; copy comparison evaluation flag
00009D2A  E208                    2762      LSR.b       #1,d0                   ; shift out comparison evaluation lowest bit
00009D2C  1740 05E1               2763      MOVE.b  d0,Cflag(a3)            ; save comparison evaluation flag
00009D30  375F 059C               2764      MOVE.w  (sp)+,FAC2_e(a3)            ; pop exponent and sign
00009D34  275F 0598               2765      MOVE.l  (sp)+,FAC2_m(a3)            ; pop mantissa
00009D38  176B 059D 059E          2766      MOVE.b  FAC2_s(a3),FAC_sc(a3)       ; copy FAC2 sign
00009D3E  102B 0595               2767      MOVE.b  FAC1_s(a3),d0           ; get FAC1 sign
00009D42  B12B 059E               2768      EOR.b       d0,FAC_sc(a3)           ; EOR FAC1 sign and set sign compare
00009D46                          2769  
00009D46  E209                    2770      LSR.b       #1,d1                   ; type bit into X and C
00009D48  4E75                    2771      RTS
00009D4A                          2772  
00009D4A                          2773  LAB_1B9D
00009D4A  102B 0594               2774      MOVE.b  FAC1_e(a3),d0           ; get FAC1 exponent
00009D4E  4E75                    2775      RTS
00009D50                          2776  
00009D50                          2777  
00009D50                          2778  ;************************************************************************************
00009D50                          2779  ;
00009D50                          2780  ; get a value from the BASIC line
00009D50                          2781  
00009D50                          2782  LAB_GVAL
00009D50  6150                    2783      BSR.s       LAB_IGBY                ; increment & scan memory
00009D52  6500 1B48               2784      BCS     LAB_2887                ; if numeric get FAC1 from string & return
00009D56                          2785  
00009D56  4A00                    2786      TST.b       d0                  ; test byte
00009D58  6B00 0090               2787      BMI     LAB_1BD0                ; if -ve go test token values
00009D5C                          2788  
00009D5C                          2789                                  ; else it is either a string, number, variable
00009D5C                          2790                                  ; or (<expr>)
00009D5C  B03C 0024               2791      CMP.b       #'$',d0             ; compare with "$"
00009D60  6700 1B3A               2792      BEQ     LAB_2887                ; if "$" get hex number from string & return
00009D64                          2793  
00009D64  B03C 0025               2794      CMP.b       #'%',d0             ; else compare with "%"
00009D68  6700 1B32               2795      BEQ     LAB_2887                ; if "%" get binary number from string & return
00009D6C                          2796  
00009D6C  B03C 002E               2797      CMP.b       #$2E,d0             ; compare with "."
00009D70  6700 1B2A               2798      BEQ     LAB_2887                ; if so get FAC1 from string and return
00009D74                          2799                                  ; (e.g. .123)
00009D74                          2800  
00009D74                          2801                                  ; wasn't a number so ...
00009D74  B03C 0022               2802      CMP.b       #$22,d0             ; compare with "
00009D78  660C                    2803      BNE.s       LAB_1BF3                ; if not open quote it must be a variable or
00009D7A                          2804                                  ; open bracket
00009D7A                          2805  
00009D7A                          2806                                  ; was open quote so get the enclosed string
00009D7A                          2807  
00009D7A                          2808  ; print "..." string to string stack
00009D7A                          2809  
00009D7A                          2810  LAB_1BC1
00009D7A  101D                    2811      MOVE.b  (a5)+,d0                ; increment BASIC execute pointer (past ")
00009D7C                          2812                                  ; fastest/shortest method
00009D7C  204D                    2813      MOVEA.l a5,a0                   ; copy basic execute pointer (string start)
00009D7E  6100 063A               2814      BSR     LAB_20AE                ; print " terminated string to stack
00009D82  2A4A                    2815      MOVEA.l a2,a5                   ; restore BASIC execute pointer from temp
00009D84  4E75                    2816      RTS
00009D86                          2817  
00009D86                          2818  ; get value from line .. continued
00009D86                          2819                                  ; wasn't any sort of number so ...
00009D86                          2820  LAB_1BF3
00009D86  B03C 0028               2821      CMP.b       #'(',d0             ; compare with "("
00009D8A  6644                    2822      BNE.s       LAB_1C18                ; if not "(" get (var) and return value in FAC1
00009D8C                          2823                                  ; and $ flag
00009D8C                          2824  
00009D8C                          2825  
00009D8C                          2826  ;************************************************************************************
00009D8C                          2827  ;
00009D8C                          2828  ; evaluate expression within parentheses
00009D8C                          2829  
00009D8C                          2830  LAB_1BF7
00009D8C  6100 FEB6               2831      BSR     LAB_EVEZ                ; evaluate expression (no decrement)
00009D90                          2832  
00009D90                          2833  
00009D90                          2834  ;************************************************************************************
00009D90                          2835  ;
00009D90                          2836  ; all the 'scan for' routines return the character after the sought character
00009D90                          2837  
00009D90                          2838  ; scan for ")", else do syntax error, then warm start
00009D90                          2839  
00009D90                          2840  LAB_1BFB
00009D90  7029                    2841      MOVEQ       #$29,d0             ; load d0 with ")"
00009D92  6006                    2842      BRA.s       LAB_SCCA
00009D94                          2843  
00009D94                          2844  
00009D94                          2845  ;************************************************************************************
00009D94                          2846  ;
00009D94                          2847  ; scan for "," and get byte, else do Syntax error then warm start
00009D94                          2848  
00009D94                          2849  LAB_SCGB
00009D94  487A 0978               2850      PEA     LAB_GTBY(pc)            ; return address is to get byte parameter
00009D98                          2851  
00009D98                          2852  
00009D98                          2853  ;************************************************************************************
00009D98                          2854  ;
00009D98                          2855  ; scan for ",", else do syntax error, then warm start
00009D98                          2856  
00009D98                          2857  LAB_1C01
00009D98  702C                    2858      MOVEQ       #$2C,d0             ; load d0 with ","
00009D9A                          2859  
00009D9A                          2860  
00009D9A                          2861  ;************************************************************************************
00009D9A                          2862  ;
00009D9A                          2863  ; scan for CHR$(d0) , else do syntax error, then warm start
00009D9A                          2864  
00009D9A                          2865  LAB_SCCA
00009D9A  B01D                    2866      CMP.b       (a5)+,d0                ; check next byte is = d0
00009D9C  6706                    2867      BEQ.s       LAB_GBYT                ; if so go get next
00009D9E                          2868  
00009D9E  6000 F3BA               2869      BRA     LAB_SNER                ; else do syntax error/warm start
00009DA2                          2870  
00009DA2                          2871  
00009DA2                          2872  ;************************************************************************************
00009DA2                          2873  ;
00009DA2                          2874  ; BASIC increment and scan memory routine
00009DA2                          2875  
00009DA2                          2876  LAB_IGBY
00009DA2  101D                    2877      MOVE.b  (a5)+,d0                ; get byte & increment pointer
00009DA4                          2878  
00009DA4                          2879  ; scan memory routine, exit with Cb = 1 if numeric character
00009DA4                          2880  ; also skips any spaces encountered
00009DA4                          2881  
00009DA4                          2882  LAB_GBYT
00009DA4  1015                    2883      MOVE.b  (a5),d0             ; get byte
00009DA6                          2884  
00009DA6  B03C 0020               2885      CMP.b       #$20,d0             ; compare with " "
00009DAA  67F6                    2886      BEQ.s       LAB_IGBY                ; if " " go do next
00009DAC                          2887  
00009DAC                          2888  ; test current BASIC byte, exit with Cb = 1 if numeric character
00009DAC                          2889  
00009DAC  B03C 00A9               2890      CMP.b       #TK_ELSE,d0             ; compare with the token for ELSE
00009DB0  640E                    2891      BCC.s       RTS_001             ; exit if >= (not numeric, carry clear)
00009DB2                          2892  
00009DB2  B03C 003A               2893      CMP.b       #$3A,d0             ; compare with ":"
00009DB6  6408                    2894      BCC.s       RTS_001             ; exit if >= (not numeric, carry clear)
00009DB8                          2895  
00009DB8  1C3C 00D0               2896      MOVE.b      #$D0,d6             ; set -"0"
00009DBC  D006                    2897      ADD.b       d6,d0                   ; add -"0"
00009DBE  9006                    2898      SUB.b       d6,d0                   ; subtract -"0"
00009DC0                          2899  RTS_001                         ; carry set if byte = "0"-"9"
00009DC0  4E75                    2900      RTS
00009DC2                          2901  
00009DC2                          2902  
00009DC2                          2903  ;************************************************************************************
00009DC2                          2904  ;
00009DC2                          2905  ; set-up for - operator
00009DC2                          2906  
00009DC2                          2907  LAB_1C11
00009DC2  6100 FE68               2908      BSR     LAB_CTNM                ; check if source is numeric, else type mismatch
00009DC6  7228                    2909      MOVEQ   #(TK_GT-TK_PLUS)*4,d1           ; set offset from base to - operator
00009DC8                          2910  LAB_1C13
00009DC8  4FEF 0004               2911      LEA     4(sp),sp                ; dump GVAL return address
00009DCC  6000 FF0A               2912      BRA     LAB_1B1D                ; continue evaluating expression
00009DD0                          2913  
00009DD0                          2914  
00009DD0                          2915  ;************************************************************************************
00009DD0                          2916  ;
00009DD0                          2917  ; variable name set-up
00009DD0                          2918  ; get (var), return value in FAC_1 & data type flag
00009DD0                          2919  
00009DD0                          2920  LAB_1C18
00009DD0  6100 01E2               2921      BSR     LAB_GVAR                ; get variable address in a0
00009DD4                          2922  
00009DD4                          2923  ; return existing variable value
00009DD4                          2924  
00009DD4                          2925  LAB_1C19
00009DD4  4A2B 05B5               2926      TST.b       Dtypef(a3)              ; test data type, $80=string, $40=integer,
00009DD8                          2927                                  ; $00=float
00009DD8  6700 0D90               2928      BEQ     LAB_UFAC                ; if float unpack memory (a0) into FAC1 and
00009DDC                          2929                                  ; return
00009DDC                          2930  
00009DDC  6A06                    2931      BPL.s       LAB_1C1A                ; if integer unpack memory (a0) into FAC1
00009DDE                          2932                                  ; and return
00009DDE                          2933  
00009DDE  2748 0590               2934      MOVE.l  a0,FAC1_m(a3)           ; else save descriptor pointer in FAC1
00009DE2  4E75                    2935      RTS
00009DE4                          2936  
00009DE4                          2937  LAB_1C1A
00009DE4  2010                    2938      MOVE.l  (a0),d0             ; get integer value
00009DE6  6000 04BC               2939      BRA     LAB_AYFC                ; convert d0 to signed longword in FAC1 & return
00009DEA                          2940  
00009DEA                          2941  
00009DEA                          2942  ;************************************************************************************
00009DEA                          2943  ;
00009DEA                          2944  ; get value from line .. continued
00009DEA                          2945  ; do tokens
00009DEA                          2946  
00009DEA                          2947  LAB_1BD0
00009DEA  B03C 00B3               2948      CMP.b       #TK_MINUS,d0            ; compare with token for -
00009DEE  67D2                    2949      BEQ.s       LAB_1C11                ; branch if - token (do set-up for - operator)
00009DF0                          2950  
00009DF0                          2951                                  ; wasn't -123 so ...
00009DF0  B03C 00B2               2952      CMP.b       #TK_PLUS,d0             ; compare with token for +
00009DF4  6700 FF5A               2953      BEQ     LAB_GVAL                ; branch if + token (+n = n so ignore leading +)
00009DF8                          2954  
00009DF8  B03C 00AE               2955      CMP.b       #TK_NOT,d0              ; compare with token for NOT
00009DFC  6606                    2956      BNE.s       LAB_1BE7                ; branch if not token for NOT
00009DFE                          2957  
00009DFE                          2958                                  ; was NOT token
00009DFE  323C 002C               2959      MOVE.w  #(TK_EQUAL-TK_PLUS)*4,d1        ; offset to NOT function
00009E02  60C4                    2960      BRA.s       LAB_1C13                ; do set-up for function then execute
00009E04                          2961  
00009E04                          2962                                  ; wasn't +, - or NOT so ...
00009E04                          2963  LAB_1BE7
00009E04  B03C 00AB               2964      CMP.b       #TK_FN,d0               ; compare with token for FN
00009E08  6700 0514               2965      BEQ     LAB_201E                ; if FN go evaluate FNx
00009E0C                          2966  
00009E0C                          2967                                  ; wasn't +, -, NOT or FN so ...
00009E0C  0400 00BF               2968      SUB.b       #TK_SGN,d0              ; compare with token for SGN & normalise
00009E10  6500 F348               2969      BCS     LAB_SNER                ; if < SGN token then do syntax error
00009E14                          2970  
00009E14                          2971  ; get value from line .. continued
00009E14                          2972  ; only functions left so set up function references
00009E14                          2973  
00009E14                          2974  ; new for V2.0+ this replaces a lot of IF .. THEN .. ELSEIF .. THEN .. that was needed
00009E14                          2975  ; to process function calls. now the function vector is computed and pushed on the stack
00009E14                          2976  ; and the preprocess offset is read. if the preprocess offset is non zero then the vector
00009E14                          2977  ; is calculated and the routine called, if not this routine just does RTS. whichever
00009E14                          2978  ; happens the RTS at the end of this routine, or the preprocess routine calls, the
00009E14                          2979  ; function code
00009E14                          2980  
00009E14                          2981  ; this also removes some less than elegant code that was used to bypass type checking
00009E14                          2982  ; for functions that returned strings
00009E14                          2983  
00009E14  C07C 007F               2984      AND.w       #$7F,d0             ; mask byte
00009E18  D040                    2985      ADD.w       d0,d0                   ; *2 (2 bytes per function offset)
00009E1A                          2986  
00009E1A  41FA 20AC               2987      LEA     LAB_FTBL(pc),a0         ; pointer to functions vector table
00009E1E  3230 0000               2988      MOVE.w  (a0,d0.w),d1            ; get function vector offset
00009E22  4870 1000               2989      PEA     (a0,d1.w)               ; push function vector
00009E26                          2990  
00009E26  41FA 2054               2991      LEA     LAB_FTPP(pc),a0         ; pointer to functions preprocess vector table
00009E2A  3030 0000               2992      MOVE.w  (a0,d0.w),d0            ; get function preprocess vector offset
00009E2E  6712                    2993      BEQ.s       LAB_1C2A                ; no preprocess vector so go do function
00009E30                          2994  
00009E30  41F0 0000               2995      LEA     (a0,d0.w),a0            ; get function preprocess vector
00009E34  4ED0                    2996      JMP     (a0)                    ; go do preprocess routine then function
00009E36                          2997  
00009E36                          2998  
00009E36                          2999  ;************************************************************************************
00009E36                          3000  ;
00009E36                          3001  ; process string expression in parenthesis
00009E36                          3002  
00009E36                          3003  LAB_PPFS
00009E36  6100 FF54               3004      BSR     LAB_1BF7                ; process expression in parenthesis
00009E3A  4A2B 05B5               3005      TST.b       Dtypef(a3)              ; test data type
00009E3E  6A00 F2EE               3006      BPL     LAB_TMER                ; if numeric do Type missmatch Error/warm start
00009E42                          3007  
00009E42                          3008  LAB_1C2A
00009E42  4E75                    3009      RTS                         ; else do function
00009E44                          3010  
00009E44                          3011  
00009E44                          3012  ;************************************************************************************
00009E44                          3013  ;
00009E44                          3014  ; process numeric expression in parenthesis
00009E44                          3015  
00009E44                          3016  LAB_PPFN
00009E44  6100 FF46               3017      BSR     LAB_1BF7                ; process expression in parenthesis
00009E48  4A2B 05B5               3018      TST.b       Dtypef(a3)              ; test data type
00009E4C  6B00 F2E0               3019      BMI     LAB_TMER                ; if string do Type missmatch Error/warm start
00009E50                          3020  
00009E50  4E75                    3021      RTS                         ; else do function
00009E52                          3022  
00009E52                          3023  
00009E52                          3024  ;************************************************************************************
00009E52                          3025  ;
00009E52                          3026  ; set numeric data type and increment BASIC execute pointer
00009E52                          3027  
00009E52                          3028  LAB_PPBI
00009E52  177C 0000 05B5          3029      MOVE.b  #$00,Dtypef(a3)         ; clear data type flag, $00=float
00009E58  101D                    3030      MOVE.b  (a5)+,d0                ; get next BASIC byte
00009E5A  4E75                    3031      RTS                         ; do function
00009E5C                          3032  
00009E5C                          3033  
00009E5C                          3034  ;************************************************************************************
00009E5C                          3035  ;
00009E5C                          3036  ; process string for LEFT$, RIGHT$ or MID$
00009E5C                          3037  
00009E5C                          3038  LAB_LRMS
00009E5C  6100 FDE6               3039      BSR     LAB_EVEZ                ; evaluate (should be string) expression
00009E60  4A2B 05B5               3040      TST.b       Dtypef(a3)              ; test data type flag
00009E64  6A00 F2C8               3041      BPL     LAB_TMER                ; if type is not string do type mismatch error
00009E68                          3042  
00009E68  141D                    3043      MOVE.b  (a5)+,d2                ; get BASIC byte
00009E6A  B43C 002C               3044      CMP.b       #',',d2             ; compare with comma
00009E6E  6600 F2EA               3045      BNE     LAB_SNER                ; if not "," go do syntax error/warm start
00009E72                          3046  
00009E72  2F2B 0590               3047      MOVE.l  FAC1_m(a3),-(sp)            ; save descriptor pointer
00009E76  6100 08AC               3048      BSR     LAB_GTWO                ; get word parameter, result in d0 and Itemp
00009E7A  205F                    3049      MOVEA.l (sp)+,a0                ; restore descriptor pointer
00009E7C  4E75                    3050      RTS                         ; do function
00009E7E                          3051  
00009E7E                          3052  
00009E7E                          3053  ;************************************************************************************
00009E7E                          3054  ;
00009E7E                          3055  ; process numeric expression(s) for BIN$ or HEX$
00009E7E                          3056  
00009E7E                          3057  LAB_BHSS
00009E7E  6100 FDC4               3058      BSR     LAB_EVEZ                ; evaluate expression (no decrement)
00009E82  4A2B 05B5               3059      TST.b       Dtypef(a3)              ; test data type
00009E86  6B00 F2A6               3060      BMI     LAB_TMER                ; if string do Type missmatch Error/warm start
00009E8A                          3061  
00009E8A  6100 0DD0               3062      BSR     LAB_2831                ; convert FAC1 floating to fixed
00009E8E                          3063                                  ; result in d0 and Itemp
00009E8E  7200                    3064      MOVEQ       #0,d1                   ; set default to no leading "0"s
00009E90  141D                    3065      MOVE.b  (a5)+,d2                ; get BASIC byte
00009E92  B43C 002C               3066      CMP.b       #',',d2             ; compare with comma
00009E96  660C                    3067      BNE.s       LAB_BHCB                ; if not "," go check close bracket
00009E98                          3068  
00009E98  2F00                    3069      MOVE.l  d0,-(sp)                ; copy number to stack
00009E9A  6100 0872               3070      BSR     LAB_GTBY                ; get byte value
00009E9E  2200                    3071      MOVE.l  d0,d1                   ; copy leading 0s #
00009EA0  201F                    3072      MOVE.l  (sp)+,d0                ; restore number from stack
00009EA2  141D                    3073      MOVE.b  (a5)+,d2                ; get BASIC byte
00009EA4                          3074  LAB_BHCB
00009EA4  B43C 0029               3075      CMP.b       #')',d2             ; compare with close bracket
00009EA8  6600 F2B0               3076      BNE     LAB_SNER                ; if not ")" do Syntax Error/warm start
00009EAC                          3077  
00009EAC  4E75                    3078      RTS                         ; go do function
00009EAE                          3079  
00009EAE                          3080  
00009EAE                          3081  ;************************************************************************************
00009EAE                          3082  ;
00009EAE                          3083  ; perform EOR
00009EAE                          3084  
00009EAE                          3085  LAB_EOR
00009EAE  6116                    3086      BSR.s       GetFirst                ; get two values for OR, AND or EOR
00009EB0                          3087                                  ; first in d0, and Itemp, second in d2
00009EB0  B580                    3088      EOR.l       d2,d0                   ; EOR values
00009EB2  6000 03F0               3089      BRA     LAB_AYFC                ; convert d0 to signed longword in FAC1 & RET
00009EB6                          3090  
00009EB6                          3091  
00009EB6                          3092  ;************************************************************************************
00009EB6                          3093  ;
00009EB6                          3094  ; perform OR
00009EB6                          3095  
00009EB6                          3096  LAB_OR
00009EB6  610E                    3097      BSR.s       GetFirst                ; get two values for OR, AND or EOR
00009EB8                          3098                                  ; first in d0, and Itemp, second in d2
00009EB8  8082                    3099      OR.l        d2,d0                   ; do OR
00009EBA  6000 03E8               3100      BRA     LAB_AYFC                ; convert d0 to signed longword in FAC1 & RET
00009EBE                          3101  
00009EBE                          3102  
00009EBE                          3103  ;************************************************************************************
00009EBE                          3104  ;
00009EBE                          3105  ; perform AND
00009EBE                          3106  
00009EBE                          3107  LAB_AND
00009EBE  6106                    3108      BSR.s       GetFirst                ; get two values for OR, AND or EOR
00009EC0                          3109                                  ; first in d0, and Itemp, second in d2
00009EC0  C082                    3110      AND.l       d2,d0                   ; do AND
00009EC2  6000 03E0               3111      BRA     LAB_AYFC                ; convert d0 to signed longword in FAC1 & RET
00009EC6                          3112  
00009EC6                          3113  
00009EC6                          3114  ;************************************************************************************
00009EC6                          3115  ;
00009EC6                          3116  ; get two values for OR, AND, EOR
00009EC6                          3117  ; first in d0, second in d2
00009EC6                          3118  
00009EC6                          3119  GetFirst
00009EC6  6100 0228               3120      BSR     LAB_EVIR                ; evaluate integer expression (no sign check)
00009ECA                          3121                                  ; result in d0 and Itemp
00009ECA  2400                    3122      MOVE.l  d0,d2                   ; copy second value
00009ECC  6100 0CF6               3123      BSR     LAB_279B                ; copy FAC2 to FAC1, get first value in
00009ED0                          3124                                  ; expression
00009ED0  6000 021E               3125      BRA     LAB_EVIR                ; evaluate integer expression (no sign check)
00009ED4                          3126                                  ; result in d0 and Itemp & return
00009ED4                          3127  
00009ED4                          3128  
00009ED4                          3129  ;************************************************************************************
00009ED4                          3130  ;
00009ED4                          3131  ; perform NOT
00009ED4                          3132  
00009ED4                          3133  LAB_EQUAL
00009ED4  6100 021A               3134      BSR     LAB_EVIR                ; evaluate integer expression (no sign check)
00009ED8                          3135                                  ; result in d0 and Itemp
00009ED8  4680                    3136      NOT.l       d0                  ; bitwise invert
00009EDA  6000 03C8               3137      BRA     LAB_AYFC                ; convert d0 to signed longword in FAC1 & RET
00009EDE                          3138  
00009EDE                          3139  
00009EDE                          3140  ;************************************************************************************
00009EDE                          3141  ;
00009EDE                          3142  ; perform comparisons
00009EDE                          3143  ; do < compare
00009EDE                          3144  
00009EDE                          3145  LAB_LTHAN
00009EDE  6100 FD4E               3146      BSR     LAB_CKTM                ; type match check, set C for string
00009EE2  6506                    3147      BCS.s       LAB_1CAE                ; branch if string
00009EE4                          3148  
00009EE4                          3149                                  ; do numeric < compare
00009EE4  6100 0D4A               3150      BSR     LAB_27FA                ; compare FAC1 with FAC2
00009EE8                          3151                                  ; returns d0=+1 if FAC1 > FAC2
00009EE8                          3152                                  ; returns d0= 0 if FAC1 = FAC2
00009EE8                          3153                                  ; returns d0=-1 if FAC1 < FAC2
00009EE8  6042                    3154      BRA.s       LAB_1CF2                ; process result
00009EEA                          3155  
00009EEA                          3156                                  ; do string < compare
00009EEA                          3157  LAB_1CAE
00009EEA  177C 0000 05B5          3158      MOVE.b  #$00,Dtypef(a3)         ; clear data type, $80=string, $40=integer,
00009EF0                          3159                                  ; $00=float
00009EF0  6100 06BC               3160      BSR     LAB_22B6                ; pop string off descriptor stack, or from top
00009EF4                          3161                                  ; of string space returns d0 = length,
00009EF4                          3162                                  ; a0 = pointer
00009EF4  2248                    3163      MOVEA.l a0,a1                   ; copy string 2 pointer
00009EF6  2200                    3164      MOVE.l  d0,d1                   ; copy string 2 length
00009EF8  206B 0598               3165      MOVEA.l FAC2_m(a3),a0           ; get string 1 descriptor pointer
00009EFC  6100 06B4               3166      BSR     LAB_22BA                ; pop (a0) descriptor, returns with ..
00009F00                          3167                                  ; d0 = length, a0 = pointer
00009F00  2400                    3168      MOVE.l  d0,d2                   ; copy length
00009F02  6604                    3169      BNE.s       LAB_1CB5                ; branch if not null string
00009F04                          3170  
00009F04  4A81                    3171      TST.l       d1                  ; test if string 2 is null also
00009F06  6724                    3172      BEQ.s       LAB_1CF2                ; if so do string 1 = string 2
00009F08                          3173  
00009F08                          3174  LAB_1CB5
00009F08  9481                    3175      SUB.l       d1,d2                   ; subtract string 2 length
00009F0A  670C                    3176      BEQ.s       LAB_1CD5                ; branch if strings = length
00009F0C                          3177  
00009F0C  6504                    3178      BCS.s       LAB_1CD4                ; branch if string 1 < string 2
00009F0E                          3179  
00009F0E  70FF                    3180      MOVEQ       #-1,d0              ; set for string 1 > string 2
00009F10  6008                    3181      BRA.s       LAB_1CD6                ; go do character comapare
00009F12                          3182  
00009F12                          3183  LAB_1CD4
00009F12  2200                    3184      MOVE.l  d0,d1                   ; string 1 length is compare length
00009F14  7001                    3185      MOVEQ       #1,d0                   ; and set for string 1 < string 2
00009F16  6002                    3186      BRA.s       LAB_1CD6                ; go do character comapare
00009F18                          3187  
00009F18                          3188  LAB_1CD5
00009F18  2002                    3189      MOVE.l  d2,d0                   ; set for string 1 = string 2
00009F1A                          3190  LAB_1CD6
00009F1A  5381                    3191      SUBQ.l  #1,d1                   ; adjust length for DBcc loop
00009F1C                          3192  
00009F1C                          3193                                  ; d1 is length to compare, d0 is <=> for length
00009F1C                          3194                                  ; a0 is string 1 pointer, a1 is string 2 pointer
00009F1C                          3195  LAB_1CE6
00009F1C  B308                    3196      CMPM.b  (a0)+,(a1)+             ; compare string bytes (1 with 2)
00009F1E  56C9 FFFC               3197      DBNE        d1,LAB_1CE6             ; loop if same and not end yet
00009F22                          3198  
00009F22  6708                    3199      BEQ.s       LAB_1CF2                ; if = to here, then go use length compare
00009F24                          3200  
00009F24  6404                    3201      BCC.s       LAB_1CDB                ; else branch if string 1 > string 2
00009F26                          3202  
00009F26  70FF                    3203      MOVEQ       #-1,d0              ; else set for string 1 < string 2
00009F28  6002                    3204      BRA.s       LAB_1CF2                ; go set result
00009F2A                          3205  
00009F2A                          3206  LAB_1CDB
00009F2A  7001                    3207      MOVEQ       #1,d0                   ; and set for string 1 > string 2
00009F2C                          3208  
00009F2C                          3209  LAB_1CF2
00009F2C  5200                    3210      ADDQ.b  #1,d0                   ; make result 0, 1 or 2
00009F2E  1200                    3211      MOVE.b  d0,d1                   ; copy to d1
00009F30  7001                    3212      MOVEQ       #1,d0                   ; set d0 longword
00009F32  E338                    3213      ROL.b       d1,d0                   ; make 1, 2 or 4 (result = flag bit)
00009F34  C02B 05E1               3214      AND.b       Cflag(a3),d0            ; AND with comparison evaluation flag
00009F38  6700 0CDE               3215      BEQ     LAB_27DB                ; exit if not a wanted result (i.e. false)
00009F3C                          3216  
00009F3C  70FF                    3217      MOVEQ       #-1,d0              ; else set -1 (true)
00009F3E  6000 0CD8               3218      BRA     LAB_27DB                ; save d0 as integer & return
00009F42                          3219  
00009F42                          3220  
00009F42                          3221  LAB_1CFE
00009F42  6100 FE54               3222      BSR     LAB_1C01                ; scan for ",", else do syntax error/warm start
00009F46                          3223  
00009F46                          3224  
00009F46                          3225  ;************************************************************************************
00009F46                          3226  ;
00009F46                          3227  ; perform DIM
00009F46                          3228  
00009F46                          3229  LAB_DIM
00009F46  72FF                    3230      MOVEQ       #-1,d1              ; set "DIM" flag
00009F48  6170                    3231      BSR.s       LAB_1D10                ; search for or dimension a variable
00009F4A  6100 FE58               3232      BSR     LAB_GBYT                ; scan memory
00009F4E  66F2                    3233      BNE.s       LAB_1CFE                ; loop and scan for "," if not null
00009F50                          3234  
00009F50  4E75                    3235      RTS
00009F52                          3236  
00009F52                          3237  
00009F52                          3238  ;************************************************************************************
00009F52                          3239  ;
00009F52                          3240  ; perform << (left shift)
00009F52                          3241  
00009F52                          3242  LAB_LSHIFT
00009F52  612E                    3243      BSR.s       GetPair             ; get an integer and byte pair
00009F54                          3244                                  ; byte is in d2, integer is in d0 and Itemp
00009F54  6708                    3245      BEQ.s       NoShift             ; branch if byte zero
00009F56                          3246  
00009F56  B43C 0020               3247      CMP.b       #$20,d2             ; compare bit count with 32d
00009F5A  6420                    3248      BCC.s       TooBig              ; branch if >=
00009F5C                          3249  
00009F5C  E5A0                    3250      ASL.l       d2,d0                   ; shift longword
00009F5E                          3251  NoShift
00009F5E  6000 0344               3252      BRA     LAB_AYFC                ; convert d0 to signed longword in FAC1 & RET
00009F62                          3253  
00009F62                          3254  
00009F62                          3255  ;************************************************************************************
00009F62                          3256  ;
00009F62                          3257  ; perform >> (right shift)
00009F62                          3258  
00009F62                          3259  LAB_RSHIFT
00009F62  611E                    3260      BSR.s       GetPair             ; get an integer and byte pair
00009F64                          3261                                  ; byte is in d2, integer is in d0 and Itemp
00009F64  67F8                    3262      BEQ.s       NoShift             ; branch if byte zero
00009F66                          3263  
00009F66  B43C 0020               3264      CMP.b       #$20,d2             ; compare bit count with 32d
00009F6A  650A                    3265      BCS.s       Not2Big             ; branch if >= (return shift)
00009F6C                          3266  
00009F6C  4A80                    3267      TST.l       d0                  ; test sign bit
00009F6E  6A0C                    3268      BPL.s       TooBig              ; branch if +ve
00009F70                          3269  
00009F70  70FF                    3270      MOVEQ       #-1,d0              ; set longword
00009F72  6000 0330               3271      BRA     LAB_AYFC                ; convert d0 to longword in FAC1 & RET
00009F76                          3272  
00009F76                          3273  Not2Big
00009F76  E4A0                    3274      ASR.l       d2,d0                   ; shift longword
00009F78  6000 032A               3275      BRA     LAB_AYFC                ; convert d0 to longword in FAC1 & RET
00009F7C                          3276  
00009F7C                          3277  TooBig
00009F7C  7000                    3278      MOVEQ       #0,d0                   ; clear longword
00009F7E  6000 0324               3279      BRA     LAB_AYFC                ; convert d0 to longword in FAC1 & RET
00009F82                          3280  
00009F82                          3281  
00009F82                          3282  ;************************************************************************************
00009F82                          3283  ;
00009F82                          3284  ; get an integer and byte pair
00009F82                          3285  ; byte is in d2, integer is in d0 and Itemp
00009F82                          3286  
00009F82                          3287  GetPair
00009F82  6100 078E               3288      BSR     LAB_EVBY                ; evaluate byte expression, result in d0 and
00009F86                          3289                                  ; Itemp
00009F86  1400                    3290      MOVE.b  d0,d2                   ; save it
00009F88  6100 0C3A               3291      BSR     LAB_279B                ; copy FAC2 to FAC1, get first value in
00009F8C                          3292                                  ; expression
00009F8C  6100 0162               3293      BSR     LAB_EVIR                ; evaluate integer expression (no sign check)
00009F90                          3294                                  ; result in d0 and Itemp
00009F90  4A02                    3295      TST.b       d2                  ; test byte value
00009F92  4E75                    3296      RTS
00009F94                          3297  
00009F94                          3298  
00009F94                          3299  ;************************************************************************************
00009F94                          3300  ;
00009F94                          3301  ; check alpha, return C=0 if<"A" or >"Z" or <"a" to "z">
00009F94                          3302  
00009F94                          3303  LAB_CASC
00009F94  B03C 0061               3304      CMP.b       #$61,d0             ; compare with "a"
00009F98  6410                    3305      BCC.s       LAB_1D83                ; if >="a" go check =<"z"
00009F9A                          3306  
00009F9A                          3307  
00009F9A                          3308  ;************************************************************************************
00009F9A                          3309  ;
00009F9A                          3310  ; check alpha upper case, return C=0 if<"A" or >"Z"
00009F9A                          3311  
00009F9A                          3312  LAB_CAUC
00009F9A  B03C 0041               3313      CMP.b       #$41,d0             ; compare with "A"
00009F9E  6404                    3314      BCC.s       LAB_1D8A                ; if >="A" go check =<"Z"
00009FA0                          3315  
00009FA0  8040                    3316      OR      d0,d0                   ; make C=0
00009FA2  4E75                    3317      RTS
00009FA4                          3318  
00009FA4                          3319  LAB_1D8A
00009FA4  B03C 005B               3320      CMP.b       #$5B,d0             ; compare with "Z"+1
00009FA8                          3321                                  ; carry set if byte<="Z"
00009FA8  4E75                    3322      RTS
00009FAA                          3323  
00009FAA                          3324  LAB_1D83
00009FAA  B03C 007B               3325      CMP.b       #$7B,d0             ; compare with "z"+1
00009FAE                          3326                                  ; carry set if byte<="z"
00009FAE  4E75                    3327      RTS
00009FB0                          3328  
00009FB0                          3329  
00009FB0                          3330  ;************************************************************************************
00009FB0                          3331  ;
00009FB0                          3332  ; search for or create variable. this is used to automatically create a variable if
00009FB0                          3333  ; it is not found. any routines that need to create the variable call LAB_GVAR via
00009FB0                          3334  ; this point and error generation is supressed and the variable will be created
00009FB0                          3335  ;
00009FB0                          3336  ; return pointer to variable in Cvaral and a0
00009FB0                          3337  ; set data type to variable type
00009FB0                          3338  
00009FB0                          3339  LAB_SVAR
00009FB0  6102                    3340      BSR.s       LAB_GVAR                ; search for variable
00009FB2                          3341  LAB_FVAR
00009FB2  4E75                    3342      RTS
00009FB4                          3343  
00009FB4                          3344  
00009FB4                          3345  ;************************************************************************************
00009FB4                          3346  ;
00009FB4                          3347  ; search for variable. if this routine is called from anywhere but the above call and
00009FB4                          3348  ; the variable searched for does not exist then an error will be returned
00009FB4                          3349  ;
00009FB4                          3350  ; DIM flag is in d1.b
00009FB4                          3351  ; return pointer to variable in Cvaral and a0
00009FB4                          3352  ; set data type to variable type
00009FB4                          3353  
00009FB4                          3354  LAB_GVAR
00009FB4  7200                    3355      MOVEQ       #$00,d1             ; set DIM flag = $00
00009FB6  6100 FDEC               3356      BSR     LAB_GBYT                ; scan memory (1st character)
00009FBA                          3357  LAB_1D10
00009FBA  1741 05B4               3358      MOVE.b  d1,Defdim(a3)           ; save DIM flag
00009FBE                          3359  
00009FBE                          3360  ; search for FN name entry point
00009FBE                          3361  
00009FBE                          3362  LAB_1D12
00009FBE  61D4                    3363      BSR.s       LAB_CASC                ; check byte, return C=0 if<"A" or >"Z"
00009FC0  6400 F198               3364      BCC     LAB_SNER                ; if not, syntax error then warm start
00009FC4                          3365  
00009FC4                          3366                                  ; it is a variable name so ...
00009FC4  7200                    3367      MOVEQ       #$0,d1              ; set index for name byte
00009FC6  41EB 046A               3368      LEA     Varname(a3),a0          ; pointer to variable name
00009FCA  2081                    3369      MOVE.l  d1,(a0)             ; clear the variable name
00009FCC  1741 05B5               3370      MOVE.b  d1,Dtypef(a3)           ; clear the data type, $80=string, $40=integer,
00009FD0                          3371                                  ; $00=float
00009FD0                          3372  
00009FD0                          3373  LAB_1D2D
00009FD0  B27C 0004               3374      CMP.w       #$04,d1             ; done all significant characters?
00009FD4  6406                    3375      BCC.s       LAB_1D2E                ; if so go ignore any more
00009FD6                          3376  
00009FD6  1180 1000               3377      MOVE.b  d0,(a0,d1.w)            ; save the character
00009FDA  5241                    3378      ADDQ.w  #1,d1                   ; increment index
00009FDC                          3379  LAB_1D2E
00009FDC  6100 FDC4               3380      BSR     LAB_IGBY                ; increment & scan memory (next character)
00009FE0  65EE                    3381      BCS.s       LAB_1D2D                ; branch if character = "0"-"9" (ok)
00009FE2                          3382  
00009FE2                          3383                                  ; character wasn't "0" to "9" so ...
00009FE2  61B0                    3384      BSR.s       LAB_CASC                ; check byte, return C=0 if<"A" or >"Z"
00009FE4  65EA                    3385      BCS.s       LAB_1D2D                ; branch if = "A"-"Z" (ok)
00009FE6                          3386  
00009FE6                          3387                                  ; check if string variable
00009FE6  B03C 0024               3388      CMP.b       #'$',d0             ; compare with "$"
00009FEA  660C                    3389      BNE.s       LAB_1D44                ; branch if not string
00009FEC                          3390  
00009FEC                          3391                                  ; type is string
00009FEC  002B 0080 046B          3392      OR.b        #$80,Varname+1(a3)      ; set top bit of 2nd character, indicate string
00009FF2  6100 FDAE               3393      BSR     LAB_IGBY                ; increment & scan memory
00009FF6  6010                    3394      BRA.s       LAB_1D45                ; skip integer check
00009FF8                          3395  
00009FF8                          3396                                  ; check if integer variable
00009FF8                          3397  LAB_1D44
00009FF8  B03C 0026               3398      CMP.b       #'&',d0             ; compare with "&"
00009FFC  660A                    3399      BNE.s       LAB_1D45                ; branch if not integer
00009FFE                          3400  
00009FFE                          3401                                  ; type is integer
00009FFE  002B 0080 046C          3402      OR.b        #$80,Varname+2(a3)      ; set top bit of 3rd character, indicate integer
0000A004  6100 FD9C               3403      BSR     LAB_IGBY                ; increment & scan memory
0000A008                          3404  
0000A008                          3405  ; after we have determined the variable type we need to determine
0000A008                          3406  ; if it's an array of type
0000A008                          3407  
0000A008                          3408                                  ; gets here with character after var name in d0
0000A008                          3409  LAB_1D45
0000A008  4A2B 05DF               3410      TST.b       Sufnxf(a3)              ; test function name flag
0000A00C  670E                    3411      BEQ.s       LAB_1D48                ; if not FN or FN variable continue
0000A00E                          3412  
0000A00E  6A14                    3413      BPL.s       LAB_1D49                ; if FN variable go find or create it
0000A010                          3414  
0000A010                          3415                                  ; else was FN name
0000A010  202B 046A               3416      MOVE.l  Varname(a3),d0          ; get whole function name
0000A014  7208                    3417      MOVEQ       #8,d1                   ; set step to next function size -4
0000A016  41EB 0432               3418      LEA     Sfncl(a3),a0            ; get pointer to start of functions
0000A01A  601C                    3419      BRA.s       LAB_1D4B                ; go find function
0000A01C                          3420  
0000A01C                          3421  LAB_1D48
0000A01C  0400 0028               3422      SUB.b       #'(',d0             ; subtract "("
0000A020  6700 00F4               3423      BEQ     LAB_1E17                ; if "(" go find, or make, array
0000A024                          3424  
0000A024                          3425  ; either find or create var
0000A024                          3426  ; var name (1st four characters only!) is in Varname
0000A024                          3427  
0000A024                          3428                                  ; variable name wasn't var( .. so look for
0000A024                          3429                                  ; plain variable
0000A024                          3430  LAB_1D49
0000A024  202B 046A               3431      MOVE.l  Varname(a3),d0          ; get whole variable name
0000A028                          3432  LAB_1D4A
0000A028  7204                    3433      MOVEQ       #4,d1                   ; set step to next variable size -4
0000A02A  41EB 0436               3434      LEA     Svarl(a3),a0            ; get pointer to start of variables
0000A02E                          3435  
0000A02E  0800 0017               3436      BTST.l  #23,d0              ; test if string name
0000A032  6704                    3437      BEQ.s       LAB_1D4B                ; branch if not
0000A034                          3438  
0000A034  5441                    3439      ADDQ.w  #2,d1                   ; 6 bytes per string entry
0000A036  5848                    3440      ADDQ.w  #(Sstrl-Svarl),a0           ; move to string area
0000A038                          3441  
0000A038                          3442  LAB_1D4B
0000A038  2268 0004               3443      MOVEA.l 4(a0),a1                ; get end address
0000A03C  2050                    3444      MOVEA.l (a0),a0             ; get start address
0000A03E  6006                    3445      BRA.s       LAB_1D5E                ; enter loop at exit check
0000A040                          3446  
0000A040                          3447  LAB_1D5D
0000A040  B098                    3448      CMP.l       (a0)+,d0                ; compare this variable with name
0000A042  6776                    3449      BEQ.s       LAB_1DD7                ; branch if match (found var)
0000A044                          3450  
0000A044  D1C1                    3451      ADDA.l  d1,a0                   ; add offset to next variable
0000A046                          3452  LAB_1D5E
0000A046  B1C9                    3453      CMPA.l  a1,a0                   ; compare address with variable space end
0000A048  66F6                    3454      BNE.s       LAB_1D5D                ; if not end go check next
0000A04A                          3455  
0000A04A  4A2B 05DF               3456      TST.b       Sufnxf(a3)              ; is it a function or function variable
0000A04E  660A                    3457      BNE.s       LAB_1D94                ; if was go do DEF or function variable
0000A050                          3458  
0000A050                          3459                                  ; reached end of variable mem without match
0000A050                          3460                                  ; ... so create new variable, possibly
0000A050                          3461  
0000A050  45FA FF60               3462      LEA     LAB_FVAR(pc),a2         ; get the address of the create if doesn't
0000A054                          3463                                  ; exist call to LAB_GVAR
0000A054  B5D7                    3464      CMPA.l  (sp),a2             ; compare the return address with expected
0000A056  6600 F0BE               3465      BNE     LAB_UVER                ; if not create go do error or return null
0000A05A                          3466  
0000A05A                          3467  ; this will only branch if the call to LAB_GVAR wasn't from LAB_SVAR
0000A05A                          3468  
0000A05A                          3469  LAB_1D94
0000A05A  082B 0000 05DF          3470      BTST.b  #0,Sufnxf(a3)           ; test function search flag
0000A060  6600 F0BC               3471      BNE     LAB_UFER                ; if not doing DEF then go do undefined
0000A064                          3472                                  ; function error
0000A064                          3473  
0000A064                          3474                                  ; else create new variable/function
0000A064                          3475  LAB_1D98
0000A064  246B 0442               3476      MOVEA.l Earryl(a3),a2           ; get end of block to move
0000A068  240A                    3477      MOVE.l  a2,d2                   ; copy end of block to move
0000A06A  9489                    3478      SUB.l       a1,d2                   ; calculate block to move size
0000A06C                          3479  
0000A06C  204A                    3480      MOVEA.l a2,a0                   ; copy end of block to move
0000A06E  5881                    3481      ADDQ.l  #4,d1                   ; space for one variable/function + name
0000A070  D5C1                    3482      ADDA.l  d1,a2                   ; add space for one variable/function
0000A072  274A 0442               3483      MOVE.l  a2,Earryl(a3)           ; set new array mem end
0000A076  E28A                    3484      LSR.l       #1,d2                   ; /2 for word copy
0000A078  6712                    3485      BEQ.s       LAB_1DAF                ; skip move if zero length block
0000A07A                          3486  
0000A07A  5382                    3487      SUBQ.l  #1,d2                   ; -1 for DFB loop
0000A07C  4842                    3488      SWAP        d2                  ; swap high word to low word
0000A07E                          3489  LAB_1DAC
0000A07E  4842                    3490      SWAP        d2                  ; swap high word to low word
0000A080                          3491  LAB_1DAE
0000A080  3520                    3492      MOVE.w  -(a0),-(a2)             ; copy word
0000A082  51CA FFFC               3493      DBF     d2,LAB_1DAE             ; loop until done
0000A086                          3494  
0000A086  4842                    3495      SWAP        d2                  ; swap high word to low word
0000A088  51CA FFF4               3496      DBF     d2,LAB_1DAC             ; decrement high count and loop until done
0000A08C                          3497  
0000A08C                          3498  ; get here after creating either a function, variable or string
0000A08C                          3499  ; if function set variables start, string start, array start
0000A08C                          3500  ; if variable set string start, array start
0000A08C                          3501  ; if string set array start
0000A08C                          3502  
0000A08C                          3503  LAB_1DAF
0000A08C  4A2B 05DF               3504      TST.b       Sufnxf(a3)              ; was it function
0000A090  6B08                    3505      BMI.s       LAB_1DB0                ; branch if was FN
0000A092                          3506  
0000A092  0800 0017               3507      BTST.l  #23,d0              ; was it string
0000A096  660A                    3508      BNE.s       LAB_1DB2                ; branch if string
0000A098                          3509  
0000A098  6004                    3510      BRA.s       LAB_1DB1                ; branch if was plain variable
0000A09A                          3511  
0000A09A                          3512  LAB_1DB0
0000A09A  D3AB 0436               3513      ADD.l       d1,Svarl(a3)            ; set new variable memory start
0000A09E                          3514  LAB_1DB1
0000A09E  D3AB 043A               3515      ADD.l       d1,Sstrl(a3)            ; set new start of strings
0000A0A2                          3516  LAB_1DB2
0000A0A2  D3AB 043E               3517      ADD.l       d1,Sarryl(a3)           ; set new array memory start
0000A0A6  20C0                    3518      MOVE.l  d0,(a0)+                ; save variable/function name
0000A0A8  20BC 00000000           3519      MOVE.l  #$00,(a0)               ; initialise variable
0000A0AE  0800 0017               3520      BTST.l  #23,d0              ; was it string
0000A0B2  6706                    3521      BEQ.s       LAB_1DD7                ; branch if not string
0000A0B4                          3522  
0000A0B4  317C 0000 0004          3523      MOVE.w  #$00,4(a0)              ; else initialise string length
0000A0BA                          3524  
0000A0BA                          3525                                  ; found a match for var ((Vrschl) = ptr)
0000A0BA                          3526  LAB_1DD7
0000A0BA  2200                    3527      MOVE.l  d0,d1                   ; ........ $....... &....... ........
0000A0BC  D281                    3528      ADD.l       d1,d1                   ; .......$ .......& ........ .......0
0000A0BE  4841                    3529      SWAP        d1                  ; ........ .......0 .......$ .......&
0000A0C0  E219                    3530      ROR.b       #1,d1                   ; ........ .......0 .......$ &.......
0000A0C2  E249                    3531      LSR.w       #1,d1                   ; ........ .......0 0....... $&.....�.
0000A0C4  C23C 00C0               3532      AND.b       #$C0,d1             ; mask the type bits
0000A0C8  1741 05B5               3533      MOVE.b  d1,Dtypef(a3)           ; save the data type
0000A0CC                          3534  
0000A0CC  177C 0000 05DF          3535      MOVE.b  #$00,Sufnxf(a3)         ; clear FN flag byte
0000A0D2  4E75                    3536      RTS
0000A0D4                          3537  
0000A0D4                          3538  
0000A0D4                          3539  ;************************************************************************************
0000A0D4                          3540  ;
0000A0D4                          3541  ; set-up array pointer, d0, to first element in array
0000A0D4                          3542  ; set d0 to (a0)+2*(Dimcnt)+$0A
0000A0D4                          3543  
0000A0D4                          3544  LAB_1DE6
0000A0D4  7005                    3545      MOVEQ       #5,d0                   ; set d0 to 5 (*2 = 10, later)
0000A0D6  D02B 05DB               3546      ADD.b       Dimcnt(a3),d0           ; add # of dimensions (1, 2 or 3)
0000A0DA  D080                    3547      ADD.l       d0,d0                   ; *2 (bytes per dimension size)
0000A0DC  D088                    3548      ADD.l       a0,d0                   ; add array start pointer
0000A0DE  4E75                    3549      RTS
0000A0E0                          3550  
0000A0E0                          3551  
0000A0E0                          3552  ;************************************************************************************
0000A0E0                          3553  ;
0000A0E0                          3554  ; evaluate unsigned integer expression
0000A0E0                          3555  
0000A0E0                          3556  LAB_EVIN
0000A0E0  6100 FCC0               3557      BSR     LAB_IGBY                ; increment & scan memory
0000A0E4  6100 FB44               3558      BSR     LAB_EVNM                ; evaluate expression & check is numeric,
0000A0E8                          3559                                  ; else do type mismatch
0000A0E8                          3560  
0000A0E8                          3561  
0000A0E8                          3562  ;************************************************************************************
0000A0E8                          3563  ;
0000A0E8                          3564  ; evaluate positive integer expression, result in d0 and Itemp
0000A0E8                          3565  
0000A0E8                          3566  LAB_EVPI
0000A0E8  4A2B 0595               3567      TST.b       FAC1_s(a3)              ; test FAC1 sign (b7)
0000A0EC  6B00 F060               3568      BMI     LAB_FCER                ; do function call error if -ve
0000A0F0                          3569  
0000A0F0                          3570  
0000A0F0                          3571  ;************************************************************************************
0000A0F0                          3572  ;
0000A0F0                          3573  ; evaluate integer expression, no sign check
0000A0F0                          3574  ; result in d0 and Itemp, exit with flags set correctly
0000A0F0                          3575  
0000A0F0                          3576  LAB_EVIR
0000A0F0  0C2B 00A0 0594          3577      CMPI.b  #$A0,FAC1_e(a3)         ; compare exponent with exponent = 2^32 (n>2^31)
0000A0F6  6500 0B64               3578      BCS     LAB_2831                ; convert FAC1 floating to fixed
0000A0FA                          3579                                  ; result in d0 and Itemp
0000A0FA  6600 F052               3580      BNE     LAB_FCER                ; if > do function call error, then warm start
0000A0FE                          3581  
0000A0FE  4A2B 0595               3582      TST.b       FAC1_s(a3)              ; test sign of FAC1
0000A102  6A00 0B58               3583      BPL     LAB_2831                ; if +ve then ok
0000A106                          3584  
0000A106  202B 0590               3585      MOVE.l  FAC1_m(a3),d0           ; get mantissa
0000A10A  4480                    3586      NEG.l       d0                  ; do -d0
0000A10C  6800 F040               3587      BVC     LAB_FCER                ; if not $80000000 do FC error, then warm start
0000A110                          3588  
0000A110  2740 042A               3589      MOVE.l  d0,Itemp(a3)            ; else just set it
0000A114  4E75                    3590      RTS
0000A116                          3591  
0000A116                          3592  
0000A116                          3593  ;************************************************************************************
0000A116                          3594  ;
0000A116                          3595  ; find or make array
0000A116                          3596  
0000A116                          3597  LAB_1E17
0000A116  3F2B 05B4               3598      MOVE.w  Defdim(a3),-(sp)            ; get DIM flag and data type flag (word in mem)
0000A11A  7200                    3599      MOVEQ       #0,d1                   ; clear dimensions count
0000A11C                          3600  
0000A11C                          3601  ; now get the array dimension(s) and stack it (them) before the data type and DIM flag
0000A11C                          3602  
0000A11C                          3603  LAB_1E1F
0000A11C  3F01                    3604      MOVE.w  d1,-(sp)                ; save dimensions count
0000A11E  2F2B 046A               3605      MOVE.l  Varname(a3),-(sp)           ; save variable name
0000A122  61BC                    3606      BSR.s       LAB_EVIN                ; evaluate integer expression
0000A124                          3607  
0000A124  4840                    3608      SWAP        d0                  ; swap high word to low word
0000A126  4A40                    3609      TST.w       d0                  ; test swapped high word
0000A128  6600 F014               3610      BNE     LAB_ABER                ; if too big do array bounds error
0000A12C                          3611  
0000A12C  275F 046A               3612      MOVE.l  (sp)+,Varname(a3)           ; restore variable name
0000A130  321F                    3613      MOVE.w  (sp)+,d1                ; restore dimensions count
0000A132  301F                    3614      MOVE.w  (sp)+,d0                ; restore DIM and data type flags
0000A134  3F2B 042C               3615      MOVE.w  Itemp+2(a3),-(sp)           ; stack this dimension size
0000A138  3F00                    3616      MOVE.w  d0,-(sp)                ; save DIM and data type flags
0000A13A  5241                    3617      ADDQ.w  #1,d1                   ; increment dimensions count
0000A13C  6100 FC66               3618      BSR     LAB_GBYT                ; scan memory
0000A140  B03C 002C               3619      CMP.b       #$2C,d0             ; compare with ","
0000A144  67D6                    3620      BEQ.s       LAB_1E1F                ; if found go do next dimension
0000A146                          3621  
0000A146  1741 05DB               3622      MOVE.b  d1,Dimcnt(a3)           ; store dimensions count
0000A14A  6100 FC44               3623      BSR     LAB_1BFB                ; scan for ")", else do syntax error/warm start
0000A14E  375F 05B4               3624      MOVE.w  (sp)+,Defdim(a3)            ; restore DIM and data type flags (word in mem)
0000A152  206B 043E               3625      MOVEA.l Sarryl(a3),a0           ; get array mem start
0000A156                          3626  
0000A156                          3627  ; now check to see if we are at the end of array memory (we would be if there were
0000A156                          3628  ; no arrays).
0000A156                          3629  
0000A156                          3630  LAB_1E5C
0000A156  2748 05AC               3631      MOVE.l  a0,Astrtl(a3)           ; save as array start pointer
0000A15A  B1EB 0442               3632      CMPA.l  Earryl(a3),a0           ; compare with array mem end
0000A15E  672E                    3633      BEQ.s       LAB_1EA1                ; go build array if not found
0000A160                          3634  
0000A160                          3635                                  ; search for array
0000A160  2010                    3636      MOVE.l  (a0),d0             ; get this array name
0000A162  B0AB 046A               3637      CMP.l       Varname(a3),d0          ; compare with array name
0000A166  670A                    3638      BEQ.s       LAB_1E8D                ; array found so branch
0000A168                          3639  
0000A168                          3640                                  ; no match
0000A168  2068 0004               3641      MOVEA.l 4(a0),a0                ; get this array size
0000A16C  D1EB 05AC               3642      ADDA.l  Astrtl(a3),a0           ; add to array start pointer
0000A170  60E4                    3643      BRA.s       LAB_1E5C                ; go check next array
0000A172                          3644  
0000A172                          3645                                  ; found array, are we trying to dimension it?
0000A172                          3646  LAB_1E8D
0000A172  4A2B 05B4               3647      TST.b       Defdim(a3)              ; are we trying to dimension it?
0000A176  6600 EFC2               3648      BNE     LAB_DDER                ; if so do double dimension error/warm start
0000A17A                          3649  
0000A17A                          3650  ; found the array and we're not dimensioning it so we must find an element in it
0000A17A                          3651  
0000A17A  6100 FF58               3652      BSR     LAB_1DE6                ; set data pointer, d0, to the first element
0000A17E                          3653                                  ; in the array
0000A17E  5048                    3654      ADDQ.w  #8,a0                   ; index to dimension count
0000A180  3018                    3655      MOVE.w  (a0)+,d0                ; get no of dimensions
0000A182  B02B 05DB               3656      CMP.b       Dimcnt(a3),d0           ; compare with dimensions count
0000A186  6700 0094               3657      BEQ     LAB_1F28                ; found array so go get element
0000A18A                          3658  
0000A18A  6000 EF82               3659      BRA     LAB_WDER                ; else wrong so do "Wrong dimensions" error
0000A18E                          3660  
0000A18E                          3661                                  ; array not found, so possibly build it
0000A18E                          3662  LAB_1EA1
0000A18E  4A2B 05B4               3663      TST.b       Defdim(a3)              ; test the default DIM flag
0000A192  6700 EF7E               3664      BEQ     LAB_UDER                ; if default flag is clear then we are not
0000A196                          3665                                  ; explicitly dimensioning an array so go
0000A196                          3666                                  ; do an "Undimensioned array" error
0000A196                          3667  
0000A196  6100 FF3C               3668      BSR     LAB_1DE6                ; set data pointer, d0, to the first element
0000A19A                          3669                                  ; in the array
0000A19A  202B 046A               3670      MOVE.l  Varname(a3),d0          ; get array name
0000A19E  20C0                    3671      MOVE.l  d0,(a0)+                ; save array name
0000A1A0  7204                    3672      MOVEQ       #4,d1                   ; set 4 bytes per element
0000A1A2  0800 0017               3673      BTST.l  #23,d0              ; test if string array
0000A1A6  6702                    3674      BEQ.s       LAB_1EDF                ; branch if not string
0000A1A8                          3675  
0000A1A8  7206                    3676      MOVEQ       #6,d1                   ; else 6 bytes per element
0000A1AA                          3677  LAB_1EDF
0000A1AA  2741 05A8               3678      MOVE.l  d1,Asptl(a3)            ; set array data size (bytes per element)
0000A1AE  122B 05DB               3679      MOVE.b  Dimcnt(a3),d1           ; get dimensions count
0000A1B2  5848                    3680      ADDQ.w  #4,a0                   ; skip the array size now (don't know it yet!)
0000A1B4  30C1                    3681      MOVE.w  d1,(a0)+                ; set array's dimensions count
0000A1B6                          3682  
0000A1B6                          3683  ; now calculate the array data space size
0000A1B6                          3684  
0000A1B6                          3685  LAB_1EC0
0000A1B6                          3686  
0000A1B6                          3687  ; If you want arrays to dimension themselves by default then comment out the test
0000A1B6                          3688  ; above and uncomment the next three code lines and the label LAB_1ED0
0000A1B6                          3689  
0000A1B6                          3690  ;   MOVE.w  #$0A,d1             ; set default dimension value, allow 0 to 9
0000A1B6                          3691  ;   TST.b       Defdim(a3)              ; test default DIM flag
0000A1B6                          3692  ;   BNE.s       LAB_1ED0                ; branch if b6 of Defdim is clear
0000A1B6                          3693  
0000A1B6  321F                    3694      MOVE.w  (sp)+,d1                ; get dimension size
0000A1B8                          3695  ;LAB_1ED0
0000A1B8  30C1                    3696      MOVE.w  d1,(a0)+                ; save to array header
0000A1BA  6100 00AE               3697      BSR     LAB_1F7C                ; do this dimension size+1  ; array size
0000A1BE                          3698                                  ; (d1+1)*(Asptl), result in d0
0000A1BE  2740 05A8               3699      MOVE.l  d0,Asptl(a3)            ; save array data size
0000A1C2  532B 05DB               3700      SUBQ.b  #1,Dimcnt(a3)           ; decrement dimensions count
0000A1C6  66EE                    3701      BNE.s       LAB_1EC0                ; loop while not = 0
0000A1C8                          3702  
0000A1C8  D1EB 05A8               3703      ADDA.l  Asptl(a3),a0            ; add size to first element address
0000A1CC  6500 EF78               3704      BCS     LAB_OMER                ; if overflow go do "Out of memory" error
0000A1D0                          3705  
0000A1D0  B1EB 0446               3706      CMPA.l  Sstorl(a3),a0           ; compare with bottom of string memory
0000A1D4  650C                    3707      BCS.s       LAB_1ED6                ; branch if less (is ok)
0000A1D6                          3708  
0000A1D6  6100 028E               3709      BSR     LAB_GARB                ; do garbage collection routine
0000A1DA  B1EB 0446               3710      CMPA.l  Sstorl(a3),a0           ; compare with bottom of string memory
0000A1DE  6400 EF66               3711      BCC     LAB_OMER                ; if Sstorl <= a0 do "Out of memory"
0000A1E2                          3712                                  ; error then warm start
0000A1E2                          3713  
0000A1E2                          3714  LAB_1ED6                            ; ok exit, carry set
0000A1E2  2748 0442               3715      MOVE.l  a0,Earryl(a3)           ; save array mem end
0000A1E6  7000                    3716      MOVEQ       #0,d0                   ; zero d0
0000A1E8  222B 05A8               3717      MOVE.l  Asptl(a3),d1            ; get size in bytes
0000A1EC  E289                    3718      LSR.l       #1,d1                   ; /2 for word fill (may be odd # words)
0000A1EE  5341                    3719      SUBQ.w  #1,d1                   ; adjust for DBF loop
0000A1F0                          3720  LAB_1ED8
0000A1F0  3100                    3721      MOVE.w  d0,-(a0)                ; decrement pointer and clear word
0000A1F2  51C9 FFFC               3722      DBF     d1,LAB_1ED8             ; decrement & loop until low word done
0000A1F6                          3723  
0000A1F6  4841                    3724      SWAP        d1                  ; swap words
0000A1F8  4A41                    3725      TST.w       d1                  ; test high word
0000A1FA  6706                    3726      BEQ.s       LAB_1F07                ; exit if done
0000A1FC                          3727  
0000A1FC  5341                    3728      SUBQ.w  #1,d1                   ; decrement low (high) word
0000A1FE  4841                    3729      SWAP        d1                  ; swap back
0000A200  60EE                    3730      BRA.s       LAB_1ED8                ; go do a whole block
0000A202                          3731  
0000A202                          3732  ; now we need to calculate the array size by doing Earryl - Astrtl
0000A202                          3733  
0000A202                          3734  LAB_1F07
0000A202  206B 05AC               3735      MOVEA.l Astrtl(a3),a0           ; get for calculation and as pointer
0000A206  202B 0442               3736      MOVE.l  Earryl(a3),d0           ; get array memory end
0000A20A  9088                    3737      SUB.l       a0,d0                   ; calculate array size
0000A20C  2140 0004               3738      MOVE.l  d0,4(a0)                ; save size to array
0000A210  4A2B 05B4               3739      TST.b       Defdim(a3)              ; test default DIM flag
0000A214  6652                    3740      BNE.s       RTS_011             ; exit (RET) if this was a DIM command
0000A216                          3741  
0000A216                          3742                                  ; else, find element
0000A216  5048                    3743      ADDQ.w  #8,a0                   ; index to dimension count
0000A218  3758 05DB               3744      MOVE.w  (a0)+,Dimcnt(a3)            ; get array's dimension count
0000A21C                          3745  
0000A21C                          3746  ; we have found, or built, the array. now we need to find the element
0000A21C                          3747  
0000A21C                          3748  LAB_1F28
0000A21C  7000                    3749      MOVEQ       #0,d0                   ; clear first result
0000A21E  2740 05A8               3750      MOVE.l  d0,Asptl(a3)            ; clear array data pointer
0000A222                          3751  
0000A222                          3752  ; compare nth dimension bound (a0) with nth index (sp)+
0000A222                          3753  ; if greater do array bounds error
0000A222                          3754  
0000A222                          3755  LAB_1F2C
0000A222  3218                    3756      MOVE.w  (a0)+,d1                ; get nth dimension bound
0000A224  B257                    3757      CMP.w       (sp),d1             ; compare nth index with nth dimension bound
0000A226  6500 EF16               3758      BCS     LAB_ABER                ; if d1 less or = do array bounds error
0000A22A                          3759  
0000A22A                          3760  ; now do pointer = pointer  ; nth dimension + nth index
0000A22A                          3761  
0000A22A  4A80                    3762      TST.l       d0                  ; test pointer
0000A22C  6702                    3763      BEQ.s       LAB_1F5A                ; skip multiply if last result = null
0000A22E                          3764  
0000A22E  613A                    3765      BSR.s       LAB_1F7C                ; do this dimension size+1  ; array size
0000A230                          3766  LAB_1F5A
0000A230  7200                    3767      MOVEQ       #0,d1                   ; clear longword
0000A232  321F                    3768      MOVE.w  (sp)+,d1                ; get nth dimension index
0000A234  D081                    3769      ADD.l       d1,d0                   ; add index to size
0000A236  2740 05A8               3770      MOVE.l  d0,Asptl(a3)            ; save array data pointer
0000A23A                          3771  
0000A23A  532B 05DB               3772      SUBQ.b  #1,Dimcnt(a3)           ; decrement dimensions count
0000A23E  66E2                    3773      BNE.s       LAB_1F2C                ; loop if dimensions still to do
0000A240                          3774  
0000A240  177C 0000 05B5          3775      MOVE.b  #0,Dtypef(a3)           ; set data type to float
0000A246  7203                    3776      MOVEQ       #3,d1                   ; set for numeric array
0000A248  4A2B 046B               3777      TST.b       Varname+1(a3)           ; test if string array
0000A24C  6A0A                    3778      BPL.s       LAB_1F6A                ; branch if not string
0000A24E                          3779  
0000A24E  7205                    3780      MOVEQ       #5,d1                   ; else set for string array
0000A250  177C 0080 05B5          3781      MOVE.b  #$80,Dtypef(a3)         ; and set data type to string
0000A256  600C                    3782      BRA.s       LAB_1F6B                ; skip integer test
0000A258                          3783  
0000A258                          3784  LAB_1F6A
0000A258  4A2B 046C               3785      TST.b       Varname+2(a3)           ; test if integer array
0000A25C  6A06                    3786      BPL.s       LAB_1F6B                ; branch if not integer
0000A25E                          3787  
0000A25E  177C 0040 05B5          3788      MOVE.b  #$40,Dtypef(a3)         ; else set data type to integer
0000A264                          3789  LAB_1F6B
0000A264  6104                    3790      BSR.s       LAB_1F7C                ; do element size (d1)  ; array size (Asptl)
0000A266  D1C0                    3791      ADDA.l  d0,a0                   ; add array data start pointer
0000A268                          3792  RTS_011
0000A268  4E75                    3793      RTS
0000A26A                          3794  
0000A26A                          3795  
0000A26A                          3796  ;************************************************************************************
0000A26A                          3797  ;
0000A26A                          3798  ; do this dimension size (d1)   ; array data size (Asptl)
0000A26A                          3799  
0000A26A                          3800  ; do a 16 x 32 bit multiply
0000A26A                          3801  ; d1 holds the 16 bit multiplier
0000A26A                          3802  ; Asptl holds the 32 bit multiplicand
0000A26A                          3803  
0000A26A                          3804  ; d0    bbbb  bbbb
0000A26A                          3805  ; d1    0000  aaaa
0000A26A                          3806  ;   ----------
0000A26A                          3807  ; d0    rrrr  rrrr
0000A26A                          3808  
0000A26A                          3809  LAB_1F7C
0000A26A  202B 05A8               3810      MOVE.l  Asptl(a3),d0            ; get result
0000A26E  2400                    3811      MOVE.l  d0,d2                   ; copy it
0000A270  4842                    3812      SWAP        d2                  ; shift high word to low word
0000A272  C0C1                    3813      MULU.w  d1,d0                   ; d1    ; low word = low result
0000A274  C4C1                    3814      MULU.w  d1,d2                   ; d1    ; high word = high result
0000A276  4842                    3815      SWAP        d2                  ; align words for test
0000A278  4A42                    3816      TST.w       d2                  ; must be zero
0000A27A  6600 EECA               3817      BNE     LAB_OMER                ; if overflow go do "Out of memory" error
0000A27E                          3818  
0000A27E  D082                    3819      ADD.l       d2,d0                   ; calculate result
0000A280  6500 EEC4               3820      BCS     LAB_OMER                ; if overflow go do "Out of memory" error
0000A284                          3821  
0000A284  D0AB 05A8               3822      ADD.l       Asptl(a3),d0            ; add original
0000A288  6500 EEBC               3823      BCS     LAB_OMER                ; if overflow go do "Out of memory" error
0000A28C                          3824  
0000A28C  4E75                    3825      RTS
0000A28E                          3826  
0000A28E                          3827  
0000A28E                          3828  ;************************************************************************************
0000A28E                          3829  ;
0000A28E                          3830  ; perform FRE()
0000A28E                          3831  
0000A28E                          3832  LAB_FRE
0000A28E  4A2B 05B5               3833      TST.b       Dtypef(a3)              ; test data type, $80=string, $40=integer,
0000A292                          3834                                  ; $00=float
0000A292  6A04                    3835      BPL.s       LAB_1FB4                ; branch if numeric
0000A294                          3836  
0000A294  6100 0318               3837      BSR     LAB_22B6                ; pop string off descriptor stack, or from
0000A298                          3838                                  ; top of string space, returns d0 = length,
0000A298                          3839                                  ; a0 = pointer
0000A298                          3840  
0000A298                          3841                                  ; FRE(n) was numeric so do this
0000A298                          3842  LAB_1FB4
0000A298  6100 01CC               3843      BSR     LAB_GARB                ; go do garbage collection
0000A29C  202B 0446               3844      MOVE.l  Sstorl(a3),d0           ; get bottom of string space
0000A2A0  90AB 0442               3845      SUB.l       Earryl(a3),d0           ; subtract array mem end
0000A2A4                          3846  
0000A2A4                          3847  
0000A2A4                          3848  ;************************************************************************************
0000A2A4                          3849  ;
0000A2A4                          3850  ; convert d0 to signed longword in FAC1
0000A2A4                          3851  
0000A2A4                          3852  LAB_AYFC
0000A2A4  177C 0000 05B5          3853      MOVE.b  #$00,Dtypef(a3)         ; clear data type, $80=string, $40=integer,
0000A2AA                          3854                                  ; $00=float
0000A2AA  377C A000 0594          3855      MOVE.w  #$A000,FAC1_e(a3)           ; set FAC1 exponent and clear sign (b7)
0000A2B0  2740 0590               3856      MOVE.l  d0,FAC1_m(a3)           ; save FAC1 mantissa
0000A2B4  6A00 0640               3857      BPL     LAB_24D0                ; convert if +ve
0000A2B8                          3858  
0000A2B8  003C 0001               3859      ORI.b       #1,CCR              ; else set carry
0000A2BC  6000 0638               3860      BRA     LAB_24D0                ; do +/- (carry is sign) & normalise FAC1
0000A2C0                          3861  
0000A2C0                          3862  
0000A2C0                          3863  ;************************************************************************************
0000A2C0                          3864  ;
0000A2C0                          3865  ; remember if the line length is zero (infinite line) then POS(n) will return
0000A2C0                          3866  ; position MOD tabsize
0000A2C0                          3867  
0000A2C0                          3868  ; perform POS()
0000A2C0                          3869  
0000A2C0                          3870  LAB_POS
0000A2C0  102B 05E5               3871      MOVE.b  TPos(a3),d0             ; get terminal position
0000A2C4                          3872  
0000A2C4                          3873  ; convert d0 to unsigned byte in FAC1
0000A2C4                          3874  
0000A2C4                          3875  LAB_1FD0
0000A2C4  C0BC 000000FF           3876      AND.l       #$FF,d0             ; clear high bits
0000A2CA  60D8                    3877      BRA.s       LAB_AYFC                ; convert d0 to signed longword in FAC1 & RET
0000A2CC                          3878  
0000A2CC                          3879  ; check not direct (used by DEF and INPUT)
0000A2CC                          3880  
0000A2CC                          3881  LAB_CKRN
0000A2CC  4A2B 0452               3882      TST.b       Clinel(a3)              ; test current line #
0000A2D0  6B00 EE60               3883      BMI     LAB_IDER                ; if -ve go do illegal direct error then warm
0000A2D4                          3884                                  ; start
0000A2D4                          3885  
0000A2D4  4E75                    3886      RTS                         ; can continue so return
0000A2D6                          3887  
0000A2D6                          3888  
0000A2D6                          3889  ;************************************************************************************
0000A2D6                          3890  ;
0000A2D6                          3891  ; perform DEF
0000A2D6                          3892  
0000A2D6                          3893  LAB_DEF
0000A2D6  70AB                    3894      MOVEQ       #TK_FN-$100,d0          ; get FN token
0000A2D8  6100 FAC0               3895      BSR     LAB_SCCA                ; scan for CHR$(d0), else syntax error and
0000A2DC                          3896                                  ; warm start
0000A2DC                          3897                                  ; return character after d0
0000A2DC  177C 0080 05DF          3898      MOVE.b  #$80,Sufnxf(a3)         ; set FN flag bit
0000A2E2  6100 FCDA               3899      BSR     LAB_1D12                ; get FN name
0000A2E6  2748 05B0               3900      MOVE.l  a0,func_l(a3)           ; save function pointer
0000A2EA                          3901  
0000A2EA  61E0                    3902      BSR.s       LAB_CKRN                ; check not direct (back here if ok)
0000A2EC  0C1D 0028               3903      CMP.b       #$28,(a5)+              ; check next byte is "(" and increment
0000A2F0  6600 EE68               3904      BNE     LAB_SNER                ; else do syntax error/warm start
0000A2F4                          3905  
0000A2F4  177C 007E 05DF          3906      MOVE.b  #$7E,Sufnxf(a3)         ; set FN variable flag bits
0000A2FA  6100 FCB4               3907      BSR     LAB_SVAR                ; search for or create a variable
0000A2FE                          3908                                  ; return the variable address in a0
0000A2FE  6100 FA90               3909      BSR     LAB_1BFB                ; scan for ")", else do syntax error/warm start
0000A302  70BD                    3910      MOVEQ       #TK_EQUAL-$100,d0           ; = token
0000A304  6100 FA94               3911      BSR     LAB_SCCA                ; scan for CHR$(A), else syntax error/warm start
0000A308                          3912                                  ; return character after d0
0000A308  2F2B 046A               3913      MOVE.l  Varname(a3),-(sp)           ; push current variable name
0000A30C  2F0D                    3914      MOVE.l  a5,-(sp)                ; push BASIC execute pointer
0000A30E  6100 F410               3915      BSR     LAB_DATA                ; go perform DATA, find end of DEF FN statement
0000A312  206B 05B0               3916      MOVEA.l func_l(a3),a0           ; get the function pointer
0000A316  209F                    3917      MOVE.l  (sp)+,(a0)              ; save BASIC execute pointer to function
0000A318  215F 0004               3918      MOVE.l  (sp)+,4(a0)             ; save current variable name to function
0000A31C  4E75                    3919      RTS
0000A31E                          3920  
0000A31E                          3921  
0000A31E                          3922  ;************************************************************************************
0000A31E                          3923  ;
0000A31E                          3924  ; evaluate FNx
0000A31E                          3925  
0000A31E                          3926  LAB_201E
0000A31E  177C 0081 05DF          3927      MOVE.b  #$81,Sufnxf(a3)         ; set FN flag (find not create)
0000A324  6100 FA7C               3928      BSR     LAB_IGBY                ; increment & scan memory
0000A328  6100 FC94               3929      BSR     LAB_1D12                ; get FN name
0000A32C  1F2B 05B5               3930      MOVE.b  Dtypef(a3),-(sp)            ; push data type flag (function type)
0000A330  2F08                    3931      MOVE.l  a0,-(sp)                ; push function pointer
0000A332  0C15 0028               3932      CMP.b       #$28,(a5)               ; check next byte is "(", no increment
0000A336  6600 EE22               3933      BNE     LAB_SNER                ; else do syntax error/warm start
0000A33A                          3934  
0000A33A  6100 FA50               3935      BSR     LAB_1BF7                ; evaluate expression within parentheses
0000A33E  205F                    3936      MOVEA.l (sp)+,a0                ; pop function pointer
0000A340  2748 05B0               3937      MOVE.l  a0,func_l(a3)           ; set function pointer
0000A344  1F2B 05B5               3938      MOVE.b  Dtypef(a3),-(sp)            ; push data type flag (function expression type)
0000A348                          3939  
0000A348  2028 0004               3940      MOVE.l  4(a0),d0                ; get function variable name
0000A34C  6100 FCDA               3941      BSR     LAB_1D4A                ; go find function variable (already created)
0000A350                          3942  
0000A350                          3943                                  ; now check type match for variable
0000A350  101F                    3944      MOVE.b  (sp)+,d0                ; pop data type flag (function expression type)
0000A352  E318                    3945      ROL.b       #1,d0                   ; set carry if type = string
0000A354  6100 F8D8               3946      BSR     LAB_CKTM                ; type match check, set C for string
0000A358                          3947  
0000A358                          3948                                  ; now stack the function variable value before
0000A358                          3949                                  ; use
0000A358  6712                    3950      BEQ.s       LAB_2043                ; branch if not string
0000A35A                          3951  
0000A35A  43EB 0476               3952      LEA     des_sk_e(a3),a1         ; get string stack pointer max+1
0000A35E  B9C9                    3953      CMPA.l  a1,a4                   ; compare string stack pointer with max+1
0000A360  6700 EDC4               3954      BEQ     LAB_SCER                ; if no space on the stack go do string too
0000A364                          3955                                  ; complex error
0000A364                          3956  
0000A364  3928 0004               3957      MOVE.w  4(a0),-(a4)             ; string length on descriptor stack
0000A368  2910                    3958      MOVE.l  (a0),-(a4)              ; string address on stack
0000A36A  6002                    3959      BRA.s       LAB_204S                ; skip var push
0000A36C                          3960  
0000A36C                          3961  LAB_2043
0000A36C  2F10                    3962      MOVE.l  (a0),-(sp)              ; push variable
0000A36E                          3963  LAB_204S
0000A36E  2F08                    3964      MOVE.l  a0,-(sp)                ; push variable address
0000A370  1F2B 05B5               3965      MOVE.b  Dtypef(a3),-(sp)            ; push variable data type
0000A374                          3966  
0000A374  6132                    3967      BSR.s       LAB_2045                ; pack function expression value into (a0)
0000A376                          3968                                  ; (function variable)
0000A376  2F0D                    3969      MOVE.l  a5,-(sp)                ; push BASIC execute pointer
0000A378  206B 05B0               3970      MOVEA.l func_l(a3),a0           ; get function pointer
0000A37C  2A50                    3971      MOVEA.l (a0),a5             ; save function execute ptr as BASIC execute ptr
0000A37E  6100 F8C2               3972      BSR     LAB_EVEX                ; evaluate expression
0000A382  6100 FA20               3973      BSR     LAB_GBYT                ; scan memory
0000A386  6600 EDD2               3974      BNE     LAB_SNER                ; if not [EOL] or [EOS] do syntax error and
0000A38A                          3975                                  ; warm start
0000A38A                          3976  
0000A38A  2A5F                    3977      MOVE.l  (sp)+,a5                ; restore BASIC execute pointer
0000A38C                          3978  
0000A38C                          3979  ; restore variable from stack and test data type
0000A38C                          3980  
0000A38C  101F                    3981      MOVE.b  (sp)+,d0                ; pull variable data type
0000A38E  205F                    3982      MOVEA.l (sp)+,a0                ; pull variable address
0000A390  4A00                    3983      TST.b       d0                  ; test variable data type
0000A392  6A08                    3984      BPL.s       LAB_204T                ; branch if not string
0000A394                          3985  
0000A394  209C                    3986      MOVE.l  (a4)+,(a0)              ; string address from descriptor stack
0000A396  315C 0004               3987      MOVE.w  (a4)+,4(a0)             ; string length from descriptor stack
0000A39A  6002                    3988      BRA.s       LAB_2044                ; skip variable pull
0000A39C                          3989  
0000A39C                          3990  LAB_204T
0000A39C  209F                    3991      MOVE.l  (sp)+,(a0)              ; restore variable from stack
0000A39E                          3992  LAB_2044
0000A39E  101F                    3993      MOVE.b  (sp)+,d0                ; pop data type flag (function type)
0000A3A0  E318                    3994      ROL.b       #1,d0                   ; set carry if type = string
0000A3A2  6100 F88A               3995      BSR     LAB_CKTM                ; type match check, set C for string
0000A3A6  4E75                    3996      RTS
0000A3A8                          3997  
0000A3A8                          3998  LAB_2045
0000A3A8  4A2B 05B5               3999      TST.b       Dtypef(a3)              ; test data type
0000A3AC  6A00 07F0               4000      BPL     LAB_2778                ; if numeric pack FAC1 into variable (a0)
0000A3B0                          4001                                  ; and return
0000A3B0                          4002  
0000A3B0  2448                    4003      MOVEA.l a0,a2                   ; copy variable pointer
0000A3B2  6000 F510               4004      BRA     LAB_17D6                ; go do string LET & return
0000A3B6                          4005  
0000A3B6                          4006  
0000A3B6                          4007  
0000A3B6                          4008  ;************************************************************************************
0000A3B6                          4009  ;
0000A3B6                          4010  ; perform STR$()
0000A3B6                          4011  
0000A3B6                          4012  LAB_STRS
0000A3B6  6100 0950               4013      BSR     LAB_2970                ; convert FAC1 to string
0000A3BA                          4014  
0000A3BA                          4015  ; scan, set up string
0000A3BA                          4016  ; print " terminated string to FAC1 stack
0000A3BA                          4017  
0000A3BA                          4018  LAB_20AE
0000A3BA  7422                    4019      MOVEQ       #$22,d2             ; set Srchc character (terminator 1)
0000A3BC  3602                    4020      MOVE.w  d2,d3                   ; set Asrch character (terminator 2)
0000A3BE                          4021  
0000A3BE                          4022  ; print d2/d3 terminated string to FAC1 stack
0000A3BE                          4023  ; d2 = Srchc, d3 = Asrch, a0 is source
0000A3BE                          4024  ; a6 is temp
0000A3BE                          4025  
0000A3BE                          4026  LAB_20B4
0000A3BE  7200                    4027      MOVEQ       #0,d1                   ; clear longword
0000A3C0  5341                    4028      SUBQ.w  #1,d1                   ; set length to -1
0000A3C2  2448                    4029      MOVEA.l a0,a2                   ; copy start to calculate end
0000A3C4                          4030  LAB_20BE
0000A3C4  5241                    4031      ADDQ.w  #1,d1                   ; increment length
0000A3C6  1030 1000               4032      MOVE.b  (a0,d1.w),d0            ; get byte from string
0000A3CA  6710                    4033      BEQ.s       LAB_20D0                ; exit loop if null byte [EOS]
0000A3CC                          4034  
0000A3CC  B002                    4035      CMP.b       d2,d0                   ; compare with search character (terminator 1)
0000A3CE  6704                    4036      BEQ.s       LAB_20CB                ; branch if terminator
0000A3D0                          4037  
0000A3D0  B003                    4038      CMP.b       d3,d0                   ; compare with terminator 2
0000A3D2  66F0                    4039      BNE.s       LAB_20BE                ; loop if not terminator 2 (or null string)
0000A3D4                          4040  
0000A3D4                          4041  LAB_20CB
0000A3D4  B03C 0022               4042      CMP.b       #$22,d0             ; compare with "
0000A3D8  6602                    4043      BNE.s       LAB_20D0                ; branch if not "
0000A3DA                          4044  
0000A3DA  524A                    4045      ADDQ.w  #1,a2                   ; else increment string start (skip " at end)
0000A3DC                          4046  LAB_20D0
0000A3DC  D5C1                    4047      ADDA.l  d1,a2                   ; add longowrd length to make string end+1
0000A3DE                          4048  
0000A3DE  B1CB                    4049      CMPA.l  a3,a0                   ; is string in ram
0000A3E0  651E                    4050      BCS.s       LAB_RTST                ; if not go push descriptor on stack & exit
0000A3E2                          4051                                  ; (could be message string from ROM)
0000A3E2                          4052  
0000A3E2  B1EB 042E               4053      CMPA.l  Smeml(a3),a0            ; is string in utility ram
0000A3E6  6418                    4054      BCC.s       LAB_RTST                ; if not go push descriptor on stack & exit
0000A3E8                          4055                                  ; (is in string or program space)
0000A3E8                          4056  
0000A3E8                          4057                                  ; (else) copy string to string memory
0000A3E8                          4058  LAB_20C9
0000A3E8  2248                    4059      MOVEA.l a0,a1                   ; copy descriptor pointer
0000A3EA  2001                    4060      MOVE.l  d1,d0                   ; copy longword length
0000A3EC  6604                    4061      BNE.s       LAB_20D8                ; branch if not null string
0000A3EE                          4062  
0000A3EE  2041                    4063      MOVEA.l d1,a0                   ; make null pointer
0000A3F0  600E                    4064      BRA.s       LAB_RTST                ; go push descriptor on stack & exit
0000A3F2                          4065  
0000A3F2                          4066  LAB_20D8
0000A3F2  6126                    4067      BSR.s       LAB_2115                ; make string space d1 bytes long
0000A3F4  D1C1                    4068      ADDA.l  d1,a0                   ; new string end
0000A3F6  D3C1                    4069      ADDA.l  d1,a1                   ; old string end
0000A3F8  5340                    4070      SUBQ.w  #1,d0                   ; -1 for DBF loop
0000A3FA                          4071  LAB_20E0
0000A3FA  1121                    4072      MOVE.b  -(a1),-(a0)             ; copy byte (source can be odd aligned)
0000A3FC  51C8 FFFC               4073      DBF     d0,LAB_20E0             ; loop until done
0000A400                          4074  
0000A400                          4075  
0000A400                          4076  
0000A400                          4077  ;************************************************************************************
0000A400                          4078  ;
0000A400                          4079  ; check for space on descriptor stack then ...
0000A400                          4080  ; put string address and length on descriptor stack & update stack pointers
0000A400                          4081  ; start is in a0, length is in d1
0000A400                          4082  
0000A400                          4083  LAB_RTST
0000A400  43EB 0476               4084      LEA     des_sk_e(a3),a1         ; get string stack pointer max+1
0000A404  B9C9                    4085      CMPA.l  a1,a4                   ; compare string stack pointer with max+1
0000A406  6700 ED1E               4086      BEQ     LAB_SCER                ; if no space on string stack ..
0000A40A                          4087                                  ; .. go do 'string too complex' error
0000A40A                          4088  
0000A40A                          4089                                  ; push string & update pointers
0000A40A  3901                    4090      MOVE.w  d1,-(a4)                ; string length on descriptor stack
0000A40C  2908                    4091      MOVE.l  a0,-(a4)                ; string address on stack
0000A40E  274C 0590               4092      MOVE.l  a4,FAC1_m(a3)           ; string descriptor pointer in FAC1
0000A412  177C 0080 05B5          4093      MOVE.b  #$80,Dtypef(a3)         ; save data type flag, $80=string
0000A418  4E75                    4094      RTS
0000A41A                          4095  
0000A41A                          4096  
0000A41A                          4097  ;************************************************************************************
0000A41A                          4098  ;
0000A41A                          4099  ; build descriptor a0/d1
0000A41A                          4100  ; make space in string memory for string d1.w long
0000A41A                          4101  ; return pointer in a0/Sutill
0000A41A                          4102  
0000A41A                          4103  LAB_2115
0000A41A  4A41                    4104      TST.w       d1                  ; test length
0000A41C  672E                    4105      BEQ.s       LAB_2128                ; branch if user wants null string
0000A41E                          4106  
0000A41E                          4107                                  ; make space for string d1 long
0000A41E  2F00                    4108      MOVE.l  d0,-(sp)                ; save d0
0000A420  7000                    4109      MOVEQ       #0,d0                   ; clear longword
0000A422  1740 05DE               4110      MOVE.b  d0,Gclctd(a3)           ; clear garbage collected flag (b7)
0000A426  7001                    4111      MOVEQ       #1,d0                   ; +1 to possibly round up
0000A428  C041                    4112      AND.w       d1,d0                   ; mask odd bit
0000A42A  D041                    4113      ADD.w       d1,d0                   ; ensure d0 is even length
0000A42C  6404                    4114      BCC.s       LAB_2117                ; branch if no overflow
0000A42E                          4115  
0000A42E  7001                    4116      MOVEQ       #1,d0                   ; set to allocate 65536 bytes
0000A430  4840                    4117      SWAP        d0                  ; makes $00010000
0000A432                          4118  LAB_2117
0000A432  206B 0446               4119      MOVEA.l Sstorl(a3),a0           ; get bottom of string space
0000A436  91C0                    4120      SUBA.l  d0,a0                   ; subtract string length
0000A438  B1EB 0442               4121      CMPA.l  Earryl(a3),a0           ; compare with top of array space
0000A43C  6512                    4122      BCS.s       LAB_2137                ; if less do out of memory error
0000A43E                          4123  
0000A43E  2748 0446               4124      MOVE.l  a0,Sstorl(a3)           ; save bottom of string space
0000A442  2748 044E               4125      MOVE.l  a0,Sutill(a3)           ; save string utility pointer
0000A446  201F                    4126      MOVE.l  (sp)+,d0                ; restore d0
0000A448  4A41                    4127      TST.w       d1                  ; set flags on length
0000A44A  4E75                    4128      RTS
0000A44C                          4129  
0000A44C                          4130  LAB_2128
0000A44C  3041                    4131      MOVEA.w d1,a0                   ; make null pointer
0000A44E  4E75                    4132      RTS
0000A450                          4133  
0000A450                          4134  LAB_2137
0000A450  4A2B 05DE               4135      TST.b       Gclctd(a3)              ; get garbage collected flag
0000A454  6B00 ECF0               4136      BMI     LAB_OMER                ; do "Out of memory" error, then warm start
0000A458                          4137  
0000A458  2F09                    4138      MOVE.l  a1,-(sp)                ; save a1
0000A45A  610A                    4139      BSR.s       LAB_GARB                ; else go do garbage collection
0000A45C  225F                    4140      MOVEA.l (sp)+,a1                ; restore a1
0000A45E  177C 0080 05DE          4141      MOVE.b  #$80,Gclctd(a3)         ; set garbage collected flag
0000A464  60CC                    4142      BRA.s       LAB_2117                ; go try again
0000A466                          4143  
0000A466                          4144  
0000A466                          4145  ;************************************************************************************
0000A466                          4146  ;
0000A466                          4147  ; garbage collection routine
0000A466                          4148  
0000A466                          4149  LAB_GARB
0000A466  48E7 E0E0               4150      MOVEM.l d0-d2/a0-a2,-(sp)           ; save registers
0000A46A  276B 044A 0446          4151      MOVE.l  Ememl(a3),Sstorl(a3)        ; start with no strings
0000A470                          4152  
0000A470                          4153                                  ; re-run routine from last ending
0000A470                          4154  LAB_214B
0000A470  222B 0442               4155      MOVE.l  Earryl(a3),d1           ; set highest uncollected string so far
0000A474  7000                    4156      MOVEQ       #0,d0                   ; clear longword
0000A476  2240                    4157      MOVEA.l d0,a1                   ; clear string to move pointer
0000A478  206B 043A               4158      MOVEA.l Sstrl(a3),a0            ; set pointer to start of strings
0000A47C  41E8 0004               4159      LEA     4(a0),a0                ; index to string pointer
0000A480  246B 043E               4160      MOVEA.l Sarryl(a3),a2           ; set end pointer to start of arrays (end of
0000A484                          4161                                  ; strings)
0000A484  6008                    4162      BRA.s       LAB_2176                ; branch into loop at end loop test
0000A486                          4163  
0000A486                          4164  LAB_2161
0000A486  6100 0084               4165      BSR     LAB_2206                ; test and set if this is the highest string
0000A48A  41E8 000A               4166      LEA     10(a0),a0               ; increment to next string
0000A48E                          4167  LAB_2176
0000A48E  B1CA                    4168      CMPA.l  a2,a0                   ; compare end of area with pointer
0000A490  65F4                    4169      BCS.s       LAB_2161                ; go do next if not at end
0000A492                          4170  
0000A492                          4171  ; done strings, now do arrays.
0000A492                          4172  
0000A492  41E8 FFFC               4173      LEA     -4(a0),a0               ; decrement pointer to start of arrays
0000A496  246B 0442               4174      MOVEA.l Earryl(a3),a2           ; set end pointer to end of arrays
0000A49A  6024                    4175      BRA.s       LAB_218F                ; branch into loop at end loop test
0000A49C                          4176  
0000A49C                          4177  LAB_217E
0000A49C  2428 0004               4178      MOVE.l  4(a0),d2                ; get array size
0000A4A0  D488                    4179      ADD.l       a0,d2                   ; makes start of next array
0000A4A2                          4180  
0000A4A2  2010                    4181      MOVE.l  (a0),d0             ; get array name
0000A4A4  0800 0017               4182      BTST        #23,d0              ; test string flag
0000A4A8  6714                    4183      BEQ.s       LAB_218B                ; branch if not string
0000A4AA                          4184  
0000A4AA  3028 0008               4185      MOVE.w  8(a0),d0                ; get # of dimensions
0000A4AE  D040                    4186      ADD.w       d0,d0                   ; *2
0000A4B0  D0C0                    4187      ADDA.w  d0,a0                   ; add to skip dimension size(s)
0000A4B2  41E8 000A               4188      LEA     10(a0),a0               ; increment to first element
0000A4B6                          4189  LAB_2183
0000A4B6  6154                    4190      BSR.s       LAB_2206                ; test and set if this is the highest string
0000A4B8  5C48                    4191      ADDQ.w  #6,a0                   ; increment to next element
0000A4BA  B1C2                    4192      CMPA.l  d2,a0                   ; compare with start of next array
0000A4BC  66F8                    4193      BNE.s       LAB_2183                ; go do next if not at end of array
0000A4BE                          4194  
0000A4BE                          4195  LAB_218B
0000A4BE  2042                    4196      MOVEA.l d2,a0                   ; pointer to next array
0000A4C0                          4197  LAB_218F
0000A4C0  B5C8                    4198      CMPA.l  a0,a2                   ; compare pointer with array end
0000A4C2  66D8                    4199      BNE.s       LAB_217E                ; go do next if not at end
0000A4C4                          4200  
0000A4C4                          4201  ; done arrays and variables, now just the descriptor stack to do
0000A4C4                          4202  
0000A4C4  204C                    4203      MOVEA.l a4,a0                   ; get descriptor stack pointer
0000A4C6  45EB 048E               4204      LEA     des_sk(a3),a2           ; set end pointer to end of stack
0000A4CA  6006                    4205      BRA.s       LAB_21C4                ; branch into loop at end loop test
0000A4CC                          4206  
0000A4CC                          4207  LAB_21C2
0000A4CC  613E                    4208      BSR.s       LAB_2206                ; test and set if this is the highest string
0000A4CE  41E8 0006               4209      LEA     6(a0),a0                ; increment to next string
0000A4D2                          4210  LAB_21C4
0000A4D2  B5C8                    4211      CMPA.l  a0,a2                   ; compare pointer with stack end
0000A4D4  66F6                    4212      BNE.s       LAB_21C2                ; go do next if not at end
0000A4D6                          4213  
0000A4D6                          4214  ; descriptor search complete, now either exit or set-up and move string
0000A4D6                          4215  
0000A4D6  2009                    4216      MOVE.l  a1,d0                   ; set the flags (a1 is move string)
0000A4D8  672C                    4217      BEQ.s       LAB_21D1                ; go tidy up and exit if no move
0000A4DA                          4218  
0000A4DA  2051                    4219      MOVEA.l (a1),a0             ; a0 is now string start
0000A4DC  7200                    4220      MOVEQ       #0,d1                   ; clear d1
0000A4DE  3229 0004               4221      MOVE.w  4(a1),d1                ; d1 is string length
0000A4E2  5281                    4222      ADDQ.l  #1,d1                   ; +1
0000A4E4  C23C 00FE               4223      AND.b       #$FE,d1             ; make even length
0000A4E8  D1C1                    4224      ADDA.l  d1,a0                   ; pointer is now to string end+1
0000A4EA  246B 0446               4225      MOVEA.l Sstorl(a3),a2           ; is destination end+1
0000A4EE  B1CA                    4226      CMPA.l  a2,a0                   ; does the string need moving
0000A4F0  670C                    4227      BEQ.s       LAB_2240                ; branch if not
0000A4F2                          4228  
0000A4F2  E289                    4229      LSR.l       #1,d1                   ; word move so do /2
0000A4F4  5341                    4230      SUBQ.w  #1,d1                   ; -1 for DBF loop
0000A4F6                          4231  LAB_2216
0000A4F6  3520                    4232      MOVE.w  -(a0),-(a2)             ; copy word
0000A4F8  51C9 FFFC               4233      DBF     d1,LAB_2216             ; loop until done
0000A4FC                          4234  
0000A4FC  228A                    4235      MOVE.l  a2,(a1)             ; save new string start
0000A4FE                          4236  LAB_2240
0000A4FE  2751 0446               4237      MOVE.l  (a1),Sstorl(a3)         ; string start is new string mem start
0000A502  6000 FF6C               4238      BRA     LAB_214B                ; re-run routine from last ending
0000A506                          4239                                  ; (but don't collect this string)
0000A506                          4240  
0000A506                          4241  LAB_21D1
0000A506  4CDF 0707               4242      MOVEM.l (sp)+,d0-d2/a0-a2           ; restore registers
0000A50A  4E75                    4243      RTS
0000A50C                          4244  
0000A50C                          4245  ; test and set if this is the highest string
0000A50C                          4246  
0000A50C                          4247  LAB_2206
0000A50C  2010                    4248      MOVE.l  (a0),d0             ; get this string pointer
0000A50E  6728                    4249      BEQ.s       RTS_012             ; exit if null string
0000A510                          4250  
0000A510  B280                    4251      CMP.l       d0,d1                   ; compare with highest uncollected string so far
0000A512  6424                    4252      BCC.s       RTS_012             ; exit if <= with highest so far
0000A514                          4253  
0000A514  B0AB 0446               4254      CMP.l       Sstorl(a3),d0           ; compare with bottom of string space
0000A518  641E                    4255      BCC.s       RTS_012             ; exit if >= bottom of string space
0000A51A                          4256  
0000A51A  70FF                    4257      MOVEQ       #-1,d0              ; d0 = $FFFFFFFF
0000A51C  3028 0004               4258      MOVE.w  4(a0),d0                ; d0 is string length
0000A520  4440                    4259      NEG.w       d0                  ; make -ve
0000A522  C03C 00FE               4260      AND.b       #$FE,d0             ; make -ve even length
0000A526  D0AB 0446               4261      ADD.l       Sstorl(a3),d0           ; add string store to -ve length
0000A52A  B090                    4262      CMP.l       (a0),d0             ; compare with string address
0000A52C  6706                    4263      BEQ.s       LAB_2212                ; if = go move string store pointer down
0000A52E                          4264  
0000A52E  2210                    4265      MOVE.l  (a0),d1             ; highest = current
0000A530  2248                    4266      MOVEA.l a0,a1                   ; string to move = current
0000A532  4E75                    4267      RTS
0000A534                          4268  
0000A534                          4269  LAB_2212
0000A534  2740 0446               4270      MOVE.l  d0,Sstorl(a3)           ; set new string store start
0000A538                          4271  RTS_012
0000A538  4E75                    4272      RTS
0000A53A                          4273  
0000A53A                          4274  
0000A53A                          4275  ;************************************************************************************
0000A53A                          4276  ;
0000A53A                          4277  ; concatenate - add strings
0000A53A                          4278  ; string descriptor 1 is in FAC1_m, string 2 is in line
0000A53A                          4279  
0000A53A                          4280  LAB_224D
0000A53A  487A F738               4281      PEA     LAB_1ADB(pc)            ; continue evaluation after concatenate
0000A53E  2F2B 0590               4282      MOVE.l  FAC1_m(a3),-(sp)            ; stack descriptor pointer for string 1
0000A542                          4283  
0000A542  6100 F80C               4284      BSR     LAB_GVAL                ; get value from line
0000A546  4A2B 05B5               4285      TST.b       Dtypef(a3)              ; test data type flag
0000A54A  6A00 EBE2               4286      BPL     LAB_TMER                ; if type is not string do type mismatch error
0000A54E                          4287  
0000A54E  205F                    4288      MOVEA.l (sp)+,a0                ; restore descriptor pointer for string 1
0000A550                          4289  
0000A550                          4290  ;************************************************************************************
0000A550                          4291  ;
0000A550                          4292  ; concatenate
0000A550                          4293  ; string descriptor 1 is in a0, string descriptor 2 is in FAC1_m
0000A550                          4294  
0000A550                          4295  LAB_224E
0000A550  226B 0590               4296      MOVEA.l FAC1_m(a3),a1           ; copy descriptor pointer 2
0000A554  3228 0004               4297      MOVE.w  4(a0),d1                ; get length 1
0000A558  D269 0004               4298      ADD.w       4(a1),d1                ; add length 2
0000A55C  6500 EBCC               4299      BCS     LAB_SLER                ; if overflow go do 'string too long' error
0000A560                          4300  
0000A560  2F08                    4301      MOVE.l  a0,-(sp)                ; save descriptor pointer 1
0000A562  6100 FEB6               4302      BSR     LAB_2115                ; make space d1 bytes long
0000A566  2748 0598               4303      MOVE.l  a0,FAC2_m(a3)           ; save new string start pointer
0000A56A  2057                    4304      MOVEA.l (sp),a0             ; copy descriptor pointer 1 from stack
0000A56C  3028 0004               4305      MOVE.w  4(a0),d0                ; get length
0000A570  2050                    4306      MOVEA.l (a0),a0             ; get string pointer
0000A572  6120                    4307      BSR.s       LAB_229E                ; copy string d0 bytes long from a0 to Sutill
0000A574                          4308                                  ; return with a0 = pointer, d1 = length
0000A574                          4309  
0000A574  206B 0590               4310      MOVEA.l FAC1_m(a3),a0           ; get descriptor pointer for string 2
0000A578  6138                    4311      BSR.s       LAB_22BA                ; pop (a0) descriptor, returns with ..
0000A57A                          4312                                  ; a0 = pointer, d0 = length
0000A57A  6118                    4313      BSR.s       LAB_229E                ; copy string d0 bytes long from a0 to Sutill
0000A57C                          4314                                  ; return with a0 = pointer, d1 = length
0000A57C                          4315  
0000A57C  205F                    4316      MOVEA.l (sp)+,a0                ; get descriptor pointer for string 1
0000A57E  6132                    4317      BSR.s       LAB_22BA                ; pop (a0) descriptor, returns with ..
0000A580                          4318                                  ; d0 = length, a0 = pointer
0000A580                          4319  
0000A580  206B 0598               4320      MOVEA.l FAC2_m(a3),a0           ; retreive the result string pointer
0000A584  2208                    4321      MOVE.l  a0,d1                   ; copy the result string pointer
0000A586  6700 FE78               4322      BEQ     LAB_RTST                ; if it is a null string just return it
0000A58A                          4323                                  ; a0 = pointer, d1 = length
0000A58A                          4324  
0000A58A  4481                    4325      NEG.l       d1                  ; else make the start pointer negative
0000A58C  D2AB 044E               4326      ADD.l       Sutill(a3),d1           ; add the end pointert to give the length
0000A590  6000 FE6E               4327      BRA     LAB_RTST                ; push string on descriptor stack
0000A594                          4328                                  ; a0 = pointer, d1 = length
0000A594                          4329  
0000A594                          4330  
0000A594                          4331  ;************************************************************************************
0000A594                          4332  ;
0000A594                          4333  ; copy string d0 bytes long from a0 to Sutill
0000A594                          4334  ; return with a0 = pointer, d1 = length
0000A594                          4335  
0000A594                          4336  LAB_229E
0000A594  3200                    4337      MOVE.w  d0,d1                   ; copy and check length
0000A596  6714                    4338      BEQ.s       RTS_013             ; skip copy if null
0000A598                          4339  
0000A598  226B 044E               4340      MOVEA.l Sutill(a3),a1           ; get destination pointer
0000A59C  2F09                    4341      MOVE.l  a1,-(sp)                ; save destination string pointer
0000A59E  5340                    4342      SUBQ.w  #1,d0                   ; subtract for DBF loop
0000A5A0                          4343  LAB_22A0
0000A5A0  12D8                    4344      MOVE.b  (a0)+,(a1)+             ; copy byte
0000A5A2  51C8 FFFC               4345      DBF     d0,LAB_22A0             ; loop if not done
0000A5A6                          4346  
0000A5A6  2749 044E               4347      MOVE.l  a1,Sutill(a3)           ; update Sutill to end of copied string
0000A5AA  205F                    4348      MOVEA.l (sp)+,a0                ; restore destination string pointer
0000A5AC                          4349  RTS_013
0000A5AC  4E75                    4350      RTS
0000A5AE                          4351  
0000A5AE                          4352  
0000A5AE                          4353  ;************************************************************************************
0000A5AE                          4354  ;
0000A5AE                          4355  ; pop string off descriptor stack, or from top of string space
0000A5AE                          4356  ; returns with d0.l = length, a0 = pointer
0000A5AE                          4357  
0000A5AE                          4358  LAB_22B6
0000A5AE  206B 0590               4359      MOVEA.l FAC1_m(a3),a0           ; get descriptor pointer
0000A5B2                          4360  
0000A5B2                          4361  
0000A5B2                          4362  ;************************************************************************************
0000A5B2                          4363  ;
0000A5B2                          4364  ; pop (a0) descriptor off stack or from string space
0000A5B2                          4365  ; returns with d0.l = length, a0 = pointer
0000A5B2                          4366  
0000A5B2                          4367  LAB_22BA
0000A5B2  48E7 4040               4368      MOVEM.l a1/d1,-(sp)             ; save other regs
0000A5B6  B9C8                    4369      CMPA.l  a0,a4                   ; is string on the descriptor stack
0000A5B8  6602                    4370      BNE.s       LAB_22BD                ; skip pop if not
0000A5BA                          4371  
0000A5BA  5C4C                    4372      ADDQ.w  #$06,a4             ; else update stack pointer
0000A5BC                          4373  LAB_22BD
0000A5BC  7000                    4374      MOVEQ       #0,d0                   ; clear string length longword
0000A5BE  2258                    4375      MOVEA.l (a0)+,a1                ; get string address
0000A5C0  3018                    4376      MOVE.w  (a0)+,d0                ; get string length
0000A5C2                          4377  
0000A5C2  B9C8                    4378      CMPA.l  a0,a4                   ; was it on the descriptor stack
0000A5C4  6610                    4379      BNE.s       LAB_22E6                ; branch if it wasn't
0000A5C6                          4380  
0000A5C6  B3EB 0446               4381      CMPA.l  Sstorl(a3),a1           ; compare string address with bottom of string
0000A5CA                          4382                                  ; space
0000A5CA  660A                    4383      BNE.s       LAB_22E6                ; branch if <>
0000A5CC                          4384  
0000A5CC  7201                    4385      MOVEQ       #1,d1                   ; mask for odd bit
0000A5CE  C240                    4386      AND.w       d0,d1                   ; AND length
0000A5D0  D280                    4387      ADD.l       d0,d1                   ; make it fit word aligned length
0000A5D2                          4388  
0000A5D2  D3AB 0446               4389      ADD.l       d1,Sstorl(a3)           ; add to bottom of string space
0000A5D6                          4390  LAB_22E6
0000A5D6  2049                    4391      MOVEA.l a1,a0                   ; copy to a0
0000A5D8  4CDF 0202               4392      MOVEM.l (sp)+,a1/d1             ; restore other regs
0000A5DC  4A80                    4393      TST.l       d0                  ; set flags on length
0000A5DE  4E75                    4394      RTS
0000A5E0                          4395  
0000A5E0                          4396  
0000A5E0                          4397  ;************************************************************************************
0000A5E0                          4398  ;
0000A5E0                          4399  ; perform CHR$()
0000A5E0                          4400  
0000A5E0                          4401  LAB_CHRS
0000A5E0  6100 0130               4402      BSR     LAB_EVBY                ; evaluate byte expression, result in d0 and
0000A5E4                          4403                                  ; Itemp
0000A5E4                          4404  LAB_MKCHR
0000A5E4  7201                    4405      MOVEQ       #1,d1                   ; string is single byte
0000A5E6  6100 FE32               4406      BSR     LAB_2115                ; make string space d1 bytes long
0000A5EA                          4407                                  ; return a0/Sutill = pointer, others unchanged
0000A5EA  1080                    4408      MOVE.b  d0,(a0)             ; save byte in string (byte IS string!)
0000A5EC  6000 FE12               4409      BRA     LAB_RTST                ; push string on descriptor stack
0000A5F0                          4410                                  ; a0 = pointer, d1 = length
0000A5F0                          4411  
0000A5F0                          4412  
0000A5F0                          4413  ;************************************************************************************
0000A5F0                          4414  ;
0000A5F0                          4415  ; perform LEFT$()
0000A5F0                          4416  
0000A5F0                          4417  ; enter with a0 is descriptor, d0 & Itemp is word 1
0000A5F0                          4418  
0000A5F0                          4419  LAB_LEFT
0000A5F0  C141                    4420      EXG     d0,d1                   ; word in d1
0000A5F2  6100 F79C               4421      BSR     LAB_1BFB                ; scan for ")", else do syntax error/warm start
0000A5F6                          4422  
0000A5F6  4A81                    4423      TST.l       d1                  ; test returned length
0000A5F8  6722                    4424      BEQ.s       LAB_231C                ; branch if null return
0000A5FA                          4425  
0000A5FA  7000                    4426      MOVEQ       #0,d0                   ; clear start offset
0000A5FC  B268 0004               4427      CMP.w       4(a0),d1                ; compare word parameter with string length
0000A600  651A                    4428      BCS.s       LAB_231C                ; branch if string length > word parameter
0000A602                          4429  
0000A602  6014                    4430      BRA.s       LAB_2317                ; go copy whole string
0000A604                          4431  
0000A604                          4432  
0000A604                          4433  ;************************************************************************************
0000A604                          4434  ;
0000A604                          4435  ; perform RIGHT$()
0000A604                          4436  
0000A604                          4437  ; enter with a0 is descriptor, d0 & Itemp is word 1
0000A604                          4438  
0000A604                          4439  LAB_RIGHT
0000A604  C141                    4440      EXG     d0,d1                   ; word in d1
0000A606  6100 F788               4441      BSR     LAB_1BFB                ; scan for ")", else do syntax error/warm start
0000A60A                          4442  
0000A60A  4A81                    4443      TST.l       d1                  ; test returned length
0000A60C  670E                    4444      BEQ.s       LAB_231C                ; branch if null return
0000A60E                          4445  
0000A60E  3028 0004               4446      MOVE.w  4(a0),d0                ; get string length
0000A612  9081                    4447      SUB.l       d1,d0                   ; subtract word
0000A614  6406                    4448      BCC.s       LAB_231C                ; branch if string length > word parameter
0000A616                          4449  
0000A616                          4450                                  ; else copy whole string
0000A616                          4451  LAB_2316
0000A616  7000                    4452      MOVEQ       #0,d0                   ; clear start offset
0000A618                          4453  LAB_2317
0000A618  3228 0004               4454      MOVE.w  4(a0),d1                ; else make parameter = length
0000A61C                          4455  
0000A61C                          4456  ; get here with ...
0000A61C                          4457  ;   a0 - points to descriptor
0000A61C                          4458  ;   d0 - is offset from string start
0000A61C                          4459  ;   d1 - is required string length
0000A61C                          4460  
0000A61C                          4461  LAB_231C
0000A61C  2248                    4462      MOVEA.l a0,a1                   ; save string descriptor pointer
0000A61E  6100 FDFA               4463      BSR     LAB_2115                ; make string space d1 bytes long
0000A622                          4464                                  ; return a0/Sutill = pointer, others unchanged
0000A622  2049                    4465      MOVEA.l a1,a0                   ; restore string descriptor pointer
0000A624  2F00                    4466      MOVE.l  d0,-(sp)                ; save start offset (longword)
0000A626  618A                    4467      BSR.s       LAB_22BA                ; pop (a0) descriptor, returns with ..
0000A628                          4468                                  ; d0 = length, a0 = pointer
0000A628  D1DF                    4469      ADDA.l  (sp)+,a0                ; adjust pointer to start of wanted string
0000A62A  3001                    4470      MOVE.w  d1,d0                   ; length to d0
0000A62C  6100 FF66               4471      BSR     LAB_229E                ; store string d0 bytes long from (a0) to
0000A630                          4472                                  ; (Sutill) return with a0 = pointer,
0000A630                          4473                                  ; d1 = length
0000A630  6000 FDCE               4474      BRA     LAB_RTST                ; push string on descriptor stack
0000A634                          4475                                  ; a0 = pointer, d1 = length
0000A634                          4476  
0000A634                          4477  
0000A634                          4478  ;************************************************************************************
0000A634                          4479  ;
0000A634                          4480  ; perform MID$()
0000A634                          4481  
0000A634                          4482  ; enter with a0 is descriptor, d0 & Itemp is word 1
0000A634                          4483  
0000A634                          4484  LAB_MIDS
0000A634  7E00                    4485      MOVEQ       #0,d7                   ; clear longword
0000A636  5347                    4486      SUBQ.w  #1,d7                   ; set default length = 65535
0000A638  2F00                    4487      MOVE.l  d0,-(sp)                ; save word 1
0000A63A  6100 F768               4488      BSR     LAB_GBYT                ; scan memory
0000A63E  B03C 002C               4489      CMP.b       #',',d0             ; was it ","
0000A642  660C                    4490      BNE.s       LAB_2358                ; branch if not "," (skip second byte get)
0000A644                          4491  
0000A644  101D                    4492      MOVE.b  (a5)+,d0                ; increment pointer past ","
0000A646  2F08                    4493      MOVE.l  a0,-(sp)                ; save descriptor pointer
0000A648  6100 00DA               4494      BSR     LAB_GTWO                ; get word parameter, result in d0 and Itemp
0000A64C  205F                    4495      MOVEA.l (sp)+,a0                ; restore descriptor pointer
0000A64E  2E00                    4496      MOVE.l  d0,d7                   ; copy length
0000A650                          4497  LAB_2358
0000A650  6100 F73E               4498      BSR     LAB_1BFB                ; scan for ")", else do syntax error then warm
0000A654                          4499                                  ; start
0000A654  201F                    4500      MOVE.l  (sp)+,d0                ; restore word 1
0000A656  7200                    4501      MOVEQ       #0,d1                   ; null length
0000A658  5380                    4502      SUBQ.l  #1,d0                   ; decrement start index (word 1)
0000A65A  6B00 EAF2               4503      BMI     LAB_FCER                ; if was null do function call error then warm
0000A65E                          4504                                  ; start
0000A65E                          4505  
0000A65E  B068 0004               4506      CMP.w       4(a0),d0                ; compare string length with start index
0000A662  64B8                    4507      BCC.s       LAB_231C                ; if start not in string do null string (d1=0)
0000A664                          4508  
0000A664  2207                    4509      MOVE.l  d7,d1                   ; get length back
0000A666  DE40                    4510      ADD.w       d0,d7                   ; d7 now = MID$() end
0000A668  6506                    4511      BCS.s       LAB_2368                ; already too long so do RIGHT$ equivalent
0000A66A                          4512  
0000A66A  BE68 0004               4513      CMP.w       4(a0),d7                ; compare string length with start index+length
0000A66E  65AC                    4514      BCS.s       LAB_231C                ; if end in string go do string
0000A670                          4515  
0000A670                          4516  LAB_2368
0000A670  3228 0004               4517      MOVE.w  4(a0),d1                ; get string length
0000A674  9240                    4518      SUB.w       d0,d1                   ; subtract start offset
0000A676  60A4                    4519      BRA.s       LAB_231C                ; go do string (effectively RIGHT$)
0000A678                          4520  
0000A678                          4521  
0000A678                          4522  ;************************************************************************************
0000A678                          4523  ;
0000A678                          4524  ; perform LCASE$()
0000A678                          4525  
0000A678                          4526  LAB_LCASE
0000A678  6100 FF34               4527      BSR     LAB_22B6                ; pop string off descriptor stack or from memory
0000A67C                          4528                                  ; returns with d0 = length, a0 = pointer
0000A67C  2200                    4529      MOVE.l  d0,d1                   ; copy the string length
0000A67E  6756                    4530      BEQ.s       NoString                ; if null go return a null string
0000A680                          4531  
0000A680                          4532  ; else copy and change the string
0000A680                          4533  
0000A680  2248                    4534      MOVEA.l a0,a1                   ; copy the string address
0000A682  6100 FD96               4535      BSR     LAB_2115                ; make a string space d1 bytes long
0000A686  D1C1                    4536      ADDA.l  d1,a0                   ; new string end
0000A688  D3C1                    4537      ADDA.l  d1,a1                   ; old string end
0000A68A  3401                    4538      MOVE.w  d1,d2                   ; copy length for loop
0000A68C  5342                    4539      SUBQ.w  #1,d2                   ; -1 for DBF loop
0000A68E                          4540  LC_loop
0000A68E  1021                    4541      MOVE.b  -(a1),d0                ; get byte from string
0000A690                          4542  
0000A690  B03C 005B               4543      CMP.b       #$5B,d0             ; compare with "Z"+1
0000A694  640A                    4544      BCC.s       NoUcase             ; if > "Z" skip change
0000A696                          4545  
0000A696  B03C 0041               4546      CMP.b       #$41,d0             ; compare with "A"
0000A69A  6504                    4547      BCS.s       NoUcase             ; if < "A" skip change
0000A69C                          4548  
0000A69C  0000 0020               4549      ORI.b       #$20,d0             ; convert upper case to lower case
0000A6A0                          4550  NoUcase
0000A6A0  1100                    4551      MOVE.b  d0,-(a0)                ; copy upper case byte back to string
0000A6A2  51CA FFEA               4552      DBF     d2,LC_loop              ; decrement and loop if not all done
0000A6A6                          4553  
0000A6A6  602E                    4554      BRA.s       NoString                ; tidy up & exit (branch always)
0000A6A8                          4555  
0000A6A8                          4556  
0000A6A8                          4557  ;************************************************************************************
0000A6A8                          4558  ;
0000A6A8                          4559  ; perform UCASE$()
0000A6A8                          4560  
0000A6A8                          4561  LAB_UCASE
0000A6A8  6100 FF04               4562      BSR     LAB_22B6                ; pop string off descriptor stack or from memory
0000A6AC                          4563                                  ; returns with d0 = length, a0 = pointer
0000A6AC  2200                    4564      MOVE.l  d0,d1                   ; copy the string length
0000A6AE  6726                    4565      BEQ.s       NoString                ; if null go return a null string
0000A6B0                          4566  
0000A6B0                          4567  ; else copy and change the string
0000A6B0                          4568  
0000A6B0  2248                    4569      MOVEA.l a0,a1                   ; copy the string address
0000A6B2  6100 FD66               4570      BSR     LAB_2115                ; make a string space d1 bytes long
0000A6B6  D1C1                    4571      ADDA.l  d1,a0                   ; new string end
0000A6B8  D3C1                    4572      ADDA.l  d1,a1                   ; old string end
0000A6BA  3401                    4573      MOVE.w  d1,d2                   ; copy length for loop
0000A6BC  5342                    4574      SUBQ.w  #1,d2                   ; -1 for DBF loop
0000A6BE                          4575  UC_loop
0000A6BE  1021                    4576      MOVE.b  -(a1),d0                ; get a byte from the string
0000A6C0                          4577  
0000A6C0  B03C 0061               4578      CMP.b       #$61,d0             ; compare with "a"
0000A6C4  650A                    4579      BCS.s       NoLcase             ; if < "a" skip change
0000A6C6                          4580  
0000A6C6  B03C 007B               4581      CMP.b       #$7B,d0             ; compare with "z"+1
0000A6CA  6404                    4582      BCC.s       NoLcase             ; if > "z" skip change
0000A6CC                          4583  
0000A6CC  0200 00DF               4584      ANDI.b  #$DF,d0             ; convert lower case to upper case
0000A6D0                          4585  NoLcase
0000A6D0  1100                    4586      MOVE.b  d0,-(a0)                ; copy upper case byte back to string
0000A6D2  51CA FFEA               4587      DBF     d2,UC_loop              ; decrement and loop if not all done
0000A6D6                          4588  
0000A6D6                          4589  NoString
0000A6D6  6000 FD28               4590      BRA     LAB_RTST                ; push string on descriptor stack
0000A6DA                          4591                                  ; a0 = pointer, d1 = length
0000A6DA                          4592  
0000A6DA                          4593  
0000A6DA                          4594  ;************************************************************************************
0000A6DA                          4595  ;
0000A6DA                          4596  ; perform SADD()
0000A6DA                          4597  
0000A6DA                          4598  LAB_SADD
0000A6DA  101D                    4599      MOVE.b  (a5)+,d0                ; increment pointer
0000A6DC  6100 F8D6               4600      BSR     LAB_GVAR                ; get variable address in a0
0000A6E0  6100 F6AE               4601      BSR     LAB_1BFB                ; scan for ")", else do syntax error/warm start
0000A6E4  4A2B 05B5               4602      TST.b       Dtypef(a3)              ; test data type flag
0000A6E8  6A00 EA44               4603      BPL     LAB_TMER                ; if numeric do Type missmatch Error
0000A6EC  2010                    4604      MOVE.l  (a0),d0                 ; get string address
0000A6EE  6000 FBB4               4605      BRA     LAB_AYFC                ; convert d0 to signed longword in FAC1 & return
0000A6F2                          4606  
0000A6F2                          4607  
0000A6F2                          4608  ;************************************************************************************
0000A6F2                          4609  ;
0000A6F2                          4610  ; perform LEN()
0000A6F2                          4611  
0000A6F2                          4612  LAB_LENS
0000A6F2  487A FBB0               4613      PEA     LAB_AYFC(pc)            ; set return address to convert d0 to signed
0000A6F6                          4614                                  ; longword in FAC1
0000A6F6  6000 FEB6               4615      BRA     LAB_22B6                ; pop string off descriptor stack or from memory
0000A6FA                          4616                                  ; returns with d0 = length, a0 = pointer
0000A6FA                          4617  
0000A6FA                          4618  
0000A6FA                          4619  ;************************************************************************************
0000A6FA                          4620  ;
0000A6FA                          4621  ; perform ASC()
0000A6FA                          4622  
0000A6FA                          4623  LAB_ASC
0000A6FA  6100 FEB2               4624      BSR     LAB_22B6                ; pop string off descriptor stack or from memory
0000A6FE                          4625                                  ; returns with d0 = length, a0 = pointer
0000A6FE  4A40                    4626      TST.w       d0                  ; test length
0000A700  6700 EA4C               4627      BEQ     LAB_FCER                ; if null do function call error then warm start
0000A704                          4628  
0000A704  1010                    4629      MOVE.b  (a0),d0             ; get first character byte
0000A706  6000 FBBC               4630      BRA     LAB_1FD0                ; convert d0 to unsigned byte in FAC1 & return
0000A70A                          4631  
0000A70A                          4632  
0000A70A                          4633  ;************************************************************************************
0000A70A                          4634  ;
0000A70A                          4635  ; increment and get byte, result in d0 and Itemp
0000A70A                          4636  
0000A70A                          4637  LAB_SGBY
0000A70A  6100 F696               4638      BSR     LAB_IGBY                ; increment & scan memory
0000A70E                          4639  
0000A70E                          4640  
0000A70E                          4641  ;************************************************************************************
0000A70E                          4642  ;
0000A70E                          4643  ; get byte parameter, result in d0 and Itemp
0000A70E                          4644  
0000A70E                          4645  LAB_GTBY
0000A70E  6100 F51A               4646      BSR     LAB_EVNM                ; evaluate expression & check is numeric,
0000A712                          4647                                  ; else do type mismatch
0000A712                          4648  
0000A712                          4649  
0000A712                          4650  ;************************************************************************************
0000A712                          4651  ;
0000A712                          4652  ; evaluate byte expression, result in d0 and Itemp
0000A712                          4653  
0000A712                          4654  LAB_EVBY
0000A712  6100 F9D4               4655      BSR     LAB_EVPI                ; evaluate positive integer expression
0000A716                          4656                                  ; result in d0 and Itemp
0000A716  123C 0080               4657      MOVE.b      #$80,d1             ; set mask/2
0000A71A  D281                    4658      ADD.l       d1,d1                   ; =$FFFFFF00
0000A71C  C280                    4659      AND.l       d0,d1                   ; check top 24 bits
0000A71E  6600 EA2E               4660      BNE     LAB_FCER                ; if <> 0 do function call error/warm start
0000A722                          4661  
0000A722  4E75                    4662      RTS
0000A724                          4663  
0000A724                          4664  
0000A724                          4665  ;************************************************************************************
0000A724                          4666  ;
0000A724                          4667  ; get word parameter, result in d0 and Itemp
0000A724                          4668  
0000A724                          4669  LAB_GTWO
0000A724  6100 F504               4670      BSR     LAB_EVNM                ; evaluate expression & check is numeric,
0000A728                          4671                                  ; else do type mismatch
0000A728  6100 F9BE               4672      BSR     LAB_EVPI                ; evaluate positive integer expression
0000A72C                          4673                                  ; result in d0 and Itemp
0000A72C  4840                    4674      SWAP        d0                  ; copy high word to low word
0000A72E  4A40                    4675      TST.w       d0                  ; set flags
0000A730  6600 EA1C               4676      BNE     LAB_FCER                ; if <> 0 do function call error/warm start
0000A734                          4677  
0000A734  4840                    4678      SWAP        d0                  ; copy high word to low word
0000A736  4E75                    4679      RTS
0000A738                          4680  
0000A738                          4681  
0000A738                          4682  ;************************************************************************************
0000A738                          4683  ;
0000A738                          4684  ; perform VAL()
0000A738                          4685  
0000A738                          4686  LAB_VAL
0000A738  6100 FE74               4687      BSR     LAB_22B6                ; pop string off descriptor stack or from memory
0000A73C                          4688                                  ; returns with d0 = length, a0 = pointer
0000A73C  6722                    4689      BEQ.s       LAB_VALZ                ; string was null so set result = $00
0000A73E                          4690                                  ; clear FAC1 exponent & sign & return
0000A73E                          4691  
0000A73E  2C4D                    4692      MOVEA.l a5,a6                   ; save BASIC execute pointer
0000A740  2A48                    4693      MOVEA.l a0,a5                   ; copy string pointer to execute pointer
0000A742  D1C0                    4694      ADDA.l  d0,a0                   ; string end+1
0000A744  1010                    4695      MOVE.b  (a0),d0             ; get byte from string+1
0000A746  3F00                    4696      MOVE.w  d0,-(sp)                ; save it
0000A748  2F08                    4697      MOVE.l  a0,-(sp)                ; save address
0000A74A  10BC 0000               4698      MOVE.b  #0,(a0)             ; null terminate string
0000A74E  6100 F654               4699      BSR     LAB_GBYT                ; scan memory
0000A752  6100 1148               4700      BSR     LAB_2887                ; get FAC1 from string
0000A756  205F                    4701      MOVEA.l (sp)+,a0                ; restore pointer
0000A758  301F                    4702      MOVE.w  (sp)+,d0                ; pop byte
0000A75A  1080                    4703      MOVE.b  d0,(a0)             ; restore to memory
0000A75C  2A4E                    4704      MOVEA.l a6,a5                   ; restore BASIC execute pointer
0000A75E  4E75                    4705      RTS
0000A760                          4706  
0000A760                          4707  LAB_VALZ
0000A760  3740 0594               4708      MOVE.w  d0,FAC1_e(a3)           ; clear FAC1 exponent & sign
0000A764  4E75                    4709      RTS
0000A766                          4710  
0000A766                          4711  
0000A766                          4712  ;************************************************************************************
0000A766                          4713  ;
0000A766                          4714  ; get two parameters for POKE or WAIT, first parameter in a0, second in d0
0000A766                          4715  
0000A766                          4716  LAB_GADB
0000A766  6100 F4C2               4717      BSR     LAB_EVNM                ; evaluate expression & check is numeric,
0000A76A                          4718                                  ; else do type mismatch
0000A76A  6100 F984               4719      BSR     LAB_EVIR                ; evaluate integer expression
0000A76E                          4720                                  ; (does FC error not OF error if out of range)
0000A76E  2F00                    4721      MOVE.l  d0,-(sp)                ; copy to stack
0000A770  6100 F626               4722      BSR     LAB_1C01                ; scan for ",", else do syntax error/warm start
0000A774  6198                    4723      BSR.s       LAB_GTBY                ; get byte parameter, result in d0 and Itemp
0000A776  205F                    4724      MOVEA.l (sp)+,a0                ; pull address
0000A778  4E75                    4725      RTS
0000A77A                          4726  
0000A77A                          4727  
0000A77A                          4728  ;************************************************************************************
0000A77A                          4729  ;
0000A77A                          4730  ; get two parameters for DOKE or WAITW, first parameter in a0, second in d0
0000A77A                          4731  
0000A77A                          4732  LAB_GADW
0000A77A  611E                    4733      BSR.s       LAB_GEAD                ; get even address for word/long memory actions
0000A77C                          4734                                  ; address returned in d0 and on the stack
0000A77C  6100 F61A               4735      BSR     LAB_1C01                ; scan for ",", else do syntax error/warm start
0000A780  6100 F4A8               4736      BSR     LAB_EVNM                ; evaluate expression & check is numeric,
0000A784                          4737                                  ; else do type mismatch
0000A784  6100 F96A               4738      BSR     LAB_EVIR                ; evaluate integer expression
0000A788                          4739                                  ; result in d0 and Itemp
0000A788  4840                    4740      SWAP        d0                  ; swap words
0000A78A  4A40                    4741      TST.w       d0                  ; test high word
0000A78C  6706                    4742      BEQ.s       LAB_XGADW               ; exit if null
0000A78E                          4743  
0000A78E  5240                    4744      ADDQ.w  #1,d0                   ; increment word
0000A790  6600 E9BC               4745      BNE     LAB_FCER                ; if <> 0 do function call error/warm start
0000A794                          4746  
0000A794                          4747  LAB_XGADW
0000A794  4840                    4748      SWAP        d0                  ; swap words back
0000A796  205F                    4749      MOVEA.l (sp)+,a0                ; pull address
0000A798  4E75                    4750      RTS
0000A79A                          4751  
0000A79A                          4752  
0000A79A                          4753  ;************************************************************************************
0000A79A                          4754  ;
0000A79A                          4755  ; get even address (for word or longword memory actions)
0000A79A                          4756  ; address returned in d0 and on the stack
0000A79A                          4757  ; does address error if the address is odd
0000A79A                          4758  
0000A79A                          4759  LAB_GEAD
0000A79A  6100 F48E               4760      BSR     LAB_EVNM                ; evaluate expression & check is numeric,
0000A79E                          4761                                  ; else do type mismatch
0000A79E  6100 F950               4762      BSR     LAB_EVIR                ; evaluate integer expression
0000A7A2                          4763                                  ; (does FC error not OF error if out of range)
0000A7A2  0800 0000               4764      BTST        #0,d0                   ; test low bit of longword
0000A7A6  6600 E962               4765      BNE     LAB_ADER                ; if address is odd do address error/warm start
0000A7AA                          4766  
0000A7AA  2057                    4767      MOVEA.l (sp),a0             ; copy return address
0000A7AC  2E80                    4768      MOVE.l  d0,(sp)             ; even address on stack
0000A7AE  4ED0                    4769      JMP     (a0)                    ; effectively RTS
0000A7B0                          4770  
0000A7B0                          4771  
0000A7B0                          4772  ;************************************************************************************
0000A7B0                          4773  ;
0000A7B0                          4774  ; perform PEEK()
0000A7B0                          4775  
0000A7B0                          4776  LAB_PEEK
0000A7B0  6100 F93E               4777      BSR     LAB_EVIR                ; evaluate integer expression
0000A7B4                          4778                                  ; (does FC error not OF error if out of range)
0000A7B4  2040                    4779      MOVEA.l d0,a0                   ; copy to address register
0000A7B6  1010                    4780      MOVE.b  (a0),d0             ; get byte
0000A7B8  6000 FB0A               4781      BRA     LAB_1FD0                ; convert d0 to unsigned byte in FAC1 & return
0000A7BC                          4782  
0000A7BC                          4783  
0000A7BC                          4784  ;************************************************************************************
0000A7BC                          4785  ;
0000A7BC                          4786  ; perform POKE
0000A7BC                          4787  
0000A7BC                          4788  LAB_POKE
0000A7BC  61A8                    4789      BSR.s       LAB_GADB                ; get two parameters for POKE or WAIT
0000A7BE                          4790                                  ; first parameter in a0, second in d0
0000A7BE  1080                    4791      MOVE.b  d0,(a0)             ; put byte in memory
0000A7C0  4E75                    4792      RTS
0000A7C2                          4793  
0000A7C2                          4794  
0000A7C2                          4795  ;************************************************************************************
0000A7C2                          4796  ;
0000A7C2                          4797  ; perform DEEK()
0000A7C2                          4798  
0000A7C2                          4799  LAB_DEEK
0000A7C2  6100 F92C               4800      BSR     LAB_EVIR                ; evaluate integer expression
0000A7C6                          4801                                  ; (does FC error not OF error if out of range)
0000A7C6  E208                    4802      LSR.b       #1,d0                   ; shift bit 0 to carry
0000A7C8  6500 E940               4803      BCS     LAB_ADER                ; if address is odd do address error/warm start
0000A7CC                          4804  
0000A7CC  D000                    4805      ADD.b       d0,d0                   ; shift byte back
0000A7CE  C188                    4806      EXG     d0,a0                   ; copy to address register
0000A7D0  7000                    4807      MOVEQ       #0,d0                   ; clear top bits
0000A7D2  3010                    4808      MOVE.w  (a0),d0             ; get word
0000A7D4  6000 FACE               4809      BRA     LAB_AYFC                ; convert d0 to signed longword in FAC1 & return
0000A7D8                          4810  
0000A7D8                          4811  
0000A7D8                          4812  ;************************************************************************************
0000A7D8                          4813  ;
0000A7D8                          4814  ; perform LEEK()
0000A7D8                          4815  
0000A7D8                          4816  LAB_LEEK
0000A7D8  6100 F916               4817      BSR     LAB_EVIR                ; evaluate integer expression
0000A7DC                          4818                                  ; (does FC error not OF error if out of range)
0000A7DC  E208                    4819      LSR.b       #1,d0                   ; shift bit 0 to carry
0000A7DE  6500 E92A               4820      BCS     LAB_ADER                ; if address is odd do address error/warm start
0000A7E2                          4821  
0000A7E2  D000                    4822      ADD.b       d0,d0                   ; shift byte back
0000A7E4  C188                    4823      EXG     d0,a0                   ; copy to address register
0000A7E6  2010                    4824      MOVE.l  (a0),d0             ; get longword
0000A7E8  6000 FABA               4825      BRA     LAB_AYFC                ; convert d0 to signed longword in FAC1 & return
0000A7EC                          4826  
0000A7EC                          4827  
0000A7EC                          4828  ;************************************************************************************
0000A7EC                          4829  ;
0000A7EC                          4830  ; perform DOKE
0000A7EC                          4831  
0000A7EC                          4832  LAB_DOKE
0000A7EC  618C                    4833      BSR.s       LAB_GADW                ; get two parameters for DOKE or WAIT
0000A7EE                          4834                                  ; first parameter in a0, second in d0
0000A7EE  3080                    4835      MOVE.w  d0,(a0)             ; put word in memory
0000A7F0  4E75                    4836      RTS
0000A7F2                          4837  
0000A7F2                          4838  
0000A7F2                          4839  ;************************************************************************************
0000A7F2                          4840  ;
0000A7F2                          4841  ; perform LOKE
0000A7F2                          4842  
0000A7F2                          4843  LAB_LOKE
0000A7F2  61A6                    4844      BSR.s       LAB_GEAD                ; get even address for word/long memory actions
0000A7F4                          4845                                  ; address returned in d0 and on the stack
0000A7F4  6100 F5A2               4846      BSR     LAB_1C01                ; scan for ",", else do syntax error/warm start
0000A7F8  6100 F430               4847      BSR     LAB_EVNM                ; evaluate expression & check is numeric,
0000A7FC                          4848                                  ; else do type mismatch
0000A7FC  6100 F8F2               4849      BSR     LAB_EVIR                ; evaluate integer value (no sign check)
0000A800  205F                    4850      MOVEA.l (sp)+,a0                ; pull address
0000A802  2080                    4851      MOVE.l  d0,(a0)             ; put longword in memory
0000A804                          4852  RTS_015
0000A804  4E75                    4853      RTS
0000A806                          4854  
0000A806                          4855  
0000A806                          4856  ;************************************************************************************
0000A806                          4857  ;
0000A806                          4858  ; perform SWAP
0000A806                          4859  
0000A806                          4860  LAB_SWAP
0000A806  6100 F7AC               4861      BSR     LAB_GVAR                ; get variable 1 address in a0
0000A80A  2F08                    4862      MOVE.l  a0,-(sp)                ; save variable 1 address
0000A80C  182B 05B5               4863      MOVE.b  Dtypef(a3),d4           ; copy variable 1 data type, $80=string,
0000A810                          4864                                  ; $40=inetger, $00=float
0000A810                          4865  
0000A810  6100 F586               4866      BSR     LAB_1C01                ; scan for ",", else do syntax error/warm start
0000A814  6100 F79E               4867      BSR     LAB_GVAR                ; get variable 2 address in a0
0000A818  245F                    4868      MOVEA.l (sp)+,a2                ; restore variable 1 address
0000A81A  B82B 05B5               4869      CMP.b       Dtypef(a3),d4           ; compare variable 1 data type with variable 2
0000A81E                          4870                                  ; data type
0000A81E  6600 E90E               4871      BNE     LAB_TMER                ; if not both the same type do "Type mismatch"
0000A822                          4872                                  ; error then warm start
0000A822                          4873  
0000A822  2010                    4874      MOVE.l  (a0),d0             ; get variable 2
0000A824  20D2                    4875      MOVE.l  (a2),(a0)+              ; copy variable 1 to variable 2
0000A826  24C0                    4876      MOVE.l  d0,(a2)+                ; save variable 2 to variable 1
0000A828                          4877  
0000A828  4A04                    4878      TST.b       d4                  ; check data type
0000A82A  6AD8                    4879      BPL.s       RTS_015             ; exit if not string
0000A82C                          4880  
0000A82C  3010                    4881      MOVE.w  (a0),d0             ; get string 2 length
0000A82E  3092                    4882      MOVE.w  (a2),(a0)               ; copy string 1 length to string 2 length
0000A830  3480                    4883      MOVE.w  d0,(a2)             ; save string 2 length to string 1 length
0000A832  4E75                    4884      RTS
0000A834                          4885  
0000A834                          4886  
0000A834                          4887  ;************************************************************************************
0000A834                          4888  ;
0000A834                          4889  ; perform USR
0000A834                          4890  
0000A834                          4891  LAB_USR
0000A834  4EAB 0406               4892      JSR     Usrjmp(a3)              ; do user vector
0000A838  6000 F556               4893      BRA     LAB_1BFB                ; scan for ")", else do syntax error/warm start
0000A83C                          4894  
0000A83C                          4895  
0000A83C                          4896  ;************************************************************************************
0000A83C                          4897  ;
0000A83C                          4898  ; perform LOAD
0000A83C                          4899  
0000A83C                          4900  LAB_LOAD
0000A83C  4EEB 0418               4901      JMP     V_LOAD(a3)              ; do load vector
0000A840                          4902  
0000A840                          4903  
0000A840                          4904  ;************************************************************************************
0000A840                          4905  ;
0000A840                          4906  ; perform SAVE
0000A840                          4907  
0000A840                          4908  LAB_SAVE
0000A840  4EEB 041E               4909      JMP     V_SAVE(a3)              ; do save vector
0000A844                          4910  
0000A844                          4911  
0000A844                          4912  ;************************************************************************************
0000A844                          4913  ;
0000A844                          4914  ; perform CALL
0000A844                          4915  
0000A844                          4916  LAB_CALL
0000A844  487A F55E               4917      PEA     LAB_GBYT(pc)            ; put return address on stack
0000A848  6100 FF50               4918      BSR     LAB_GEAD                ; get even address for word/long memory actions
0000A84C                          4919                                  ; address returned in d0 and on the stack
0000A84C  4E75                    4920      RTS                         ; effectively calls the routine
0000A84E                          4921  
0000A84E                          4922  ; if the called routine exits correctly then it will return via the get byte routine.
0000A84E                          4923  ; this will then get the next byte for the interpreter and return
0000A84E                          4924  
0000A84E                          4925  
0000A84E                          4926  ;************************************************************************************
0000A84E                          4927  ;
0000A84E                          4928  ; perform WAIT
0000A84E                          4929  
0000A84E                          4930  LAB_WAIT
0000A84E  6100 FF16               4931      BSR     LAB_GADB                ; get two parameters for POKE or WAIT
0000A852                          4932                                  ; first parameter in a0, second in d0
0000A852  2F08                    4933      MOVE.l  a0,-(sp)                ; save address
0000A854  3F00                    4934      MOVE.w  d0,-(sp)                ; save byte
0000A856  7400                    4935      MOVEQ       #0,d2                   ; clear mask
0000A858  6100 F54A               4936      BSR     LAB_GBYT                ; scan memory
0000A85C  6706                    4937      BEQ.s       LAB_2441                ; skip if no third argument
0000A85E                          4938  
0000A85E  6100 F534               4939      BSR     LAB_SCGB                ; scan for "," & get byte,
0000A862                          4940                                  ; else do syntax error/warm start
0000A862  2400                    4941      MOVE.l  d0,d2                   ; copy mask
0000A864                          4942  LAB_2441
0000A864  321F                    4943      MOVE.w  (sp)+,d1                ; get byte
0000A866  205F                    4944      MOVEA.l (sp)+,a0                ; get address
0000A868                          4945  LAB_2445
0000A868  1010                    4946      MOVE.b  (a0),d0             ; read memory byte
0000A86A  B500                    4947      EOR.b       d2,d0                   ; EOR with second argument (mask)
0000A86C  C001                    4948      AND.b       d1,d0                   ; AND with first argument (byte)
0000A86E  67F8                    4949      BEQ.s       LAB_2445                ; loop if result is zero
0000A870                          4950  
0000A870  4E75                    4951      RTS
0000A872                          4952  
0000A872                          4953  
0000A872                          4954  ;************************************************************************************
0000A872                          4955  ;
0000A872                          4956  ; perform subtraction, FAC1 from FAC2
0000A872                          4957  
0000A872                          4958  LAB_SUBTRACT
0000A872  0A2B 0080 0595          4959      EORI.b  #$80,FAC1_s(a3)         ; complement FAC1 sign
0000A878  176B 059D 059E          4960      MOVE.b  FAC2_s(a3),FAC_sc(a3)       ; copy FAC2 sign byte
0000A87E                          4961  
0000A87E  102B 0595               4962      MOVE.b  FAC1_s(a3),d0           ; get FAC1 sign byte
0000A882  B12B 059E               4963      EOR.b       d0,FAC_sc(a3)           ; EOR with FAC2 sign
0000A886                          4964  
0000A886                          4965  
0000A886                          4966  ;************************************************************************************
0000A886                          4967  ;
0000A886                          4968  ; add FAC2 to FAC1
0000A886                          4969  
0000A886                          4970  LAB_ADD
0000A886  102B 0594               4971      MOVE.b  FAC1_e(a3),d0           ; get exponent
0000A88A  6700 0338               4972      BEQ     LAB_279B                ; FAC1 was zero so copy FAC2 to FAC1 & return
0000A88E                          4973  
0000A88E                          4974                                  ; FAC1 is non zero
0000A88E  41EB 0598               4975      LEA     FAC2_m(a3),a0           ; set pointer1 to FAC2 mantissa
0000A892  102B 059C               4976      MOVE.b  FAC2_e(a3),d0           ; get FAC2 exponent
0000A896  6746                    4977      BEQ.s       RTS_016             ; exit if zero
0000A898                          4978  
0000A898  902B 0594               4979      SUB.b       FAC1_e(a3),d0           ; subtract FAC1 exponent
0000A89C  6722                    4980      BEQ.s       LAB_24A8                ; branch if = (go add mantissa)
0000A89E                          4981  
0000A89E  650A                    4982      BCS.s       LAB_249C                ; branch if FAC2 < FAC1
0000A8A0                          4983  
0000A8A0                          4984                                  ; FAC2 > FAC1
0000A8A0  376B 059C 0594          4985      MOVE.w  FAC2_e(a3),FAC1_e(a3)       ; copy sign and exponent of FAC2
0000A8A6  4400                    4986      NEG.b       d0                  ; negate exponent difference (make diff -ve)
0000A8A8  5148                    4987      SUBQ.w  #8,a0                   ; pointer1 to FAC1
0000A8AA                          4988  
0000A8AA                          4989  LAB_249C
0000A8AA  4400                    4990      NEG.b       d0                  ; negate exponent difference (make diff +ve)
0000A8AC  2F01                    4991      MOVE.l  d1,-(sp)                ; save d1
0000A8AE  B03C 0020               4992      CMP.b       #32,d0              ; compare exponent diff with 32
0000A8B2  6D04                    4993      BLT.s       LAB_2467                ; branch if range >= 32
0000A8B4                          4994  
0000A8B4  7200                    4995      MOVEQ       #0,d1                   ; clear d1
0000A8B6  6004                    4996      BRA.s       LAB_2468                ; go clear smaller mantissa
0000A8B8                          4997  
0000A8B8                          4998  LAB_2467
0000A8B8  2210                    4999      MOVE.l  (a0),d1             ; get FACx mantissa
0000A8BA  E0A9                    5000      LSR.l       d0,d1                   ; shift d0 times right
0000A8BC                          5001  LAB_2468
0000A8BC  2081                    5002      MOVE.l  d1,(a0)             ; save it back
0000A8BE  221F                    5003      MOVE.l  (sp)+,d1                ; restore d1
0000A8C0                          5004  
0000A8C0                          5005                                  ; exponents are equal now do mantissa add or
0000A8C0                          5006                                  ; subtract
0000A8C0                          5007  LAB_24A8
0000A8C0  4A2B 059E               5008      TST.b       FAC_sc(a3)              ; test sign compare (FAC1 EOR FAC2)
0000A8C4  6B1A                    5009      BMI.s       LAB_24F8                ; if <> go do subtract
0000A8C6                          5010  
0000A8C6  202B 0598               5011      MOVE.l  FAC2_m(a3),d0           ; get FAC2 mantissa
0000A8CA  D0AB 0590               5012      ADD.l       FAC1_m(a3),d0           ; add FAC1 mantissa
0000A8CE  640A                    5013      BCC.s       LAB_24F7                ; save and exit if no carry (FAC1 is normal)
0000A8D0                          5014  
0000A8D0  E290                    5015      ROXR.l  #1,d0                   ; else shift carry back into mantissa
0000A8D2  522B 0594               5016      ADDQ.b  #1,FAC1_e(a3)           ; increment FAC1 exponent
0000A8D6  6500 E872               5017      BCS     LAB_OFER                ; if carry do overflow error & warm start
0000A8DA                          5018  
0000A8DA                          5019  LAB_24F7
0000A8DA  2740 0590               5020      MOVE.l  d0,FAC1_m(a3)           ; save mantissa
0000A8DE                          5021  RTS_016
0000A8DE  4E75                    5022      RTS
0000A8E0                          5023                                  ; signs are different
0000A8E0                          5024  LAB_24F8
0000A8E0  43EB 0590               5025      LEA     FAC1_m(a3),a1           ; pointer 2 to FAC1
0000A8E4  B3C8                    5026      CMPA.l  a0,a1                   ; compare pointers
0000A8E6  6602                    5027      BNE.s       LAB_24B4                ; branch if <>
0000A8E8                          5028  
0000A8E8  5049                    5029      ADDQ.w  #8,a1                   ; else pointer2 to FAC2
0000A8EA                          5030  
0000A8EA                          5031                                  ; take smaller from bigger (take sign of bigger)
0000A8EA                          5032  LAB_24B4
0000A8EA  2011                    5033      MOVE.l  (a1),d0             ; get larger mantissa
0000A8EC  2210                    5034      MOVE.l  (a0),d1             ; get smaller mantissa
0000A8EE  2740 0590               5035      MOVE.l  d0,FAC1_m(a3)           ; save larger mantissa
0000A8F2  93AB 0590               5036      SUB.l       d1,FAC1_m(a3)           ; subtract smaller
0000A8F6                          5037  
0000A8F6                          5038  
0000A8F6                          5039  ;************************************************************************************
0000A8F6                          5040  ;
0000A8F6                          5041  ; do +/- (carry is sign) & normalise FAC1
0000A8F6                          5042  
0000A8F6                          5043  LAB_24D0
0000A8F6  640A                    5044      BCC.s       LAB_24D5                ; branch if result is +ve
0000A8F8                          5045  
0000A8F8                          5046                                  ; erk! subtract is the wrong way round so
0000A8F8                          5047                                  ; negate everything
0000A8F8  0A2B 00FF 0595          5048      EORI.b  #$FF,FAC1_s(a3)         ; complement FAC1 sign
0000A8FE  44AB 0590               5049      NEG.l       FAC1_m(a3)              ; negate FAC1 mantissa
0000A902                          5050  
0000A902                          5051  
0000A902                          5052  ;************************************************************************************
0000A902                          5053  ;
0000A902                          5054  ; normalise FAC1
0000A902                          5055  
0000A902                          5056  LAB_24D5
0000A902  202B 0590               5057      MOVE.l  FAC1_m(a3),d0           ; get mantissa
0000A906  6B2E                    5058      BMI.s       LAB_24DA                ; mantissa is normal so just exit
0000A908                          5059  
0000A908  6606                    5060      BNE.s       LAB_24D9                ; mantissa is not zero so go normalise FAC1
0000A90A                          5061  
0000A90A  3740 0594               5062      MOVE.w  d0,FAC1_e(a3)           ; else make FAC1 = +zero
0000A90E  4E75                    5063      RTS
0000A910                          5064  
0000A910                          5065  LAB_24D9
0000A910  2F01                    5066      MOVE.l  d1,-(sp)                ; save d1
0000A912  2200                    5067      MOVE.l  d0,d1                   ; mantissa to d1
0000A914  7000                    5068      MOVEQ       #0,d0                   ; clear d0
0000A916  102B 0594               5069      MOVE.b  FAC1_e(a3),d0           ; get exponent byte
0000A91A  6714                    5070      BEQ.s       LAB_24D8                ; if exponent is zero then clean up and exit
0000A91C                          5071  LAB_24D6
0000A91C  D281                    5072      ADD.l       d1,d1                   ; shift mantissa, ADD is quicker for a single
0000A91E                          5073                                  ; shift
0000A91E  5BC8 FFFC               5074      DBMI        d0,LAB_24D6             ; decrement exponent and loop if mantissa and
0000A922                          5075                                  ; exponent +ve
0000A922                          5076  
0000A922  4A40                    5077      TST.w       d0                  ; test exponent
0000A924  670A                    5078      BEQ.s       LAB_24D8                ; if exponent is zero make FAC1 zero
0000A926                          5079  
0000A926  6A02                    5080      BPL.s       LAB_24D7                ; if exponent is >zero go save FAC1
0000A928                          5081  
0000A928  7001                    5082      MOVEQ       #1,d0                   ; else set for zero after correction
0000A92A                          5083  LAB_24D7
0000A92A  5300                    5084      SUBQ.b  #1,d0                   ; adjust exponent for loop
0000A92C  2741 0590               5085      MOVE.l  d1,FAC1_m(a3)           ; save normalised mantissa
0000A930                          5086  LAB_24D8
0000A930  221F                    5087      MOVE.l  (sp)+,d1                ; restore d1
0000A932  1740 0594               5088      MOVE.b  d0,FAC1_e(a3)           ; save corrected exponent
0000A936                          5089  LAB_24DA
0000A936  4E75                    5090      RTS
0000A938                          5091  
0000A938                          5092  
0000A938                          5093  ;************************************************************************************
0000A938                          5094  ;
0000A938                          5095  ; perform LOG()
0000A938                          5096  
0000A938                          5097  LAB_LOG
0000A938  4A2B 0595               5098      TST.b       FAC1_s(a3)              ; test sign
0000A93C  6B00 E810               5099      BMI     LAB_FCER                ; if -ve do function call error/warm start
0000A940                          5100  
0000A940  7E00                    5101      MOVEQ       #0,d7                   ; clear d7
0000A942  1747 059E               5102      MOVE.b  d7,FAC_sc(a3)           ; clear sign compare
0000A946  1E2B 0594               5103      MOVE.b  FAC1_e(a3),d7           ; get exponent
0000A94A  6700 E802               5104      BEQ     LAB_FCER                ; if 0 do function call error/warm start
0000A94E                          5105  
0000A94E  0487 00000081           5106      SUB.l       #$81,d7             ; normalise exponent
0000A954  177C 0081 0594          5107      MOVE.b  #$81,FAC1_e(a3)         ; force a value between 1 and 2
0000A95A  2C2B 0590               5108      MOVE.l  FAC1_m(a3),d6           ; copy mantissa
0000A95E                          5109  
0000A95E  277C 80000000 0598      5110      MOVE.l  #$80000000,FAC2_m(a3)       ; set mantissa for 1
0000A966  377C 8100 059C          5111      MOVE.w  #$8100,FAC2_e(a3)           ; set exponent for 1
0000A96C  6100 FF18               5112      BSR     LAB_ADD             ; find arg+1
0000A970  7000                    5113      MOVEQ       #0,d0                   ; setup for calc skip
0000A972  3740 059C               5114      MOVE.w  d0,FAC2_e(a3)           ; set FAC1 for zero result
0000A976  DC86                    5115      ADD.l       d6,d6                   ; shift 1 bit out
0000A978  2746 0598               5116      MOVE.l  d6,FAC2_m(a3)           ; put back FAC2
0000A97C  6758                    5117      BEQ.s       LAB_LONN                ; if 0 skip calculation
0000A97E                          5118  
0000A97E  377C 8000 059C          5119      MOVE.w  #$8000,FAC2_e(a3)           ; set exponent for .5
0000A984  6100 0130               5120      BSR     LAB_DIVIDE              ; do (arg-1)/(arg+1)
0000A988  4A2B 0594               5121      TST.b       FAC1_e(a3)              ; test exponent
0000A98C  6748                    5122      BEQ.s       LAB_LONN                ; if 0 skip calculation
0000A98E                          5123  
0000A98E  122B 0594               5124      MOVE.b  FAC1_e(a3),d1           ; get exponent
0000A992  0401 0082               5125      SUB.b       #$82,d1             ; normalise and two integer bits
0000A996  4401                    5126      NEG.b       d1                  ; negate for shift
0000A998                          5127  ;   CMP.b       #$1F,d1             ; will mantissa vanish?
0000A998                          5128  ;   BGT.s       LAB_dunno               ; if so do ???
0000A998                          5129  
0000A998  202B 0590               5130      MOVE.l  FAC1_m(a3),d0           ; get mantissa
0000A99C  E2A8                    5131      LSR.l       d1,d0                   ; shift in two integer bits
0000A99E                          5132  
0000A99E                          5133  ; d0 = arg
0000A99E                          5134  ; d0 = x, d1 = y
0000A99E                          5135  ; d2 = x1, d3 = y1
0000A99E                          5136  ; d4 = shift count
0000A99E                          5137  ; d5 = loop count
0000A99E                          5138  ; d6 = z
0000A99E                          5139  ; a0 = table pointer
0000A99E                          5140  
0000A99E  7C00                    5141      MOVEQ       #0,d6                   ; z = 0
0000A9A0  223C 40000000           5142      MOVE.l  #1<<30,d1               ; y = 1
0000A9A6  41FA 1404               5143      LEA     TAB_HTHET(pc),a0            ; get pointer to hyperbolic tangent table
0000A9AA  7A1E                    5144      MOVEQ       #30,d5              ; loop 31 times
0000A9AC  7801                    5145      MOVEQ       #1,d4                   ; set shift count
0000A9AE  6006                    5146      BRA.s       LAB_LOCC                ; entry point for loop
0000A9B0                          5147  
0000A9B0                          5148  LAB_LAAD
0000A9B0  E8A2                    5149      ASR.l       d4,d2                   ; x1 >> i
0000A9B2  9282                    5150      SUB.l       d2,d1                   ; y = y - x1
0000A9B4  DC90                    5151      ADD.l       (a0),d6             ; z = z + tanh(i)
0000A9B6                          5152  LAB_LOCC
0000A9B6  2400                    5153      MOVE.l  d0,d2                   ; x1 = x
0000A9B8  2601                    5154      MOVE.l  d1,d3                   ; y1 = Y
0000A9BA  E8A3                    5155      ASR.l       d4,d3                   ; y1 >> i
0000A9BC  6402                    5156      BCC.s       LAB_LOLP
0000A9BE                          5157  
0000A9BE  5283                    5158      ADDQ.l  #1,d3
0000A9C0                          5159  LAB_LOLP
0000A9C0  9083                    5160      SUB.l       d3,d0                   ; x = x - y1
0000A9C2  6AEC                    5161      BPL.s       LAB_LAAD                ; branch if > 0
0000A9C4                          5162  
0000A9C4  2002                    5163      MOVE.l  d2,d0                   ; get x back
0000A9C6  5848                    5164      ADDQ.w  #4,a0                   ; next entry
0000A9C8  5284                    5165      ADDQ.l  #1,d4                   ; next i
0000A9CA  E28B                    5166      LSR.l       #1,d3                   ; /2
0000A9CC  6704                    5167      BEQ.s       LAB_LOCX                ; branch y1 = 0
0000A9CE                          5168  
0000A9CE  51CD FFF0               5169      DBF     d5,LAB_LOLP             ; decrement and loop if not done
0000A9D2                          5170  
0000A9D2                          5171                                  ; now sort out the result
0000A9D2                          5172  LAB_LOCX
0000A9D2  DC86                    5173      ADD.l       d6,d6                   ; *2
0000A9D4  2006                    5174      MOVE.l  d6,d0                   ; setup for d7 = 0
0000A9D6                          5175  LAB_LONN
0000A9D6  2800                    5176      MOVE.l  d0,d4                   ; save cordic result
0000A9D8  7A00                    5177      MOVEQ       #0,d5                   ; set default exponent sign
0000A9DA  4A87                    5178      TST.l       d7                  ; check original exponent sign
0000A9DC  6716                    5179      BEQ.s       LAB_LOXO                ; branch if original was 0
0000A9DE                          5180  
0000A9DE  6A04                    5181      BPL.s       LAB_LOXP                ; branch if was +ve
0000A9E0                          5182  
0000A9E0  4487                    5183      NEG.l       d7                  ; make original exponent +ve
0000A9E2  7A80                    5184      MOVEQ       #$80-$100,d5            ; make sign -ve
0000A9E4                          5185  LAB_LOXP
0000A9E4  1745 0595               5186      MOVE.b  d5,FAC1_s(a3)           ; save original exponent sign
0000A9E8  4847                    5187      SWAP        d7                  ; 16 bit shift
0000A9EA  E18F                    5188      LSL.l       #8,d7                   ; easy first part
0000A9EC  7A88                    5189      MOVEQ       #$88-$100,d5            ; start with byte
0000A9EE                          5190  LAB_LONE
0000A9EE  5385                    5191      SUBQ.l  #1,d5                   ; decrement exponent
0000A9F0  DE87                    5192      ADD.l       d7,d7                   ; shift mantissa
0000A9F2  6AFA                    5193      BPL.s       LAB_LONE                ; loop if not normal
0000A9F4                          5194  
0000A9F4                          5195  LAB_LOXO
0000A9F4  2747 0590               5196      MOVE.l  d7,FAC1_m(a3)           ; save original exponent as mantissa
0000A9F8  1745 0594               5197      MOVE.b  d5,FAC1_e(a3)           ; save exponent for this
0000A9FC  277C B17217F8 0598      5198      MOVE.l  #$B17217F8,FAC2_m(a3)       ; LOG(2) mantissa
0000AA04  377C 8000 059C          5199      MOVE.w  #$8000,FAC2_e(a3)           ; LOG(2) exponent & sign
0000AA0A  176B 0595 059E          5200      MOVE.b  FAC1_s(a3),FAC_sc(a3)       ; make sign compare = FAC1 sign
0000AA10  6118                    5201      BSR.s       LAB_MULTIPLY            ; do multiply
0000AA12  2744 0598               5202      MOVE.l  d4,FAC2_m(a3)           ; save cordic result
0000AA16  6710                    5203      BEQ.s       LAB_LOWZ                ; branch if zero
0000AA18                          5204  
0000AA18  377C 8200 059C          5205      MOVE.w  #$8200,FAC2_e(a3)           ; set exponent & sign
0000AA1E  176B 0595 059E          5206      MOVE.b  FAC1_s(a3),FAC_sc(a3)       ; clear sign compare
0000AA24  6100 FE60               5207      BSR     LAB_ADD             ; and add for final result
0000AA28                          5208  
0000AA28                          5209  LAB_LOWZ
0000AA28  4E75                    5210      RTS
0000AA2A                          5211  
0000AA2A                          5212  
0000AA2A                          5213  ;************************************************************************************
0000AA2A                          5214  ;
0000AA2A                          5215  ; multiply FAC1 by FAC2
0000AA2A                          5216  
0000AA2A                          5217  LAB_MULTIPLY
0000AA2A  48E7 F800               5218      MOVEM.l d0-d4,-(sp)             ; save registers
0000AA2E  4A2B 0594               5219      TST.b       FAC1_e(a3)              ; test FAC1 exponent
0000AA32  6776                    5220      BEQ.s       LAB_MUUF                ; if exponent zero go make result zero
0000AA34                          5221  
0000AA34  102B 059C               5222      MOVE.b  FAC2_e(a3),d0           ; get FAC2 exponent
0000AA38  6770                    5223      BEQ.s       LAB_MUUF                ; if exponent zero go make result zero
0000AA3A                          5224  
0000AA3A  176B 059E 0595          5225      MOVE.b  FAC_sc(a3),FAC1_s(a3)       ; sign compare becomes sign
0000AA40                          5226  
0000AA40  D02B 0594               5227      ADD.b       FAC1_e(a3),d0           ; multiply exponents by adding
0000AA44  640A                    5228      BCC.s       LAB_MNOC                ; branch if no carry
0000AA46                          5229  
0000AA46  0400 0080               5230      SUB.b       #$80,d0             ; normalise result
0000AA4A  6400 E6FE               5231      BCC     LAB_OFER                ; if no carry do overflow
0000AA4E                          5232  
0000AA4E  6006                    5233      BRA.s       LAB_MADD                ; branch
0000AA50                          5234  
0000AA50                          5235                                  ; no carry for exponent add
0000AA50                          5236  LAB_MNOC
0000AA50  0400 0080               5237      SUB.b       #$80,d0             ; normalise result
0000AA54  6554                    5238      BCS.s       LAB_MUUF                ; return zero if underflow
0000AA56                          5239  
0000AA56                          5240  LAB_MADD
0000AA56  1740 0594               5241      MOVE.b  d0,FAC1_e(a3)           ; save exponent
0000AA5A                          5242  
0000AA5A                          5243                                  ; d1 (FAC1) x d2 (FAC2)
0000AA5A  222B 0590               5244      MOVE.l  FAC1_m(a3),d1           ; get FAC1 mantissa
0000AA5E  242B 0598               5245      MOVE.l  FAC2_m(a3),d2           ; get FAC2 mantissa
0000AA62                          5246  
0000AA62  3801                    5247      MOVE.w  d1,d4                   ; copy low word FAC1
0000AA64  2001                    5248      MOVE.l  d1,d0                   ; copy long word FAC1
0000AA66  4840                    5249      SWAP        d0                  ; high word FAC1 to low word FAC1
0000AA68  3600                    5250      MOVE.w  d0,d3                   ; copy high word FAC1
0000AA6A                          5251  
0000AA6A  C2C2                    5252      MULU        d2,d1                   ; low word FAC2 x low word FAC1
0000AA6C  C0C2                    5253      MULU        d2,d0                   ; low word FAC2 x high word FAC1
0000AA6E  4842                    5254      SWAP        d2                  ; high word FAC2 to low word FAC2
0000AA70  C8C2                    5255      MULU        d2,d4                   ; high word FAC2 x low word FAC1
0000AA72  C6C2                    5256      MULU        d2,d3                   ; high word FAC2 x high word FAC1
0000AA74                          5257  
0000AA74                          5258  ; done multiply, now add partial products
0000AA74                          5259  
0000AA74                          5260  ;           d1 =                    aaaa  ----  FAC2_L x FAC1_L
0000AA74                          5261  ;           d0 =                bbbb  aaaa      FAC2_L x FAC1_H
0000AA74                          5262  ;           d4 =                bbbb  aaaa      FAC2_H x FAC1_L
0000AA74                          5263  ;           d3 =            cccc  bbbb          FAC2_H x FAC1_H
0000AA74                          5264  ;           product =       mmmm  mmmm
0000AA74                          5265  
0000AA74  0681 00008000           5266      ADD.L       #$8000,d1               ; round up lowest word
0000AA7A  4241                    5267      CLR.w       d1                  ; clear low word, don't need it
0000AA7C  4841                    5268      SWAP        d1                  ; align high word
0000AA7E  D280                    5269      ADD.l       d0,d1                   ; add FAC2_L x FAC1_H (can't be carry)
0000AA80                          5270  LAB_MUF1
0000AA80  D284                    5271      ADD.l       d4,d1                   ; now add intermediate (FAC2_H x FAC1_L)
0000AA82  6406                    5272      BCC.s       LAB_MUF2                ; branch if no carry
0000AA84                          5273  
0000AA84  0683 00010000           5274      ADD.l       #$10000,d3              ; else correct result
0000AA8A                          5275  LAB_MUF2
0000AA8A  0681 00008000           5276      ADD.l       #$8000,d1               ; round up low word
0000AA90  4241                    5277      CLR.w       d1                  ; clear low word
0000AA92  4841                    5278      SWAP        d1                  ; align for final add
0000AA94  D283                    5279      ADD.l       d3,d1                   ; add FAC2_H x FAC1_H, result
0000AA96  6B08                    5280      BMI.s       LAB_MUF3                ; branch if normalisation not needed
0000AA98                          5281  
0000AA98  D281                    5282      ADD.l       d1,d1                   ; shift mantissa
0000AA9A  532B 0594               5283      SUBQ.b  #1,FAC1_e(a3)           ; adjust exponent
0000AA9E  670A                    5284      BEQ.s       LAB_MUUF                ; branch if underflow
0000AAA0                          5285  
0000AAA0                          5286  LAB_MUF3
0000AAA0  2741 0590               5287      MOVE.l  d1,FAC1_m(a3)           ; save mantissa
0000AAA4                          5288  LAB_MUEX
0000AAA4  4CDF 001F               5289      MOVEM.l (sp)+,d0-d4             ; restore registers
0000AAA8  4E75                    5290      RTS
0000AAAA                          5291                                  ; either zero or underflow result
0000AAAA                          5292  LAB_MUUF
0000AAAA  7000                    5293      MOVEQ       #0,d0                   ; quick clear
0000AAAC  2740 0590               5294      MOVE.l  d0,FAC1_m(a3)           ; clear mantissa
0000AAB0  3740 0594               5295      MOVE.w  d0,FAC1_e(a3)           ; clear sign and exponent
0000AAB4  60EE                    5296      BRA.s       LAB_MUEX                ; restore regs & exit
0000AAB6                          5297  
0000AAB6                          5298  
0000AAB6                          5299  ;************************************************************************************
0000AAB6                          5300  ;
0000AAB6                          5301  ; do FAC2/FAC1, result in FAC1
0000AAB6                          5302  ; fast hardware divide version
0000AAB6                          5303  
0000AAB6                          5304  LAB_DIVIDE
0000AAB6  2F07                    5305      MOVE.l  d7,-(sp)                ; save d7
0000AAB8  7000                    5306      MOVEQ       #0,d0                   ; clear FAC2 exponent
0000AABA  2400                    5307      MOVE.l  d0,d2                   ; clear FAC1 exponent
0000AABC                          5308  
0000AABC  142B 0594               5309      MOVE.b  FAC1_e(a3),d2           ; get FAC1 exponent
0000AAC0  6700 E674               5310      BEQ     LAB_DZER                ; if zero go do /0 error
0000AAC4                          5311  
0000AAC4  102B 059C               5312      MOVE.b  FAC2_e(a3),d0           ; get FAC2 exponent
0000AAC8  6766                    5313      BEQ.s       LAB_DIV0                ; if zero return zero
0000AACA                          5314  
0000AACA  9042                    5315      SUB.w       d2,d0                   ; get result exponent by subtracting
0000AACC  0640 0080               5316      ADD.w       #$80,d0             ; correct 16 bit exponent result
0000AAD0                          5317  
0000AAD0  176B 059E 0595          5318      MOVE.b  FAC_sc(a3),FAC1_s(a3)       ; sign compare is result sign
0000AAD6                          5319  
0000AAD6                          5320  ; now to do 32/32 bit mantissa divide
0000AAD6                          5321  
0000AAD6  422B 059F               5322      CLR.b       flag(a3)                ; clear 'flag' byte
0000AADA  262B 0590               5323      MOVE.l  FAC1_m(a3),d3           ; get FAC1 mantissa
0000AADE  282B 0598               5324      MOVE.l  FAC2_m(a3),d4           ; get FAC2 mantissa
0000AAE2  B883                    5325      CMP.l       d3,d4                   ; compare FAC2 with FAC1 mantissa
0000AAE4  6744                    5326      BEQ.s       LAB_MAN1                ; set mantissa result = 1 if equal
0000AAE6                          5327  
0000AAE6  6506                    5328      BCS.s       AC1gtAC2                ; branch if FAC1 > FAC2
0000AAE8                          5329  
0000AAE8  9883                    5330      SUB.l       d3,d4                   ; subtract FAC1 from FAC2, result now must be <1
0000AAEA  562B 059F               5331      ADDQ.b  #3,flag(a3)             ; FAC2>FAC1 so set 'flag' byte
0000AAEE                          5332  AC1gtAC2
0000AAEE  6146                    5333      BSR.s       LAB_32_16               ; do 32/16 divide
0000AAF0  4841                    5334      SWAP        d1                  ; move 16 bit result to high word
0000AAF2  2802                    5335      MOVE.l  d2,d4                   ; copy remainder longword
0000AAF4  6142                    5336      BSR.s       LAB_3216                ; do 32/16 divide again (skip copy d4 to d2)
0000AAF6  84C5                    5337      DIVU.w  d5,d2                   ; now divide remainder to make guard word
0000AAF8  1E2B 059F               5338      MOVE.b  flag(a3),d7             ; now normalise, get flag byte back
0000AAFC  6708                    5339      BEQ.s       LAB_DIVX                ; skip add if null
0000AAFE                          5340  
0000AAFE                          5341  ; else result was >1 so we need to add 1 to result mantissa and adjust exponent
0000AAFE                          5342  
0000AAFE  E20F                    5343      LSR.b       #1,d7                   ; shift 1 into eXtend
0000AB00  E291                    5344      ROXR.l  #1,d1                   ; shift extend result >>
0000AB02  E252                    5345      ROXR.w  #1,d2                   ; shift extend guard word >>
0000AB04  5200                    5346      ADDQ.b  #1,d0                   ; adjust exponent
0000AB06                          5347  
0000AB06                          5348  ; now round result to 32 bits
0000AB06                          5349  
0000AB06                          5350  LAB_DIVX
0000AB06  D442                    5351      ADD.w       d2,d2                   ; guard bit into eXtend bit
0000AB08  6408                    5352      BCC.s       L_DIVRND                ; branch if guard=0
0000AB0A                          5353  
0000AB0A  5281                    5354      ADDQ.l  #1,d1                   ; add guard to mantissa
0000AB0C  6404                    5355      BCC.s       L_DIVRND                ; branch if no overflow
0000AB0E                          5356  
0000AB0E                          5357  LAB_SET1
0000AB0E  E291                    5358      ROXR.l  #1,d1                   ; shift extend result >>
0000AB10  5240                    5359      ADDQ.w  #1,d0                   ; adjust exponent
0000AB12                          5360  
0000AB12                          5361                                  ; test for over/under flow
0000AB12                          5362  L_DIVRND
0000AB12  3600                    5363      MOVE.w  d0,d3                   ; copy exponent
0000AB14  6B1A                    5364      BMI.s       LAB_DIV0                ; if -ve return zero
0000AB16                          5365  
0000AB16  0243 FF00               5366      ANDI.w  #$FF00,d3               ; mask word high byte
0000AB1A  6600 E62E               5367      BNE     LAB_OFER                ; branch if overflow
0000AB1E                          5368  
0000AB1E                          5369                                  ; move result into FAC1
0000AB1E                          5370  LAB_XDIV
0000AB1E  2E1F                    5371      MOVE.l  (sp)+,d7                ; restore d7
0000AB20  1740 0594               5372      MOVE.b  d0,FAC1_e(a3)           ; save result exponent
0000AB24  2741 0590               5373      MOVE.l  d1,FAC1_m(a3)           ; save result mantissa
0000AB28  4E75                    5374      RTS
0000AB2A                          5375  
0000AB2A                          5376  ; FAC1 mantissa = FAC2 mantissa so set result mantissa
0000AB2A                          5377  
0000AB2A                          5378  LAB_MAN1
0000AB2A  7201                    5379      MOVEQ       #1,d1                   ; set bit
0000AB2C  E2A9                    5380      LSR.l       d1,d1                   ; bit into eXtend
0000AB2E  60DE                    5381      BRA.s       LAB_SET1                ; set mantissa, adjust exponent and exit
0000AB30                          5382  
0000AB30                          5383  ; result is zero
0000AB30                          5384  
0000AB30                          5385  LAB_DIV0
0000AB30  7000                    5386      MOVEQ       #0,d0                   ; zero exponent & sign
0000AB32  2200                    5387      MOVE.l  d0,d1                   ; zero mantissa
0000AB34  60E8                    5388      BRA     LAB_XDIV                ; exit divide
0000AB36                          5389  
0000AB36                          5390  ; divide 16 bits into 32, AB/Ex
0000AB36                          5391  ;
0000AB36                          5392  ; d4            AAAA    BBBB                ; 32 bit numerator
0000AB36                          5393  ; d3            EEEE    xxxx                ; 16 bit denominator
0000AB36                          5394  ;
0000AB36                          5395  ; returns -
0000AB36                          5396  ;
0000AB36                          5397  ; d1            xxxx    DDDD                ; 16 bit result
0000AB36                          5398  ; d2                HHHH    IIII            ; 32 bit remainder
0000AB36                          5399  
0000AB36                          5400  LAB_32_16
0000AB36  2404                    5401      MOVE.l  d4,d2                   ; copy FAC2 mantissa        (AB)
0000AB38                          5402  LAB_3216
0000AB38  2A03                    5403      MOVE.l  d3,d5                   ; copy FAC1 mantissa        (EF)
0000AB3A  4245                    5404      CLR.w       d5                  ; clear low word d1     (Ex)
0000AB3C  4845                    5405      SWAP        d5                  ; swap high word to low word    (xE)
0000AB3E                          5406  
0000AB3E                          5407  ; d3            EEEE    FFFF                ; denominator copy
0000AB3E                          5408  ; d5        0000    EEEE                    ; denominator high word
0000AB3E                          5409  ; d2            AAAA    BBBB                ; numerator copy
0000AB3E                          5410  ; d4            AAAA    BBBB                ; numerator
0000AB3E                          5411  
0000AB3E  88C5                    5412      DIVU.w  d5,d4                   ; do FAC2/FAC1 high word    (AB/E)
0000AB40  6802                    5413      BVC.s       LAB_LT_1                ; if no overflow DIV was ok
0000AB42                          5414  
0000AB42  78FF                    5415      MOVEQ       #-1,d4              ; else set default value
0000AB44                          5416  
0000AB44                          5417  ; done the divide, now check the result, we have ...
0000AB44                          5418  
0000AB44                          5419  ; d3            EEEE    FFFF                ; denominator copy
0000AB44                          5420  ; d5        0000    EEEE                    ; denominator high word
0000AB44                          5421  ; d2            AAAA    BBBB                ; numerator copy
0000AB44                          5422  ; d4            MMMM    DDDD                ; result MOD and DIV
0000AB44                          5423  
0000AB44                          5424  LAB_LT_1
0000AB44  3C04                    5425      MOVE.w  d4,d6                   ; copy 16 bit result
0000AB46  3204                    5426      MOVE.w  d4,d1                   ; copy 16 bit result again
0000AB48                          5427  
0000AB48                          5428  ; we now have ..
0000AB48                          5429  ; d3            EEEE    FFFF                ; denominator copy
0000AB48                          5430  ; d5        0000    EEEE                    ; denominator high word
0000AB48                          5431  ; d6            xxxx  DDDD              ; result DIV copy
0000AB48                          5432  ; d1            xxxx  DDDD              ; result DIV copy
0000AB48                          5433  ; d2            AAAA    BBBB                ; numerator copy
0000AB48                          5434  ; d4            MMMM    DDDD                ; result MOD and DIV
0000AB48                          5435  
0000AB48                          5436  ; now multiply out 32 bit denominator by 16 bit result
0000AB48                          5437  ; QRS = AB*D
0000AB48                          5438  
0000AB48  CCC3                    5439      MULU.w  d3,d6                   ; FFFF  ; DDDD =       rrrr  SSSS
0000AB4A  C8C5                    5440      MULU.w  d5,d4                   ; EEEE  ; DDDD = QQQQ  rrrr
0000AB4C                          5441  
0000AB4C                          5442  ; we now have ..
0000AB4C                          5443  ; d3            EEEE    FFFF                ; denominator copy
0000AB4C                          5444  ; d5        0000    EEEE                    ; denominator high word
0000AB4C                          5445  ; d6                rrrr  SSSS          ; 48 bit result partial low
0000AB4C                          5446  ; d1            xxxx  DDDD              ; result DIV copy
0000AB4C                          5447  ; d2            AAAA    BBBB                ; numerator copy
0000AB4C                          5448  ; d4            QQQQ    rrrr                ; 48 bit result partial
0000AB4C                          5449  
0000AB4C  3E06                    5450      MOVE.w  d6,d7                   ; copy low word of low multiply
0000AB4E                          5451  
0000AB4E                          5452  ; d7                xxxx    SSSS            ; 48 bit result partial low
0000AB4E                          5453  
0000AB4E  4246                    5454      CLR.w       d6                  ; clear low word of low multiply
0000AB50  4846                    5455      SWAP        d6                  ; high word of low multiply to low word
0000AB52                          5456  
0000AB52                          5457  ; d6            0000    rrrr                ; high word of 48 bit result partial low
0000AB52                          5458  
0000AB52  D886                    5459      ADD.l       d6,d4
0000AB54                          5460  
0000AB54                          5461  ; d4            QQQQ    RRRR                ; 48 bit result partial high longword
0000AB54                          5462  
0000AB54  7C00                    5463      MOVEQ       #0,d6                   ; clear to extend numerator to 48 bits
0000AB56                          5464  
0000AB56                          5465  ; now do GHI = AB0 - QRS (which is the remainder)
0000AB56                          5466  
0000AB56  9C47                    5467      SUB.w       d7,d6                   ; low word subtract
0000AB58                          5468  
0000AB58                          5469  ; d6                xxxx    IIII            ; remainder low word
0000AB58                          5470  
0000AB58  9584                    5471      SUBX.l  d4,d2                   ; high longword subtract
0000AB5A                          5472  
0000AB5A                          5473  ; d2            GGGG    HHHH                ; remainder high longword
0000AB5A                          5474  
0000AB5A                          5475  ; now if we got the divide correct then the remainder high longword will be +ve
0000AB5A                          5476  
0000AB5A  6A08                    5477      BPL.s       L_DDIV              ; branch if result is ok (<needed)
0000AB5C                          5478  
0000AB5C                          5479  ; remainder was -ve so DDDD is too big
0000AB5C                          5480  
0000AB5C                          5481  LAB_REMM
0000AB5C  5341                    5482      SUBQ.w  #1,d1                   ; adjust DDDD
0000AB5E                          5483  
0000AB5E                          5484  ; d3                xxxx    FFFF            ; denominator copy
0000AB5E                          5485  ; d6                xxxx    IIII            ; remainder low word
0000AB5E                          5486  
0000AB5E  DC43                    5487      ADD.w       d3,d6                   ; add EF*1 low remainder low word
0000AB60                          5488  
0000AB60                          5489  ; d5            0000    EEEE                ; denominator high word
0000AB60                          5490  ; d2            GGGG    HHHH                ; remainder high longword
0000AB60                          5491  
0000AB60  D585                    5492      ADDX.l  d5,d2                   ; add extend EF*1 to remainder high longword
0000AB62  6BF8                    5493      BMI.s       LAB_REMM                ; loop if result still too big
0000AB64                          5494  
0000AB64                          5495  ; all done and result correct or <
0000AB64                          5496  
0000AB64                          5497  L_DDIV
0000AB64  4842                    5498      SWAP        d2                  ; remainder mid word to high word
0000AB66                          5499  
0000AB66                          5500  ; d2            HHHH    GGGG                ; (high word /should/ be $0000)
0000AB66                          5501  
0000AB66  3406                    5502      MOVE.w  d6,d2                   ; remainder in high word
0000AB68                          5503  
0000AB68                          5504  ; d2                HHHH    IIII            ; now is 32 bit remainder
0000AB68                          5505  ; d1            xxxx    DDDD                ; 16 bit result
0000AB68                          5506  
0000AB68  4E75                    5507      RTS
0000AB6A                          5508  
0000AB6A                          5509  
0000AB6A                          5510  ;************************************************************************************
0000AB6A                          5511  ;
0000AB6A                          5512  ; unpack memory (a0) into FAC1
0000AB6A                          5513  
0000AB6A                          5514  LAB_UFAC
0000AB6A  2010                    5515      MOVE.l  (a0),d0             ; get packed value
0000AB6C  4840                    5516      SWAP        d0                  ; exponent and sign into least significant word
0000AB6E  3740 0594               5517      MOVE.w  d0,FAC1_e(a3)           ; save exponent and sign
0000AB72  6708                    5518      BEQ.s       LAB_NB1T                ; branch if exponent (and the rest) zero
0000AB74                          5519  
0000AB74  807C 0080               5520      OR.w        #$80,d0             ; set MSb
0000AB78  4840                    5521      SWAP        d0                  ; word order back to normal
0000AB7A  E180                    5522      ASL.l       #8,d0                   ; shift exponent & clear guard byte
0000AB7C                          5523  LAB_NB1T
0000AB7C  2740 0590               5524      MOVE.l  d0,FAC1_m(a3)           ; move into FAC1
0000AB80                          5525  
0000AB80  102B 0594               5526      MOVE.b  FAC1_e(a3),d0           ; get FAC1 exponent
0000AB84  4E75                    5527      RTS
0000AB86                          5528  
0000AB86                          5529  
0000AB86                          5530  ;************************************************************************************
0000AB86                          5531  ;
0000AB86                          5532  ; set numeric variable, pack FAC1 into Lvarpl
0000AB86                          5533  
0000AB86                          5534  LAB_PFAC
0000AB86  2F08                    5535      MOVE.l  a0,-(sp)                ; save pointer
0000AB88  206B 0472               5536      MOVEA.l Lvarpl(a3),a0           ; get destination pointer
0000AB8C  082B 0006 05B5          5537      BTST        #6,Dtypef(a3)           ; test data type
0000AB92  670C                    5538      BEQ.s       LAB_277C                ; branch if floating
0000AB94                          5539  
0000AB94  6100 00C6               5540      BSR     LAB_2831                ; convert FAC1 floating to fixed
0000AB98                          5541                                  ; result in d0 and Itemp
0000AB98  2080                    5542      MOVE.l  d0,(a0)             ; save in var
0000AB9A  205F                    5543      MOVE.l  (sp)+,a0                ; restore pointer
0000AB9C  4E75                    5544      RTS
0000AB9E                          5545  
0000AB9E                          5546  
0000AB9E                          5547  ;************************************************************************************
0000AB9E                          5548  ;
0000AB9E                          5549  ; normalise round and pack FAC1 into (a0)
0000AB9E                          5550  
0000AB9E                          5551  LAB_2778
0000AB9E  2F08                    5552      MOVE.l  a0,-(sp)                ; save pointer
0000ABA0                          5553  LAB_277C
0000ABA0  6100 FD60               5554      BSR     LAB_24D5                ; normalise FAC1
0000ABA4  612C                    5555      BSR.s       LAB_27BA                ; round FAC1
0000ABA6  202B 0590               5556      MOVE.l  FAC1_m(a3),d0           ; get FAC1 mantissa
0000ABAA  E098                    5557      ROR.l       #8,d0                   ; align 24/32 bit mantissa
0000ABAC  4840                    5558      SWAP        d0                  ; exponent/sign into 0-15
0000ABAE  C07C 007F               5559      AND.w       #$7F,d0             ; clear exponent and sign bit
0000ABB2  022B 0080 0595          5560      ANDI.b  #$80,FAC1_s(a3)         ; clear non sign bits in sign
0000ABB8  806B 0594               5561      OR.w        FAC1_e(a3),d0           ; OR in exponent and sign
0000ABBC  4840                    5562      SWAP        d0                  ; move exponent and sign back to 16-31
0000ABBE  2080                    5563      MOVE.l  d0,(a0)             ; store in destination
0000ABC0  205F                    5564      MOVE.l  (sp)+,a0                ; restore pointer
0000ABC2  4E75                    5565      RTS
0000ABC4                          5566  
0000ABC4                          5567  
0000ABC4                          5568  ;************************************************************************************
0000ABC4                          5569  ;
0000ABC4                          5570  ; copy FAC2 to FAC1
0000ABC4                          5571  
0000ABC4                          5572  LAB_279B
0000ABC4  376B 059C 0594          5573      MOVE.w  FAC2_e(a3),FAC1_e(a3)       ; copy exponent & sign
0000ABCA  276B 0598 0590          5574      MOVE.l  FAC2_m(a3),FAC1_m(a3)       ; copy mantissa
0000ABD0  4E75                    5575      RTS
0000ABD2                          5576  
0000ABD2                          5577  
0000ABD2                          5578  ;************************************************************************************
0000ABD2                          5579  ;
0000ABD2                          5580  ; round FAC1
0000ABD2                          5581  
0000ABD2                          5582  LAB_27BA
0000ABD2  102B 0594               5583      MOVE.b  FAC1_e(a3),d0           ; get FAC1 exponent
0000ABD6  6720                    5584      BEQ.s       LAB_27C4                ; branch if zero
0000ABD8                          5585  
0000ABD8  202B 0590               5586      MOVE.l  FAC1_m(a3),d0           ; get FAC1
0000ABDC  0680 00000080           5587      ADD.l       #$80,d0             ; round to 24 bit
0000ABE2  640A                    5588      BCC.s       LAB_27C3                ; branch if no overflow
0000ABE4                          5589  
0000ABE4  E290                    5590      ROXR.l  #1,d0                   ; shift FAC1 mantissa
0000ABE6  522B 0594               5591      ADDQ.b  #1,FAC1_e(a3)           ; correct exponent
0000ABEA  6500 E55E               5592      BCS     LAB_OFER                ; if carry do overflow error & warm start
0000ABEE                          5593  
0000ABEE                          5594  LAB_27C3
0000ABEE  C03C 0000               5595      AND.b       #$00,d0             ; clear guard byte
0000ABF2  2740 0590               5596      MOVE.l  d0,FAC1_m(a3)           ; save back to FAC1
0000ABF6  4E75                    5597      RTS
0000ABF8                          5598  
0000ABF8                          5599  LAB_27C4
0000ABF8  1740 0595               5600      MOVE.b  d0,FAC1_s(a3)           ; make zero always +ve
0000ABFC                          5601  RTS_017
0000ABFC  4E75                    5602      RTS
0000ABFE                          5603  
0000ABFE                          5604  
0000ABFE                          5605  ;************************************************************************************
0000ABFE                          5606  ;
0000ABFE                          5607  ; get FAC1 sign
0000ABFE                          5608  ; return d0=-1,C=1/-ve d0=+1,C=0/+ve
0000ABFE                          5609  
0000ABFE                          5610  LAB_27CA
0000ABFE  7000                    5611      MOVEQ       #0,d0                   ; clear d0
0000AC00  102B 0594               5612      MOVE.b  FAC1_e(a3),d0           ; get FAC1 exponent
0000AC04  67F6                    5613      BEQ.s       RTS_017             ; exit if zero (already correct SGN(0)=0)
0000AC06                          5614  
0000AC06                          5615  
0000AC06                          5616  ;************************************************************************************
0000AC06                          5617  ;
0000AC06                          5618  ; return d0=-1,C=1/-ve d0=+1,C=0/+ve
0000AC06                          5619  ; no = 0 check
0000AC06                          5620  
0000AC06                          5621  LAB_27CE
0000AC06  102B 0595               5622      MOVE.b  FAC1_s(a3),d0           ; else get FAC1 sign (b7)
0000AC0A                          5623  
0000AC0A                          5624  
0000AC0A                          5625  ;************************************************************************************
0000AC0A                          5626  ;
0000AC0A                          5627  ; return d0=-1,C=1/-ve d0=+1,C=0/+ve
0000AC0A                          5628  ; no = 0 check, sign in d0
0000AC0A                          5629  
0000AC0A                          5630  LAB_27D0
0000AC0A  4880                    5631      EXT.w       d0                  ; make word
0000AC0C  48C0                    5632      EXT.l       d0                  ; make longword
0000AC0E  E080                    5633      ASR.l       #8,d0                   ; move sign bit through byte to carry
0000AC10  65EA                    5634      BCS.s       RTS_017             ; exit if carry set
0000AC12                          5635  
0000AC12  7001                    5636      MOVEQ       #1,d0                   ; set result for +ve sign
0000AC14  4E75                    5637      RTS
0000AC16                          5638  
0000AC16                          5639  
0000AC16                          5640  ;************************************************************************************
0000AC16                          5641  ;
0000AC16                          5642  ; perform SGN()
0000AC16                          5643  
0000AC16                          5644  LAB_SGN
0000AC16  61E6                    5645      BSR.s       LAB_27CA                ; get FAC1 sign
0000AC18                          5646                                  ; return d0=-1/-ve d0=+1/+ve
0000AC18                          5647  
0000AC18                          5648  
0000AC18                          5649  ;************************************************************************************
0000AC18                          5650  ;
0000AC18                          5651  ; save d0 as integer longword
0000AC18                          5652  
0000AC18                          5653  LAB_27DB
0000AC18  2740 0590               5654      MOVE.l  d0,FAC1_m(a3)           ; save FAC1 mantissa
0000AC1C  377C A000 0594          5655      MOVE.w  #$A000,FAC1_e(a3)           ; set FAC1 exponent & sign
0000AC22  D080                    5656      ADD.l       d0,d0                   ; top bit into carry
0000AC24  6000 FCD0               5657      BRA     LAB_24D0                ; do +/- (carry is sign) & normalise FAC1
0000AC28                          5658  
0000AC28                          5659  
0000AC28                          5660  ;************************************************************************************
0000AC28                          5661  ;
0000AC28                          5662  ; perform ABS()
0000AC28                          5663  
0000AC28                          5664  LAB_ABS
0000AC28  177C 0000 0595          5665      MOVE.b  #0,FAC1_s(a3)           ; clear FAC1 sign
0000AC2E  4E75                    5666      RTS
0000AC30                          5667  
0000AC30                          5668  
0000AC30                          5669  ;************************************************************************************
0000AC30                          5670  ;
0000AC30                          5671  ; compare FAC1 with FAC2
0000AC30                          5672  ; returns d0=+1 Cb=0 if FAC1 > FAC2
0000AC30                          5673  ; returns d0= 0 Cb=0 if FAC1 = FAC2
0000AC30                          5674  ; returns d0=-1 Cb=1 if FAC1 < FAC2
0000AC30                          5675  
0000AC30                          5676  LAB_27FA
0000AC30  122B 059C               5677      MOVE.b  FAC2_e(a3),d1           ; get FAC2 exponent
0000AC34  67C8                    5678      BEQ.s       LAB_27CA                ; branch if FAC2 exponent=0 & get FAC1 sign
0000AC36                          5679                                  ; d0=-1,C=1/-ve d0=+1,C=0/+ve
0000AC36                          5680  
0000AC36  102B 059E               5681      MOVE.b  FAC_sc(a3),d0           ; get FAC sign compare
0000AC3A  6BCA                    5682      BMI.s       LAB_27CE                ; if signs <> do return d0=-1,C=1/-ve
0000AC3C                          5683                                  ; d0=+1,C=0/+ve & return
0000AC3C                          5684  
0000AC3C  102B 0595               5685      MOVE.b  FAC1_s(a3),d0           ; get FAC1 sign
0000AC40  B22B 0594               5686      CMP.b       FAC1_e(a3),d1           ; compare FAC1 exponent with FAC2 exponent
0000AC44  660A                    5687      BNE.s       LAB_2828                ; branch if different
0000AC46                          5688  
0000AC46  222B 0598               5689      MOVE.l  FAC2_m(a3),d1           ; get FAC2 mantissa
0000AC4A  B2AB 0590               5690      CMP.l       FAC1_m(a3),d1           ; compare mantissas
0000AC4E  6708                    5691      BEQ.s       LAB_282F                ; exit if mantissas equal
0000AC50                          5692  
0000AC50                          5693  ; gets here if number <> FAC1
0000AC50                          5694  
0000AC50                          5695  LAB_2828
0000AC50  65B8                    5696      BCS.s       LAB_27D0                ; if FAC1 > FAC2 return d0=-1,C=1/-ve d0=+1,
0000AC52                          5697                                  ; C=0/+ve
0000AC52                          5698  
0000AC52  0A00 0080               5699      EORI.b  #$80,d0             ; else toggle FAC1 sign
0000AC56                          5700  LAB_282E
0000AC56  60B2                    5701      BRA.s       LAB_27D0                ; return d0=-1,C=1/-ve d0=+1,C=0/+ve
0000AC58                          5702  
0000AC58                          5703  LAB_282F
0000AC58  7000                    5704      MOVEQ       #0,d0                   ; clear result
0000AC5A  4E75                    5705      RTS
0000AC5C                          5706  
0000AC5C                          5707  
0000AC5C                          5708  ;************************************************************************************
0000AC5C                          5709  ;
0000AC5C                          5710  ; convert FAC1 floating to fixed
0000AC5C                          5711  ; result in d0 and Itemp, sets flags correctly
0000AC5C                          5712  
0000AC5C                          5713  LAB_2831
0000AC5C  202B 0590               5714      MOVE.l  FAC1_m(a3),d0           ; copy mantissa
0000AC60  6732                    5715      BEQ.s       LAB_284J                ; branch if mantissa = 0
0000AC62                          5716  
0000AC62  2F01                    5717      MOVE.l  d1,-(sp)                ; save d1
0000AC64  123C 00A0               5718      MOVE.b      #$A0,d1             ; set for no floating bits
0000AC68  922B 0594               5719      SUB.b       FAC1_e(a3),d1           ; subtract FAC1 exponent
0000AC6C  6500 E4DC               5720      BCS     LAB_OFER                ; do overflow if too big
0000AC70                          5721  
0000AC70  660E                    5722      BNE.s       LAB_284G                ; branch if exponent was not $A0
0000AC72                          5723  
0000AC72  4A2B 0595               5724      TST.b       FAC1_s(a3)              ; test FAC1 sign
0000AC76  6A1A                    5725      BPL.s       LAB_284H                ; branch if FAC1 +ve
0000AC78                          5726  
0000AC78  4480                    5727      NEG.l       d0
0000AC7A  6916                    5728      BVS.s       LAB_284H                ; branch if was $80000000
0000AC7C                          5729  
0000AC7C  6000 E4CC               5730      BRA     LAB_OFER                ; do overflow if too big
0000AC80                          5731  
0000AC80                          5732  LAB_284G
0000AC80  B23C 0020               5733      CMP.b       #$20,d1             ; compare with minimum result for integer
0000AC84  6502                    5734      BCS.s       LAB_284L                ; if < minimum just do shift
0000AC86                          5735  
0000AC86  7000                    5736      MOVEQ       #0,d0                   ; else return zero
0000AC88                          5737  LAB_284L
0000AC88  E2A8                    5738      LSR.l       d1,d0                   ; shift integer
0000AC8A                          5739  
0000AC8A  4A2B 0595               5740      TST.b       FAC1_s(a3)              ; test FAC1 sign (b7)
0000AC8E  6A02                    5741      BPL.s       LAB_284H                ; branch if FAC1 +ve
0000AC90                          5742  
0000AC90  4480                    5743      NEG.l       d0                  ; negate integer value
0000AC92                          5744  LAB_284H
0000AC92  221F                    5745      MOVE.l  (sp)+,d1                ; restore d1
0000AC94                          5746  LAB_284J
0000AC94  2740 042A               5747      MOVE.l  d0,Itemp(a3)            ; save result to Itemp
0000AC98  4E75                    5748      RTS
0000AC9A                          5749  
0000AC9A                          5750  
0000AC9A                          5751  ;************************************************************************************
0000AC9A                          5752  ;
0000AC9A                          5753  ; perform INT()
0000AC9A                          5754  
0000AC9A                          5755  LAB_INT
0000AC9A  103C 00A0               5756      MOVE.b      #$A0,d0             ; set for no floating bits
0000AC9E  902B 0594               5757      SUB.b       FAC1_e(a3),d0           ; subtract FAC1 exponent
0000ACA2  6310                    5758      BLS.s       LAB_IRTS                ; exit if exponent >= $A0
0000ACA4                          5759                                  ; (too big for fraction part!)
0000ACA4                          5760  
0000ACA4  B03C 0020               5761      CMP.b       #$20,d0             ; compare with minimum result for integer
0000ACA8  6400 025E               5762      BCC     LAB_POZE                ; if >= minimum go return 0
0000ACAC                          5763                                  ; (too small for integer part!)
0000ACAC                          5764  
0000ACAC  72FF                    5765      MOVEQ       #-1,d1              ; set integer mask
0000ACAE  E1A1                    5766      ASL.l       d0,d1                   ; shift mask [8+2*d0]
0000ACB0  C3AB 0590               5767      AND.l       d1,FAC1_m(a3)           ; mask mantissa
0000ACB4                          5768  LAB_IRTS
0000ACB4  4E75                    5769      RTS
0000ACB6                          5770  
0000ACB6                          5771  
0000ACB6                          5772  ;************************************************************************************
0000ACB6                          5773  ;
0000ACB6                          5774  ; print " in line [LINE #]"
0000ACB6                          5775  
0000ACB6                          5776  LAB_2953
0000ACB6  41FA 17FC               5777      LEA     LAB_LMSG(pc),a0         ; point to " in line " message
0000ACBA  6100 ED1C               5778      BSR     LAB_18C3                ; print null terminated string
0000ACBE                          5779  
0000ACBE                          5780                                  ; Print Basic line #
0000ACBE  202B 0452               5781      MOVE.l  Clinel(a3),d0           ; get current line
0000ACC2                          5782  
0000ACC2                          5783  
0000ACC2                          5784  ;************************************************************************************
0000ACC2                          5785  ;
0000ACC2                          5786  ; print d0 as unsigned integer
0000ACC2                          5787  
0000ACC2                          5788  LAB_295E
0000ACC2  43FA 0DEA               5789      LEA     Bin2dec(pc),a1          ; get table address
0000ACC6  7200                    5790      MOVEQ       #0,d1                   ; table index
0000ACC8  41EB 05CC               5791      LEA     Usdss(a3),a0            ; output string start
0000ACCC  2401                    5792      MOVE.l  d1,d2                   ; output string index
0000ACCE                          5793  LAB_2967
0000ACCE  2631 1000               5794      MOVE.l  (a1,d1.w),d3            ; get table value
0000ACD2  6714                    5795      BEQ.s       LAB_2969                ; exit if end marker
0000ACD4                          5796  
0000ACD4  782F                    5797      MOVEQ       #'0'-1,d4               ; set character to "0"-1
0000ACD6                          5798  LAB_2968
0000ACD6  5244                    5799      ADDQ.w  #1,d4                   ; next numeric character
0000ACD8  9083                    5800      SUB.l       d3,d0                   ; subtract table value
0000ACDA  6AFA                    5801      BPL.s       LAB_2968                ; not overdone so loop
0000ACDC                          5802  
0000ACDC  D083                    5803      ADD.l       d3,d0                   ; correct value
0000ACDE  1184 2000               5804      MOVE.b  d4,(a0,d2.w)            ; character out to string
0000ACE2  5841                    5805      ADDQ.w  #4,d1                   ; increment table pointer
0000ACE4  5242                    5806      ADDQ.w  #1,d2                   ; increment output string pointer
0000ACE6  60E6                    5807      BRA.s       LAB_2967                ; loop
0000ACE8                          5808  
0000ACE8                          5809  LAB_2969
0000ACE8  0600 0030               5810      ADD.b       #'0',d0             ; make last character
0000ACEC  1180 2000               5811      MOVE.b  d0,(a0,d2.w)            ; character out to string
0000ACF0  5348                    5812      SUBQ.w  #1,a0                   ; decrement a0 (allow simple loop)
0000ACF2                          5813  
0000ACF2                          5814                                  ; now find non zero start of string
0000ACF2                          5815  LAB_296A
0000ACF2  5248                    5816      ADDQ.w  #1,a0                   ; increment a0 (this will never carry to b16)
0000ACF4  43EB 05D5               5817      LEA     BHsend-1(a3),a1         ; get string end
0000ACF8  B1C9                    5818      CMPA.l  a1,a0                   ; are we at end
0000ACFA  6700 ECDC               5819      BEQ     LAB_18C3                ; if so print null terminated string and RETURN
0000ACFE                          5820  
0000ACFE  0C10 0030               5821      CMPI.b  #'0',(a0)               ; is character "0" ?
0000AD02  67EE                    5822      BEQ.s       LAB_296A                ; loop if so
0000AD04                          5823  
0000AD04  6000 ECD2               5824      BRA     LAB_18C3                ; print null terminated string from memory & RET
0000AD08                          5825  
0000AD08                          5826  
0000AD08                          5827  ;************************************************************************************
0000AD08                          5828  ;
0000AD08                          5829  ; convert FAC1 to ASCII string result in (a0)
0000AD08                          5830  ; STR$() function enters here
0000AD08                          5831  
0000AD08                          5832  ; now outputs 7 significant digits
0000AD08                          5833  
0000AD08                          5834  ; d0 is character out
0000AD08                          5835  ; d1 is save index
0000AD08                          5836  ; d2 is gash
0000AD08                          5837  
0000AD08                          5838  ; a0 is output string pointer
0000AD08                          5839  
0000AD08                          5840  LAB_2970
0000AD08  43EB 05C6               5841      LEA     Decss(a3),a1            ; set output string start
0000AD0C                          5842  
0000AD0C  7420                    5843      MOVEQ       #' ',d2             ; character = " ", assume +ve
0000AD0E  08AB 0007 0595          5844      BCLR.b  #7,FAC1_s(a3)           ; test and clear FAC1 sign (b7)
0000AD14  6702                    5845      BEQ.s       LAB_2978                ; branch if +ve
0000AD16                          5846  
0000AD16  742D                    5847      MOVEQ       #'-',d2             ; else character = "-"
0000AD18                          5848  LAB_2978
0000AD18  1282                    5849      MOVE.b  d2,(a1)             ; save the sign character
0000AD1A  142B 0594               5850      MOVE.b  FAC1_e(a3),d2           ; get FAC1 exponent
0000AD1E  6608                    5851      BNE.s       LAB_2989                ; branch if FAC1<>0
0000AD20                          5852  
0000AD20                          5853                                  ; exponent was $00 so FAC1 is 0
0000AD20  7030                    5854      MOVEQ       #'0',d0             ; set character = "0"
0000AD22  7201                    5855      MOVEQ       #1,d1                   ; set output string index
0000AD24  6000 01A4               5856      BRA     LAB_2A89                ; save last character, [EOT] & exit
0000AD28                          5857  
0000AD28                          5858                                  ; FAC1 is some non zero value
0000AD28                          5859  LAB_2989
0000AD28  177C 0000 05AC          5860      MOVE.b  #0,numexp(a3)           ; clear number exponent count
0000AD2E  B43C 0081               5861      CMP.b       #$81,d2             ; compare FAC1 exponent with $81 (>1.00000)
0000AD32                          5862  
0000AD32  6448                    5863      BCC.s       LAB_299C                ; branch if FAC1=>1
0000AD34                          5864  
0000AD34                          5865                                  ; else FAC1 < 1
0000AD34  277C 98968000 0598      5866      MOVE.l  #$98968000,FAC2_m(a3)       ; 10000000 mantissa
0000AD3C  377C 9800 059C          5867      MOVE.w  #$9800,FAC2_e(a3)           ; 10000000 exponent & sign
0000AD42  176B 0595 059E          5868      MOVE.b  FAC1_s(a3),FAC_sc(a3)       ; make FAC1 sign sign compare
0000AD48  6100 FCE0               5869      BSR     LAB_MULTIPLY            ; do FAC2*FAC1
0000AD4C                          5870  
0000AD4C  177C 00F9 05AC          5871      MOVE.b  #$F9,numexp(a3)         ; set number exponent count (-7)
0000AD52  6028                    5872      BRA.s       LAB_299C                ; go test for fit
0000AD54                          5873  
0000AD54                          5874  LAB_29B9
0000AD54  376B 0594 059C          5875      MOVE.w  FAC1_e(a3),FAC2_e(a3)       ; copy exponent & sign from FAC1 to FAC2
0000AD5A  276B 0590 0598          5876      MOVE.l  FAC1_m(a3),FAC2_m(a3)       ; copy FAC1 mantissa to FAC2 mantissa
0000AD60  176B 0595 059E          5877      MOVE.b  FAC1_s(a3),FAC_sc(a3)       ; save FAC1_s as sign compare
0000AD66                          5878  
0000AD66  277C CCCCCCCD 0590      5879      MOVE.l  #$CCCCCCCD,FAC1_m(a3)       ; 1/10 mantissa
0000AD6E  377C 7D00 0594          5880      MOVE.w  #$7D00,FAC1_e(a3)           ; 1/10 exponent & sign
0000AD74  6100 FCB4               5881      BSR     LAB_MULTIPLY            ; do FAC2*FAC1, effectively divide by 10 but
0000AD78                          5882                                  ; faster
0000AD78                          5883  
0000AD78  522B 05AC               5884      ADDQ.b  #1,numexp(a3)           ; increment number exponent count
0000AD7C                          5885  LAB_299C
0000AD7C  277C 98967F70 0598      5886      MOVE.l  #$98967F70,FAC2_m(a3)       ; 9999999.4375 mantissa
0000AD84  377C 9800 059C          5887      MOVE.w  #$9800,FAC2_e(a3)           ; 9999999.4375 exponent & sign
0000AD8A                          5888                                  ; (max before scientific notation)
0000AD8A  6100 014C               5889      BSR     LAB_27F0                ; fast compare FAC1 with FAC2
0000AD8E                          5890                                  ; returns d0=+1 C=0 if FAC1 > FAC2
0000AD8E                          5891                                  ; returns d0= 0 C=0 if FAC1 = FAC2
0000AD8E                          5892                                  ; returns d0=-1 C=1 if FAC1 < FAC2
0000AD8E  62C4                    5893      BHI.s       LAB_29B9                ; go do /10 if FAC1 > 9999999.4375
0000AD90                          5894  
0000AD90  6750                    5895      BEQ.s       LAB_29C3                ; branch if FAC1 = 9999999.4375
0000AD92                          5896  
0000AD92                          5897                                  ; FAC1 < 9999999.4375
0000AD92  277C F423F800 0598      5898      MOVE.l  #$F423F800,FAC2_m(a3)       ; set mantissa for 999999.5
0000AD9A  377C 9400 059C          5899      MOVE.w  #$9400,FAC2_e(a3)           ; set exponent for 999999.5
0000ADA0                          5900  
0000ADA0  41EB 0590               5901      LEA     FAC1_m(a3),a0           ; set pointer for x10
0000ADA4                          5902  LAB_29A7
0000ADA4  6100 0132               5903      BSR     LAB_27F0                ; fast compare FAC1 with FAC2
0000ADA8                          5904                                  ; returns d0=+1 C=0 if FAC1 > FAC2
0000ADA8                          5905                                  ; returns d0= 0 C=0 if FAC1 = FAC2
0000ADA8                          5906                                  ; returns d0=-1 C=1 if FAC1 < FAC2
0000ADA8  6220                    5907      BHI.s       LAB_29C0                ; branch if FAC1 > 99999.9375,no decimal places
0000ADAA                          5908  
0000ADAA                          5909                                  ; FAC1 <= 999999.5 so do x 10
0000ADAA  2010                    5910      MOVE.l  (a0),d0             ; get FAC1 mantissa
0000ADAC  1228 0004               5911      MOVE.b  4(a0),d1                ; get FAC1 exponent
0000ADB0  2400                    5912      MOVE.l  d0,d2                   ; copy it
0000ADB2  E488                    5913      LSR.l       #2,d0                   ; /4
0000ADB4  D082                    5914      ADD.l       d2,d0                   ; add FAC1 (x1.125)
0000ADB6  6404                    5915      BCC.s       LAB_29B7                ; branch if no carry
0000ADB8                          5916  
0000ADB8  E290                    5917      ROXR.l  #1,d0                   ; shift carry back in
0000ADBA  5201                    5918      ADDQ.b  #1,d1                   ; increment exponent (never overflows)
0000ADBC                          5919  LAB_29B7
0000ADBC  5601                    5920      ADDQ.b  #3,d1                   ; correct exponent ( 8 x 1.125 = 10 )
0000ADBE                          5921                                  ; (never overflows)
0000ADBE  2080                    5922      MOVE.l  d0,(a0)             ; save new mantissa
0000ADC0  1141 0004               5923      MOVE.b  d1,4(a0)                ; save new exponent
0000ADC4  532B 05AC               5924      SUBQ.b  #1,numexp(a3)           ; decrement number exponent count
0000ADC8  60DA                    5925      BRA.s       LAB_29A7                ; go test again
0000ADCA                          5926  
0000ADCA                          5927                                  ; now we have just the digits to do
0000ADCA                          5928  LAB_29C0
0000ADCA  277C 80000000 0598      5929      MOVE.l  #$80000000,FAC2_m(a3)       ; set mantissa for 0.5
0000ADD2  377C 8000 059C          5930      MOVE.w  #$8000,FAC2_e(a3)           ; set exponent for 0.5
0000ADD8  176B 0595 059E          5931      MOVE.b  FAC1_s(a3),FAC_sc(a3)       ; sign compare = sign
0000ADDE  6100 FAA6               5932      BSR     LAB_ADD             ; add the 0.5 to FAC1 (round FAC1)
0000ADE2                          5933  
0000ADE2                          5934  LAB_29C3
0000ADE2  6100 FE78               5935      BSR     LAB_2831                ; convert FAC1 floating to fixed
0000ADE6                          5936                                  ; result in d0 and Itemp
0000ADE6  7401                    5937      MOVEQ       #$01,d2             ; set default digits before dp = 1
0000ADE8  102B 05AC               5938      MOVE.b  numexp(a3),d0           ; get number exponent count
0000ADEC  5000                    5939      ADD.b       #8,d0                   ; allow 7 digits before point
0000ADEE  6B0C                    5940      BMI.s       LAB_29D9                ; if -ve then 1 digit before dp
0000ADF0                          5941  
0000ADF0  B03C 0009               5942      CMP.b       #$09,d0             ; d0>=9 if n>=1E7
0000ADF4  6406                    5943      BCC.s       LAB_29D9                ; branch if >= $09
0000ADF6                          5944  
0000ADF6                          5945                                  ; < $08
0000ADF6  5300                    5946      SUBQ.b  #1,d0                   ; take 1 from digit count
0000ADF8  1400                    5947      MOVE.b  d0,d2                   ; copy byte
0000ADFA  7002                    5948      MOVEQ       #$02,d0             ; set exponent adjust
0000ADFC                          5949  LAB_29D9
0000ADFC  7200                    5950      MOVEQ       #0,d1                   ; set output string index
0000ADFE  5500                    5951      SUBQ.b  #2,d0                   ; -2
0000AE00  1740 05AD               5952      MOVE.b  d0,expcnt(a3)           ; save exponent adjust
0000AE04  1742 05AC               5953      MOVE.b  d2,numexp(a3)           ; save digits before dp count
0000AE08  1002                    5954      MOVE.b  d2,d0                   ; copy digits before dp count
0000AE0A  6702                    5955      BEQ.s       LAB_29E4                ; branch if no digits before dp
0000AE0C                          5956  
0000AE0C  6A14                    5957      BPL.s       LAB_29F7                ; branch if digits before dp
0000AE0E                          5958  
0000AE0E                          5959  LAB_29E4
0000AE0E  5281                    5960      ADDQ.l  #1,d1                   ; increment index
0000AE10  13BC 002E 1000          5961      MOVE.b  #'.',(a1,d1.w)          ; save to output string
0000AE16                          5962  
0000AE16  4A02                    5963      TST.b       d2                  ; test digits before dp count
0000AE18  6708                    5964      BEQ.s       LAB_29F7                ; branch if no digits before dp
0000AE1A                          5965  
0000AE1A  5281                    5966      ADDQ.l  #1,d1                   ; increment index
0000AE1C  13BC 0030 1000          5967      MOVE.b  #'0',(a1,d1.w)          ; save to output string
0000AE22                          5968  LAB_29F7
0000AE22  7400                    5969      MOVEQ       #0,d2                   ; clear index (point to 1,000,000)
0000AE24  7080                    5970      MOVEQ       #$80-$100,d0            ; set output character
0000AE26                          5971  LAB_29FB
0000AE26  41FA 1120               5972      LEA     LAB_2A9A(pc),a0         ; get base of table
0000AE2A  2630 2000               5973      MOVE.l  (a0,d2.w),d3            ; get table value
0000AE2E                          5974  LAB_29FD
0000AE2E  5200                    5975      ADDQ.b  #1,d0                   ; increment output character
0000AE30  D7AB 042A               5976      ADD.l       d3,Itemp(a3)            ; add to (now fixed) mantissa
0000AE34  0800 0007               5977      BTST        #7,d0                   ; set test sense (z flag only)
0000AE38  6504                    5978      BCS.s       LAB_2A18                ; did carry so has wrapped past zero
0000AE3A                          5979  
0000AE3A  67F2                    5980      BEQ.s       LAB_29FD                ; no wrap and +ve test so try again
0000AE3C                          5981  
0000AE3C  6002                    5982      BRA.s       LAB_2A1A                ; found this digit
0000AE3E                          5983  
0000AE3E                          5984  LAB_2A18
0000AE3E  66EE                    5985      BNE.s       LAB_29FD                ; wrap and -ve test so try again
0000AE40                          5986  
0000AE40                          5987  LAB_2A1A
0000AE40  6406                    5988      BCC.s       LAB_2A21                ; branch if +ve test result
0000AE42                          5989  
0000AE42  4400                    5990      NEG.b       d0                  ; negate the digit number
0000AE44  0600 000B               5991      ADD.b       #$0B,d0             ; and subtract from 11 decimal
0000AE48                          5992  LAB_2A21
0000AE48  0600 002F               5993      ADD.b       #$2F,d0             ; add "0"-1 to result
0000AE4C  5842                    5994      ADDQ.w  #4,d2                   ; increment index to next less power of ten
0000AE4E  5241                    5995      ADDQ.w  #1,d1                   ; increment output string index
0000AE50  1600                    5996      MOVE.b  d0,d3                   ; copy character to d3
0000AE52  C63C 007F               5997      AND.b       #$7F,d3             ; mask out top bit
0000AE56  1383 1000               5998      MOVE.b  d3,(a1,d1.w)            ; save to output string
0000AE5A  532B 05AC               5999      SUB.b       #1,numexp(a3)           ; decrement # of characters before the dp
0000AE5E  6608                    6000      BNE.s       LAB_2A3B                ; branch if still characters to do
0000AE60                          6001  
0000AE60                          6002                                  ; else output the point
0000AE60  5281                    6003      ADDQ.l  #1,d1                   ; increment index
0000AE62  13BC 002E 1000          6004      MOVE.b  #'.',(a1,d1.w)          ; save to output string
0000AE68                          6005  LAB_2A3B
0000AE68  C03C 0080               6006      AND.b       #$80,d0             ; mask test sense bit
0000AE6C  0A00 0080               6007      EORI.b  #$80,d0             ; invert it
0000AE70  B43C 001C               6008      CMP.b       #LAB_2A9B-LAB_2A9A,d2       ; compare table index with max+4
0000AE74  66B0                    6009      BNE.s       LAB_29FB                ; loop if not max
0000AE76                          6010  
0000AE76                          6011                                  ; now remove trailing zeroes
0000AE76                          6012  LAB_2A4B
0000AE76  1031 1000               6013      MOVE.b  (a1,d1.w),d0            ; get character from output string
0000AE7A  5381                    6014      SUBQ.l  #1,d1                   ; decrement output string index
0000AE7C  B03C 0030               6015      CMP.b       #'0',d0             ; compare with "0"
0000AE80  67F4                    6016      BEQ.s       LAB_2A4B                ; loop until non "0" character found
0000AE82                          6017  
0000AE82  B03C 002E               6018      CMP.b       #'.',d0             ; compare with "."
0000AE86  6702                    6019      BEQ.s       LAB_2A58                ; branch if was dp
0000AE88                          6020  
0000AE88                          6021                                  ; else restore last character
0000AE88  5281                    6022      ADDQ.l  #1,d1                   ; increment output string index
0000AE8A                          6023  LAB_2A58
0000AE8A  13BC 002B 1002          6024      MOVE.b  #'+',2(a1,d1.w)         ; save character "+" to output string
0000AE90  4A2B 05AD               6025      TST.b       expcnt(a3)              ; test exponent count
0000AE94  6738                    6026      BEQ.s       LAB_2A8C                ; if zero go set null terminator & exit
0000AE96                          6027  
0000AE96                          6028                                  ; exponent isn't zero so write exponent
0000AE96  6A0A                    6029      BPL.s       LAB_2A68                ; branch if exponent count +ve
0000AE98                          6030  
0000AE98  13BC 002D 1002          6031      MOVE.b  #'-',2(a1,d1.w)         ; save character "-" to output string
0000AE9E  442B 05AD               6032      NEG.b       expcnt(a3)              ; convert -ve to +ve
0000AEA2                          6033  LAB_2A68
0000AEA2  13BC 0045 1001          6034      MOVE.b  #'E',1(a1,d1.w)         ; save character "E" to output string
0000AEA8  142B 05AD               6035      MOVE.b  expcnt(a3),d2           ; get exponent count
0000AEAC  702F                    6036      MOVEQ       #$2F,d0             ; one less than "0" character
0000AEAE                          6037  LAB_2A74
0000AEAE  5200                    6038      ADDQ.b  #1,d0                   ; increment 10's character
0000AEB0  0402 000A               6039      SUB.b       #$0A,d2             ; subtract 10 from exponent count
0000AEB4  64F8                    6040      BCC.s       LAB_2A74                ; loop while still >= 0
0000AEB6                          6041  
0000AEB6  0602 003A               6042      ADD.b       #$3A,d2             ; add character ":", $30+$0A, result is 10-value
0000AEBA  1380 1003               6043      MOVE.b  d0,3(a1,d1.w)           ; save 10's character to output string
0000AEBE  1382 1004               6044      MOVE.b  d2,4(a1,d1.w)           ; save 1's character to output string
0000AEC2  13BC 0000 1005          6045      MOVE.b  #0,5(a1,d1.w)           ; save null terminator after last character
0000AEC8  600A                    6046      BRA.s       LAB_2A91                ; go set string pointer (a0) and exit
0000AECA                          6047  
0000AECA                          6048  LAB_2A89
0000AECA  1380 1000               6049      MOVE.b  d0,(a1,d1.w)            ; save last character to output string
0000AECE                          6050  LAB_2A8C
0000AECE  13BC 0000 1001          6051      MOVE.b  #0,1(a1,d1.w)           ; save null terminator after last character
0000AED4                          6052  LAB_2A91
0000AED4  2049                    6053      MOVEA.l a1,a0                   ; set result string pointer (a0)
0000AED6  4E75                    6054      RTS
0000AED8                          6055  
0000AED8                          6056  
0000AED8                          6057  ;************************************************************************************
0000AED8                          6058  ;
0000AED8                          6059  ; fast compare FAC1 with FAC2
0000AED8                          6060  ; assumes both are +ve and FAC2>0
0000AED8                          6061  ; returns d0=+1 C=0 if FAC1 > FAC2
0000AED8                          6062  ; returns d0= 0 C=0 if FAC1 = FAC2
0000AED8                          6063  ; returns d0=-1 C=1 if FAC1 < FAC2
0000AED8                          6064  
0000AED8                          6065  LAB_27F0
0000AED8  7000                    6066      MOVEQ       #0,d0                   ; set for FAC1 = FAC2
0000AEDA  122B 059C               6067      MOVE.b  FAC2_e(a3),d1           ; get FAC2 exponent
0000AEDE  B22B 0594               6068      CMP.b       FAC1_e(a3),d1           ; compare FAC1 exponent with FAC2 exponent
0000AEE2  660A                    6069      BNE.s       LAB_27F1                ; branch if different
0000AEE4                          6070  
0000AEE4  222B 0598               6071      MOVE.l  FAC2_m(a3),d1           ; get FAC2 mantissa
0000AEE8  B2AB 0590               6072      CMP.l       FAC1_m(a3),d1           ; compare mantissas
0000AEEC  6708                    6073      BEQ.s       LAB_27F3                ; exit if mantissas equal
0000AEEE                          6074  
0000AEEE                          6075  LAB_27F1
0000AEEE  6504                    6076      BCS.s       LAB_27F2                ; if FAC1 > FAC2 return d0=+1,C=0
0000AEF0                          6077  
0000AEF0  5380                    6078      SUBQ.l  #1,d0                   ; else FAC1 < FAC2 return d0=-1,C=1
0000AEF2  4E75                    6079      RTS
0000AEF4                          6080  
0000AEF4                          6081  LAB_27F2
0000AEF4  5280                    6082      ADDQ.l  #1,d0
0000AEF6                          6083  LAB_27F3
0000AEF6  4E75                    6084      RTS
0000AEF8                          6085  
0000AEF8                          6086  
0000AEF8                          6087  ;************************************************************************************
0000AEF8                          6088  ;
0000AEF8                          6089  ; make FAC1 = 1
0000AEF8                          6090  
0000AEF8                          6091  LAB_POON
0000AEF8  277C 80000000 0590      6092      MOVE.l  #$80000000,FAC1_m(a3)       ; 1 mantissa
0000AF00  377C 8100 0594          6093      MOVE.w  #$8100,FAC1_e(a3)           ; 1 exonent & sign
0000AF06  4E75                    6094      RTS
0000AF08                          6095  
0000AF08                          6096  
0000AF08                          6097  ;************************************************************************************
0000AF08                          6098  ;
0000AF08                          6099  ; make FAC1 = 0
0000AF08                          6100  
0000AF08                          6101  LAB_POZE
0000AF08  7000                    6102      MOVEQ       #0,d0                   ; clear longword
0000AF0A  2740 0590               6103      MOVE.l  d0,FAC1_m(a3)           ; 0 mantissa
0000AF0E  3740 0594               6104      MOVE.w  d0,FAC1_e(a3)           ; 0 exonent & sign
0000AF12  4E75                    6105      RTS
0000AF14                          6106  
0000AF14                          6107  
0000AF14                          6108  ;************************************************************************************
0000AF14                          6109  ;
0000AF14                          6110  ; perform power function
0000AF14                          6111  ; the number is in FAC2, the power is in FAC1
0000AF14                          6112  ; no longer trashes Itemp
0000AF14                          6113  
0000AF14                          6114  LAB_POWER
0000AF14  4A2B 0594               6115      TST.b       FAC1_e(a3)              ; test power
0000AF18  67DE                    6116      BEQ.s       LAB_POON                ; if zero go return 1
0000AF1A                          6117  
0000AF1A  4A2B 059C               6118      TST.b       FAC2_e(a3)              ; test number
0000AF1E  67E8                    6119      BEQ.s       LAB_POZE                ; if zero go return 0
0000AF20                          6120  
0000AF20  1F2B 059D               6121      MOVE.b  FAC2_s(a3),-(sp)            ; save number sign
0000AF24  6A20                    6122      BPL.s       LAB_POWP                ; power of positive number
0000AF26                          6123  
0000AF26  7200                    6124      MOVEQ       #0,d1                   ; clear d1
0000AF28  1741 059D               6125      MOVE.b  d1,FAC2_s(a3)           ; make sign +ve
0000AF2C                          6126  
0000AF2C                          6127                                  ; number sign was -ve and can only be raised to
0000AF2C                          6128                                  ; an integer power which gives an x +j0 result,
0000AF2C                          6129                                  ; else do 'function call' error
0000AF2C  122B 0594               6130      MOVE.b  FAC1_e(a3),d1           ; get power exponent
0000AF30  0441 0080               6131      SUB.w       #$80,d1             ; normalise to .5
0000AF34  6300 E218               6132      BLS     LAB_FCER                ; if 0<power<1 then do 'function call' error
0000AF38                          6133  
0000AF38                          6134                                  ; now shift all the integer bits out
0000AF38  202B 0590               6135      MOVE.l  FAC1_m(a3),d0           ; get power mantissa
0000AF3C  E3A0                    6136      ASL.l       d1,d0                   ; shift mantissa
0000AF3E  6600 E20E               6137      BNE     LAB_FCER                ; if power<>INT(power) then do 'function call'
0000AF42                          6138                                  ; error
0000AF42                          6139  
0000AF42  6502                    6140      BCS.s       LAB_POWP                ; if integer value odd then leave result -ve
0000AF44                          6141  
0000AF44  1E80                    6142      MOVE.b  d0,(sp)             ; save result sign +ve
0000AF46                          6143  LAB_POWP
0000AF46  2F2B 0590               6144      MOVE.l  FAC1_m(a3),-(sp)            ; save power mantissa
0000AF4A  3F2B 0594               6145      MOVE.w  FAC1_e(a3),-(sp)            ; save power sign & exponent
0000AF4E                          6146  
0000AF4E  6100 FC74               6147      BSR     LAB_279B                ; copy number to FAC1
0000AF52  6100 F9E4               6148      BSR     LAB_LOG             ; find log of number
0000AF56                          6149  
0000AF56  301F                    6150      MOVE.w  (sp)+,d0                ; get power sign & exponent
0000AF58  275F 0598               6151      MOVE.l  (sp)+,FAC2_m(a3)            ; get power mantissa
0000AF5C  3740 059C               6152      MOVE.w  d0,FAC2_e(a3)           ; save sign & exponent to FAC2
0000AF60  1740 059E               6153      MOVE.b  d0,FAC_sc(a3)           ; save sign as sign compare
0000AF64  102B 0595               6154      MOVE.b  FAC1_s(a3),d0           ; get FAC1 sign
0000AF68  B12B 059E               6155      EOR.b       d0,FAC_sc(a3)           ; make sign compare (FAC1_s EOR FAC2_s)
0000AF6C                          6156  
0000AF6C  6100 FABC               6157      BSR     LAB_MULTIPLY            ; multiply by power
0000AF70  6158                    6158      BSR.s       LAB_EXP             ; find exponential
0000AF72  175F 0595               6159      MOVE.b  (sp)+,FAC1_s(a3)            ; restore number sign
0000AF76  4E75                    6160      RTS
0000AF78                          6161  
0000AF78                          6162  
0000AF78                          6163  ;************************************************************************************
0000AF78                          6164  ;
0000AF78                          6165  ; do - FAC1
0000AF78                          6166  
0000AF78                          6167  LAB_GTHAN
0000AF78  4A2B 0594               6168      TST.b       FAC1_e(a3)              ; test for non zero FAC1
0000AF7C  6706                    6169      BEQ.s       RTS_020             ; branch if null
0000AF7E                          6170  
0000AF7E  0A2B 0080 0595          6171      EORI.b  #$80,FAC1_s(a3)         ; (else) toggle FAC1 sign bit
0000AF84                          6172  RTS_020
0000AF84  4E75                    6173      RTS
0000AF86                          6174  
0000AF86                          6175  
0000AF86                          6176  ;************************************************************************************
0000AF86                          6177  ;
0000AF86                          6178                                  ; return +1
0000AF86                          6179  LAB_EX1
0000AF86  277C 80000000 0590      6180      MOVE.l  #$80000000,FAC1_m(a3)       ; +1 mantissa
0000AF8E  377C 8100 0594          6181      MOVE.w  #$8100,FAC1_e(a3)           ; +1 sign & exponent
0000AF94  4E75                    6182      RTS
0000AF96                          6183                                  ; do over/under flow
0000AF96                          6184  LAB_EXOU
0000AF96  4A2B 0595               6185      TST.b       FAC1_s(a3)              ; test sign
0000AF9A  6A00 E1AE               6186      BPL     LAB_OFER                ; was +ve so do overflow error
0000AF9E                          6187  
0000AF9E                          6188                                  ; else underflow so return zero
0000AF9E  7000                    6189      MOVEQ       #0,d0                   ; clear longword
0000AFA0  2740 0590               6190      MOVE.l  d0,FAC1_m(a3)           ; 0 mantissa
0000AFA4  3740 0594               6191      MOVE.w  d0,FAC1_e(a3)           ; 0 sign & exponent
0000AFA8  4E75                    6192      RTS
0000AFAA                          6193                                  ; fraction was zero so do 2^n
0000AFAA                          6194  LAB_EXOF
0000AFAA  277C 80000000 0590      6195      MOVE.l  #$80000000,FAC1_m(a3)       ; +n mantissa
0000AFB2  177C 0000 0595          6196      MOVE.b  #0,FAC1_s(a3)           ; clear sign
0000AFB8  4A2B 05B4               6197      TST.b       cosout(a3)              ; test sign flag
0000AFBC  6A02                    6198      BPL.s       LAB_EXOL                ; branch if +ve
0000AFBE                          6199  
0000AFBE  4481                    6200      NEG.l       d1                  ; else do 1/2^n
0000AFC0                          6201  LAB_EXOL
0000AFC0  0601 0081               6202      ADD.b       #$81,d1             ; adjust exponent
0000AFC4  1741 0594               6203      MOVE.b  d1,FAC1_e(a3)           ; save exponent
0000AFC8  4E75                    6204      RTS
0000AFCA                          6205  
0000AFCA                          6206  ; perform EXP() (x^e)
0000AFCA                          6207  ; valid input range is -88 to +88
0000AFCA                          6208  
0000AFCA                          6209  LAB_EXP
0000AFCA  102B 0594               6210      MOVE.b  FAC1_e(a3),d0           ; get exponent
0000AFCE  67B6                    6211      BEQ.s       LAB_EX1             ; return 1 for zero in
0000AFD0                          6212  
0000AFD0  B03C 0064               6213      CMP.b       #$64,d0             ; compare exponent with min
0000AFD4  65B0                    6214      BCS.s       LAB_EX1             ; if smaller just return 1
0000AFD6                          6215  
0000AFD6                          6216  ;   MOVEM.l d1-d6/a0,-(sp)          ; save the registers
0000AFD6  177C 0000 05B4          6217      MOVE.b  #0,cosout(a3)           ; flag +ve number
0000AFDC  222B 0590               6218      MOVE.l  FAC1_m(a3),d1           ; get mantissa
0000AFE0  B03C 0087               6219      CMP.b       #$87,d0             ; compare exponent with max
0000AFE4  62B0                    6220      BHI.s       LAB_EXOU                ; go do over/under flow if greater
0000AFE6                          6221  
0000AFE6  6608                    6222      BNE.s       LAB_EXCM                ; branch if less
0000AFE8                          6223  
0000AFE8                          6224                                  ; else is 2^7
0000AFE8  B2BC B00F33C7           6225      CMP.l       #$B00F33C7,d1           ; compare mantissa with n*2^7 max
0000AFEE  64A6                    6226      BCC.s       LAB_EXOU                ; if => go over/underflow
0000AFF0                          6227  
0000AFF0                          6228  LAB_EXCM
0000AFF0  4A2B 0595               6229      TST.b       FAC1_s(a3)              ; test sign
0000AFF4  6A0C                    6230      BPL.s       LAB_EXPS                ; branch if arg +ve
0000AFF6                          6231  
0000AFF6  177C 00FF 05B4          6232      MOVE.b  #$FF,cosout(a3)         ; flag -ve number
0000AFFC  177C 0000 0595          6233      MOVE.b  #0,FAC1_s(a3)           ; take absolute value
0000B002                          6234  LAB_EXPS
0000B002                          6235                                  ; now do n/LOG(2)
0000B002  277C B8AA3B29 0598      6236      MOVE.l  #$B8AA3B29,FAC2_m(a3)       ; 1/LOG(2) mantissa
0000B00A  377C 8100 059C          6237      MOVE.w  #$8100,FAC2_e(a3)           ; 1/LOG(2) exponent & sign
0000B010  177C 0000 059E          6238      MOVE.b  #0,FAC_sc(a3)           ; we know they're both +ve
0000B016  6100 FA12               6239      BSR     LAB_MULTIPLY            ; effectively divide by log(2)
0000B01A                          6240  
0000B01A                          6241                                  ; max here is +/- 127
0000B01A                          6242                                  ; now separate integer and fraction
0000B01A  177C 0000 05D9          6243      MOVE.b  #0,tpower(a3)           ; clear exponent add byte
0000B020  1A2B 0594               6244      MOVE.b  FAC1_e(a3),d5           ; get exponent
0000B024  0405 0080               6245      SUB.b       #$80,d5             ; normalise
0000B028  6324                    6246      BLS.s       LAB_ESML                ; branch if < 1 (d5 is 0 or -ve)
0000B02A                          6247  
0000B02A                          6248                                  ; result is > 1
0000B02A  202B 0590               6249      MOVE.l  FAC1_m(a3),d0           ; get mantissa
0000B02E  2200                    6250      MOVE.l  d0,d1                   ; copy it
0000B030  2C05                    6251      MOVE.l  d5,d6                   ; copy normalised exponent
0000B032                          6252  
0000B032  4446                    6253      NEG.w       d6                  ; make -ve
0000B034  0646 0020               6254      ADD.w       #32,d6              ; is now 32-d6
0000B038  ECA9                    6255      LSR.l       d6,d1                   ; just integer bits
0000B03A  1741 05D9               6256      MOVE.b  d1,tpower(a3)           ; set exponent add byte
0000B03E                          6257  
0000B03E  EBA8                    6258      LSL.l       d5,d0                   ; shift out integer bits
0000B040  6700 FF68               6259      BEQ     LAB_EXOF                ; fraction is zero so do 2^n
0000B044                          6260  
0000B044  2740 0590               6261      MOVE.l  d0,FAC1_m(a3)           ; fraction to FAC1
0000B048  377C 8000 0594          6262      MOVE.w  #$8000,FAC1_e(a3)           ; set exponent & sign
0000B04E                          6263  
0000B04E                          6264                                  ; multiple was < 1
0000B04E                          6265  LAB_ESML
0000B04E  277C B17217F8 0598      6266      MOVE.l  #$B17217F8,FAC2_m(a3)       ; LOG(2) mantissa
0000B056  377C 8000 059C          6267      MOVE.w  #$8000,FAC2_e(a3)           ; LOG(2) exponent & sign
0000B05C  177C 0000 059E          6268      MOVE.b  #0,FAC_sc(a3)           ; clear sign compare
0000B062  6100 F9C6               6269      BSR     LAB_MULTIPLY            ; multiply by log(2)
0000B066                          6270  
0000B066  202B 0590               6271      MOVE.l  FAC1_m(a3),d0           ; get mantissa
0000B06A  1A2B 0594               6272      MOVE.b  FAC1_e(a3),d5           ; get exponent
0000B06E  0445 0082               6273      SUB.w       #$82,d5             ; normalise and -2 (result is -1 to -30)
0000B072  4445                    6274      NEG.w       d5                  ; make +ve
0000B074  EAA8                    6275      LSR.l       d5,d0                   ; shift for 2 integer bits
0000B076                          6276  
0000B076                          6277  ; d0 = arg
0000B076                          6278  ; d6 = x, d1 = y
0000B076                          6279  ; d2 = x1, d3 = y1
0000B076                          6280  ; d4 = shift count
0000B076                          6281  ; d5 = loop count
0000B076                          6282                                  ; now do cordic set-up
0000B076  7200                    6283      MOVEQ       #0,d1                   ; y = 0
0000B078  2C3C 26A3D110           6284      MOVE.l  #KFCTSEED,d6            ; x = 1 with jkh inverse factored out
0000B07E  41FA 0D2C               6285      LEA     TAB_HTHET(pc),a0            ; get pointer to hyperbolic arctan table
0000B082  7800                    6286      MOVEQ       #0,d4                   ; clear shift count
0000B084                          6287   
0000B084                          6288                                  ; cordic loop, shifts 4 and 13 (and 39
0000B084                          6289                                  ; if it went that far) need to be repeated
0000B084  7A03                    6290      MOVEQ       #3,d5                   ; 4 loops
0000B086  6136                    6291      BSR.s       LAB_EXCC                ; do loops 1 through 4
0000B088  5948                    6292      SUBQ.w  #4,a0                   ; do table entry again
0000B08A  5384                    6293      SUBQ.l  #1,d4                   ; do shift count again
0000B08C  7A09                    6294      MOVEQ       #9,d5                   ; 10 loops
0000B08E  612E                    6295      BSR.s       LAB_EXCC                ; do loops 4 (again) through 13
0000B090  5948                    6296      SUBQ.w  #4,a0                   ; do table entry again
0000B092  5384                    6297      SUBQ.l  #1,d4                   ; do shift count again
0000B094  7A12                    6298      MOVEQ       #18,d5              ; 19 loops
0000B096  6126                    6299      BSR.s       LAB_EXCC                ; do loops 13 (again) through 31
0000B098                          6300   
0000B098                          6301                                  ; now get the result
0000B098  4A2B 05B4               6302      TST.b       cosout(a3)              ; test sign flag
0000B09C  6A06                    6303      BPL.s       LAB_EXPL                ; branch if +ve
0000B09E                          6304  
0000B09E  4481                    6305      NEG.l       d1                  ; do -y
0000B0A0  442B 05D9               6306      NEG.b       tpower(a3)              ; do -exp
0000B0A4                          6307  LAB_EXPL
0000B0A4  7083                    6308      MOVEQ       #$83-$100,d0            ; set exponent
0000B0A6  DC81                    6309      ADD.l       d1,d6                   ; y = y +/- x
0000B0A8  6B06                    6310      BMI.s       LAB_EXRN                ; branch if result normal
0000B0AA                          6311  
0000B0AA                          6312  LAB_EXNN
0000B0AA  5380                    6313      SUBQ.l  #1,d0                   ; decrement exponent
0000B0AC  DC86                    6314      ADD.l       d6,d6                   ; shift mantissa
0000B0AE  6AFA                    6315      BPL.s       LAB_EXNN                ; loop if not normal
0000B0B0                          6316  
0000B0B0                          6317  LAB_EXRN
0000B0B0  2746 0590               6318      MOVE.l  d6,FAC1_m(a3)           ; save exponent result
0000B0B4  D02B 05D9               6319      ADD.b       tpower(a3),d0           ; add integer part
0000B0B8  1740 0594               6320      MOVE.b  d0,FAC1_e(a3)           ; save exponent
0000B0BC                          6321  ;   MOVEM.l (sp)+,d1-d6/a0          ; restore registers
0000B0BC  4E75                    6322      RTS
0000B0BE                          6323   
0000B0BE                          6324                                  ; cordic loop
0000B0BE                          6325  LAB_EXCC
0000B0BE  5284                    6326      ADDQ.l  #1,d4                   ; increment shift count
0000B0C0  2406                    6327      MOVE.l  d6,d2                   ; x1 = x
0000B0C2  E8A2                    6328      ASR.l       d4,d2                   ; x1 >> n
0000B0C4  2601                    6329      MOVE.l  d1,d3                   ; y1 = y
0000B0C6  E8A3                    6330      ASR.l       d4,d3                   ; y1 >> n
0000B0C8  4A80                    6331      TST.l       d0                  ; test arg
0000B0CA  6B0C                    6332      BMI.s       LAB_EXAD                ; branch if -ve
0000B0CC                          6333  
0000B0CC  D282                    6334      ADD.l       d2,d1                   ; y = y + x1
0000B0CE  DC83                    6335      ADD.l       d3,d6                   ; x = x + y1
0000B0D0  9098                    6336      SUB.l       (a0)+,d0                ; arg = arg - atnh(a0)
0000B0D2  51CD FFEA               6337      DBF     d5,LAB_EXCC             ; decrement and loop if not done
0000B0D6                          6338  
0000B0D6  4E75                    6339      RTS
0000B0D8                          6340  
0000B0D8                          6341  LAB_EXAD
0000B0D8  9282                    6342      SUB.l       d2,d1                   ; y = y - x1
0000B0DA  9C83                    6343      SUB.l       d3,d6                   ; x = x + y1
0000B0DC  D098                    6344      ADD.l       (a0)+,d0                ; arg = arg + atnh(a0)
0000B0DE  51CD FFDE               6345      DBF     d5,LAB_EXCC             ; decrement and loop if not done
0000B0E2                          6346  
0000B0E2  4E75                    6347      RTS
0000B0E4                          6348  
0000B0E4                          6349  
0000B0E4                          6350  ;************************************************************************************
0000B0E4                          6351  ;
0000B0E4                          6352  ; RND(n), 32 bit Galois version. make n=0 for 19th next number in sequence or n<>0
0000B0E4                          6353  ; to get 19th next number in sequence after seed n. This version of the PRNG uses
0000B0E4                          6354  ; the Galois method and a sample of 65536 bytes produced gives the following values.
0000B0E4                          6355  
0000B0E4                          6356  ; Entropy = 7.997442 bits per byte
0000B0E4                          6357  ; Optimum compression would reduce these 65536 bytes by 0 percent
0000B0E4                          6358  
0000B0E4                          6359  ; Chi square distribution for 65536 samples is 232.01, and
0000B0E4                          6360  ; randomly would exceed this value 75.00 percent of the time
0000B0E4                          6361  
0000B0E4                          6362  ; Arithmetic mean value of data bytes is 127.6724, 127.5 would be random
0000B0E4                          6363  ; Monte Carlo value for Pi is 3.122871269, error 0.60 percent
0000B0E4                          6364  ; Serial correlation coefficient is -0.000370, totally uncorrelated would be 0.0
0000B0E4                          6365  
0000B0E4                          6366  LAB_RND
0000B0E4  4A2B 0594               6367      TST.b       FAC1_e(a3)              ; get FAC1 exponent
0000B0E8  6708                    6368      BEQ.s       NextPRN             ; do next random number if zero
0000B0EA                          6369  
0000B0EA                          6370                                  ; else get seed into random number store
0000B0EA  41EB 05A0               6371      LEA     PRNlword(a3),a0         ; set PRNG pointer
0000B0EE  6100 FAAE               6372      BSR     LAB_2778                ; pack FAC1 into (a0)
0000B0F2                          6373  NextPRN
0000B0F2  72AF                    6374      MOVEQ       #$AF-$100,d1            ; set EOR value
0000B0F4  7412                    6375      MOVEQ       #18,d2              ; do this 19 times
0000B0F6  202B 05A0               6376      MOVE.l  PRNlword(a3),d0         ; get current
0000B0FA                          6377  Ninc0
0000B0FA  D080                    6378      ADD.l       d0,d0                   ; shift left 1 bit
0000B0FC  6402                    6379      BCC.s       Ninc1                   ; branch if bit 32 not set
0000B0FE                          6380  
0000B0FE  B300                    6381      EOR.b       d1,d0                   ; do Galois LFSR feedback
0000B100                          6382  Ninc1
0000B100  51CA FFF8               6383      DBF     d2,Ninc0                ; loop
0000B104                          6384  
0000B104  2740 05A0               6385      MOVE.l  d0,PRNlword(a3)         ; save back to seed word
0000B108  2740 0590               6386      MOVE.l  d0,FAC1_m(a3)           ; copy to FAC1 mantissa
0000B10C  377C 8000 0594          6387      MOVE.w  #$8000,FAC1_e(a3)           ; set the exponent and clear the sign
0000B112  6000 F7EE               6388      BRA     LAB_24D5                ; normalise FAC1 & return
0000B116                          6389  
0000B116                          6390  
0000B116                          6391  ;************************************************************************************
0000B116                          6392  ;
0000B116                          6393  ; cordic TAN(x) routine, TAN(x) = SIN(x)/COS(x)
0000B116                          6394  ; x = angle in radians
0000B116                          6395  
0000B116                          6396  LAB_TAN
0000B116  6138                    6397      BSR.s       LAB_SIN             ; go do SIN/COS cordic compute
0000B118  376B 0594 059C          6398      MOVE.w  FAC1_e(a3),FAC2_e(a3)       ; copy exponent & sign from FAC1 to FAC2
0000B11E  276B 0590 0598          6399      MOVE.l  FAC1_m(a3),FAC2_m(a3)       ; copy FAC1 mantissa to FAC2 mantissa
0000B124  2741 0590               6400      MOVE.l  d1,FAC1_m(a3)           ; get COS(x) mantissa
0000B128  1743 0594               6401      MOVE.b  d3,FAC1_e(a3)           ; get COS(x) exponent
0000B12C  6700 E01C               6402      BEQ     LAB_OFER                ; do overflow if COS = 0
0000B130                          6403  
0000B130  6100 F7D0               6404      BSR     LAB_24D5                ; normalise FAC1
0000B134  6000 F980               6405      BRA     LAB_DIVIDE              ; do FAC2/FAC1 and return, FAC_sc set by SIN
0000B138                          6406                                  ; COS calculation
0000B138                          6407  
0000B138                          6408  
0000B138                          6409  ;************************************************************************************
0000B138                          6410  ;
0000B138                          6411  ; cordic SIN(x), COS(x) routine
0000B138                          6412  ; x = angle in radians
0000B138                          6413  
0000B138                          6414  LAB_COS
0000B138  277C C90FDAA3 0598      6415      MOVE.l  #$C90FDAA3,FAC2_m(a3)       ; pi/2 mantissa (LSB is rounded up so
0000B140                          6416                                  ; COS(PI/2)=0)
0000B140  377C 8100 059C          6417      MOVE.w  #$8100,FAC2_e(a3)           ; pi/2 exponent and sign
0000B146  176B 0595 059E          6418      MOVE.b  FAC1_s(a3),FAC_sc(a3)       ; sign = FAC1 sign (b7)
0000B14C  6100 F738               6419      BSR     LAB_ADD             ; add FAC2 to FAC1, adjust for COS(x)
0000B150                          6420  
0000B150                          6421  
0000B150                          6422  ;************************************************************************************
0000B150                          6423  ;
0000B150                          6424  ; SIN/COS cordic calculator
0000B150                          6425  
0000B150                          6426  LAB_SIN
0000B150  177C 0000 05B4          6427      MOVE.b  #0,cosout(a3)           ; set needed result
0000B156                          6428  
0000B156  277C A2F9836F 0598      6429      MOVE.l  #$A2F9836F,FAC2_m(a3)       ; 1/pi mantissa (LSB is rounded up so SIN(PI)=0)
0000B15E  377C 7F00 059C          6430      MOVE.w  #$7F00,FAC2_e(a3)           ; 1/pi exponent & sign
0000B164  176B 0595 059E          6431      MOVE.b  FAC1_s(a3),FAC_sc(a3)       ; sign = FAC1 sign (b7)
0000B16A  6100 F8BE               6432      BSR     LAB_MULTIPLY            ; multiply by 1/pi
0000B16E                          6433  
0000B16E  102B 0594               6434      MOVE.b  FAC1_e(a3),d0           ; get FAC1 exponent
0000B172  671C                    6435      BEQ.s       LAB_SCZE                ; branch if zero
0000B174                          6436  
0000B174  41FA 0B36               6437      LEA     TAB_SNCO(pc),a0         ; get pointer to constants table
0000B178  2C2B 0590               6438      MOVE.l  FAC1_m(a3),d6           ; get FAC1 mantissa
0000B17C  5300                    6439      SUBQ.b  #1,d0                   ; 2 radians in 360 degrees so /2
0000B17E  6710                    6440      BEQ.s       LAB_SCZE                ; branch if zero
0000B180                          6441  
0000B180  0400 0080               6442      SUB.b       #$80,d0             ; normalise exponent
0000B184  6B18                    6443      BMI.s       LAB_SCL0                ; branch if < 1
0000B186                          6444  
0000B186                          6445                                  ; X is > 1
0000B186  B03C 0020               6446      CMP.b       #$20,d0             ; is it >= 2^32
0000B18A  6404                    6447      BCC.s       LAB_SCZE                ; may as well do zero
0000B18C                          6448  
0000B18C  E1AE                    6449      LSL.l       d0,d6                   ; shift out integer part bits
0000B18E  6618                    6450      BNE.s       LAB_CORD                ; if fraction go test quadrant and adjust
0000B190                          6451  
0000B190                          6452                                  ; else no fraction so do zero
0000B190                          6453  LAB_SCZE
0000B190  7481                    6454      MOVEQ       #$81-$100,d2            ; set exponent for 1.0
0000B192  7600                    6455      MOVEQ       #0,d3                   ; set exponent for 0.0
0000B194  203C 80000000           6456      MOVE.l  #$80000000,d0           ; mantissa for 1.0
0000B19A  2203                    6457      MOVE.l  d3,d1                   ; mantissa for 0.0
0000B19C  6062                    6458      BRA.s       outloop             ; go output it
0000B19E                          6459  
0000B19E                          6460                                  ; x is < 1
0000B19E                          6461  LAB_SCL0
0000B19E  4400                    6462      NEG.b       d0                  ; make +ve
0000B1A0  B03C 001E               6463      CMP.b       #$1E,d0             ; is it <= 2^-30
0000B1A4  64EA                    6464      BCC.s       LAB_SCZE                ; may as well do zero
0000B1A6                          6465  
0000B1A6  E0AE                    6466      LSR.l       d0,d6                   ; shift out <= 2^-32 bits
0000B1A8                          6467  
0000B1A8                          6468  ; cordic calculator, argument in d6
0000B1A8                          6469  ; table pointer in a0, returns in d0-d3
0000B1A8                          6470  
0000B1A8                          6471  LAB_CORD
0000B1A8  176B 0595 059E          6472      MOVE.b  FAC1_s(a3),FAC_sc(a3)       ; copy as sign compare for TAN
0000B1AE  DC86                    6473      ADD.l       d6,d6                   ; shift 0.5 bit into carry
0000B1B0  6406                    6474      BCC.s       LAB_LTPF                ; branch if less than 0.5
0000B1B2                          6475  
0000B1B2  0A2B 00FF 0595          6476      EORI.b  #$FF,FAC1_s(a3)         ; toggle result sign
0000B1B8                          6477  LAB_LTPF
0000B1B8  DC86                    6478      ADD.l       d6,d6                   ; shift 0.25 bit into carry
0000B1BA  640C                    6479      BCC.s       LAB_LTPT                ; branch if less than 0.25
0000B1BC                          6480  
0000B1BC  0A2B 00FF 05B4          6481      EORI.b  #$FF,cosout(a3)         ; toggle needed result
0000B1C2  0A2B 00FF 059E          6482      EORI.b  #$FF,FAC_sc(a3)         ; toggle sign compare for TAN
0000B1C8                          6483  
0000B1C8                          6484  LAB_LTPT
0000B1C8  E48E                    6485      LSR.l       #2,d6                   ; shift the bits back (clear integer bits)
0000B1CA  67C4                    6486      BEQ.s       LAB_SCZE                ; no fraction so go do zero
0000B1CC                          6487  
0000B1CC                          6488                                  ; set start values
0000B1CC  7A01                    6489      MOVEQ       #1,d5                   ; set bit count
0000B1CE  2028 FFFC               6490      MOVE.l  -4(a0),d0               ; get multiply constant (1st itteration d0)
0000B1D2  2200                    6491      MOVE.l  d0,d1                   ; 1st itteration d1
0000B1D4  9C98                    6492      SUB.l       (a0)+,d6                ; 1st always +ve so do 1st step
0000B1D6  6008                    6493      BRA.s       mainloop                ; jump into routine
0000B1D8                          6494  
0000B1D8                          6495  subloop
0000B1D8  9C98                    6496      SUB.l       (a0)+,d6                ; z = z - arctan(i)/2pi
0000B1DA  9083                    6497      SUB.l       d3,d0                   ; x = x - y1
0000B1DC  D282                    6498      ADD.l       d2,d1                   ; y = y + x1
0000B1DE  6012                    6499      BRA.s       nexta                   ; back to main loop
0000B1E0                          6500  
0000B1E0                          6501  mainloop
0000B1E0  2400                    6502      MOVE.l  d0,d2                   ; x1 = x
0000B1E2  EAA2                    6503      ASR.l       d5,d2                   ; / (2 ^ i)
0000B1E4  2601                    6504      MOVE.l  d1,d3                   ; y1 = y
0000B1E6  EAA3                    6505      ASR.l       d5,d3                   ; / (2 ^ i)
0000B1E8  4A86                    6506      TST.l       d6                  ; test sign (is 2^0 bit)
0000B1EA  6AEC                    6507      BPL.s       subloop             ; go do subtract if > 1
0000B1EC                          6508  
0000B1EC  DC98                    6509      ADD.l       (a0)+,d6                ; z = z + arctan(i)/2pi
0000B1EE  D083                    6510      ADD.l       d3,d0                   ; x = x + y1
0000B1F0  9282                    6511      SUB.l       d2,d1                   ; y = y + x1
0000B1F2                          6512  nexta
0000B1F2  5285                    6513      ADDQ.l  #1,d5                   ; i = i + 1
0000B1F4  BABC 0000001E           6514      CMP.l       #$1E,d5             ; check end condition
0000B1FA  66E4                    6515      BNE.s       mainloop                ; loop if not all done
0000B1FC                          6516  
0000B1FC                          6517                                  ; now untangle output value
0000B1FC  7481                    6518      MOVEQ       #$81-$100,d2            ; set exponent for 0 to .99 rec.
0000B1FE  2602                    6519      MOVE.l  d2,d3                   ; copy it for cos output
0000B200                          6520  outloop
0000B200  4A2B 05B4               6521      TST.b       cosout(a3)              ; did we want cos output?
0000B204  6B04                    6522      BMI.s       subexit             ; if so skip
0000B206                          6523  
0000B206  C141                    6524      EXG     d0,d1                   ; swap SIN and COS mantissas
0000B208  C543                    6525      EXG     d2,d3                   ; swap SIN and COS exponents
0000B20A                          6526  subexit
0000B20A  2740 0590               6527      MOVE.l  d0,FAC1_m(a3)           ; set result mantissa
0000B20E  1742 0594               6528      MOVE.b  d2,FAC1_e(a3)           ; set result exponent
0000B212  6000 F6EE               6529      BRA     LAB_24D5                ; normalise FAC1 & return
0000B216                          6530  
0000B216                          6531  
0000B216                          6532  
0000B216                          6533  ;************************************************************************************
0000B216                          6534  ;
0000B216                          6535  ; perform ATN()
0000B216                          6536  
0000B216                          6537  LAB_ATN
0000B216  102B 0594               6538      MOVE.b  FAC1_e(a3),d0           ; get FAC1 exponent
0000B21A  6700 00AC               6539      BEQ     RTS_021             ; ATN(0) = 0 so skip calculation
0000B21E                          6540  
0000B21E  177C 0000 05B4          6541      MOVE.b  #0,cosout(a3)           ; set result needed
0000B224  B03C 0081               6542      CMP.b       #$81,d0             ; compare exponent with 1
0000B228  6528                    6543      BCS.s       LAB_ATLE                ; branch if n<1
0000B22A                          6544  
0000B22A  6608                    6545      BNE.s       LAB_ATGO                ; branch if n>1
0000B22C                          6546  
0000B22C  202B 0590               6547      MOVE.l  FAC1_m(a3),d0           ; get mantissa
0000B230  D080                    6548      ADD.l       d0,d0                   ; shift left
0000B232  671E                    6549      BEQ.s       LAB_ATLE                ; branch if n=1
0000B234                          6550  
0000B234                          6551  LAB_ATGO
0000B234  277C 80000000 0598      6552      MOVE.l  #$80000000,FAC2_m(a3)       ; set mantissa for 1
0000B23C  377C 8100 059C          6553      MOVE.w  #$8100,FAC2_e(a3)           ; set exponent for 1
0000B242  176B 0595 059E          6554      MOVE.b  FAC1_s(a3),FAC_sc(a3)       ; sign compare = sign
0000B248  6100 F86C               6555      BSR     LAB_DIVIDE              ; do 1/n
0000B24C  177C 00FF 05B4          6556      MOVE.b  #$FF,cosout(a3)         ; set inverse result needed
0000B252                          6557  LAB_ATLE
0000B252  202B 0590               6558      MOVE.l  FAC1_m(a3),d0           ; get FAC1 mantissa
0000B256  123C 0082               6559      MOVE.b      #$82,d1             ; set to correct exponent
0000B25A  922B 0594               6560      SUB.b       FAC1_e(a3),d1           ; subtract FAC1 exponent (always <= 1)
0000B25E  E2A8                    6561      LSR.l       d1,d0                   ; shift in two integer part bits
0000B260  41FA 0ACA               6562      LEA     TAB_ATNC(pc),a0         ; get pointer to arctan table
0000B264  7C00                    6563      MOVEQ       #0,d6                   ; Z = 0
0000B266  223C 40000000           6564      MOVE.l  #1<<30,d1               ; y = 1
0000B26C  7A1D                    6565      MOVEQ       #29,d5              ; loop 30 times
0000B26E  7801                    6566      MOVEQ       #1,d4                   ; shift counter
0000B270  6006                    6567      BRA.s       LAB_ATCD                ; enter loop
0000B272                          6568  
0000B272                          6569  LAB_ATNP
0000B272  E8A2                    6570      ASR.l       d4,d2                   ; x1 / 2^i
0000B274  D282                    6571      ADD.l       d2,d1                   ; y = y + x1
0000B276  DC90                    6572      ADD.l       (a0),d6             ; z = z + atn(i)
0000B278                          6573  LAB_ATCD
0000B278  2400                    6574      MOVE.l  d0,d2                   ; x1 = x
0000B27A  2601                    6575      MOVE.l  d1,d3                   ; y1 = y
0000B27C  E8A3                    6576      ASR.l       d4,d3                   ; y1 / 2^i
0000B27E                          6577  LAB_CATN
0000B27E  9083                    6578      SUB.l       d3,d0                   ; x = x - y1
0000B280  6AF0                    6579      BPL.s       LAB_ATNP                ; branch if x >= 0
0000B282                          6580  
0000B282  2002                    6581      MOVE.l  d2,d0                   ; else get x back
0000B284  5848                    6582      ADDQ.w  #4,a0                   ; increment pointer
0000B286  5284                    6583      ADDQ.l  #1,d4                   ; increment i
0000B288  E283                    6584      ASR.l       #1,d3                   ; y1 / 2^i
0000B28A  51CD FFF2               6585      DBF     d5,LAB_CATN             ; decrement and loop if not done
0000B28E                          6586  
0000B28E  177C 0082 0594          6587      MOVE.b  #$82,FAC1_e(a3)         ; set new exponent
0000B294  2746 0590               6588      MOVE.l  d6,FAC1_m(a3)           ; save mantissa
0000B298  6100 F668               6589      BSR     LAB_24D5                ; normalise FAC1
0000B29C                          6590  
0000B29C  4A2B 05B4               6591      TST.b       cosout(a3)              ; was it > 1 ?
0000B2A0  6A26                    6592      BPL.s       RTS_021             ; branch if not
0000B2A2                          6593  
0000B2A2  1E2B 0595               6594      MOVE.b  FAC1_s(a3),d7           ; get sign
0000B2A6  177C 0000 0595          6595      MOVE.b  #0,FAC1_s(a3)           ; clear sign
0000B2AC  277C C90FDAA2 0598      6596      MOVE.l  #$C90FDAA2,FAC2_m(a3)       ; set -(pi/2)
0000B2B4  377C 8180 059C          6597      MOVE.w  #$8180,FAC2_e(a3)           ; set exponent and sign
0000B2BA  177C 00FF 059E          6598      MOVE.b  #$FF,FAC_sc(a3)         ; set sign compare
0000B2C0  6100 F5C4               6599      BSR     LAB_ADD             ; perform addition, FAC2 to FAC1
0000B2C4  1747 0595               6600      MOVE.b  d7,FAC1_s(a3)           ; restore sign
0000B2C8                          6601  RTS_021
0000B2C8  4E75                    6602      RTS
0000B2CA                          6603  
0000B2CA                          6604  
0000B2CA                          6605  ;************************************************************************************
0000B2CA                          6606  ;
0000B2CA                          6607  ; perform BITSET
0000B2CA                          6608  
0000B2CA                          6609  LAB_BITSET
0000B2CA  6100 F49A               6610      BSR     LAB_GADB                ; get two parameters for POKE or WAIT
0000B2CE                          6611                                  ; first parameter in a0, second in d0
0000B2CE  B03C 0008               6612      CMP.b       #$08,d0             ; only 0 to 7 are allowed
0000B2D2  6400 DE7A               6613      BCC     LAB_FCER                ; branch if > 7
0000B2D6                          6614  
0000B2D6  01D0                    6615      BSET        d0,(a0)             ; set bit
0000B2D8  4E75                    6616      RTS
0000B2DA                          6617  
0000B2DA                          6618  
0000B2DA                          6619  ;************************************************************************************
0000B2DA                          6620  ;
0000B2DA                          6621  ; perform BITCLR
0000B2DA                          6622  
0000B2DA                          6623  LAB_BITCLR
0000B2DA  6100 F48A               6624      BSR     LAB_GADB                ; get two parameters for POKE or WAIT
0000B2DE                          6625                                  ; first parameter in a0, second in d0
0000B2DE  B03C 0008               6626      CMP.b       #$08,d0             ; only 0 to 7 are allowed
0000B2E2  6400 DE6A               6627      BCC     LAB_FCER                ; branch if > 7
0000B2E6                          6628  
0000B2E6  0190                    6629      BCLR        d0,(a0)             ; clear bit
0000B2E8  4E75                    6630      RTS
0000B2EA                          6631  
0000B2EA                          6632  
0000B2EA                          6633  ;************************************************************************************
0000B2EA                          6634  ;
0000B2EA                          6635  ; perform BITTST()
0000B2EA                          6636  
0000B2EA                          6637  LAB_BTST
0000B2EA  101D                    6638      MOVE.b  (a5)+,d0                ; increment BASIC pointer
0000B2EC  6100 F478               6639      BSR     LAB_GADB                ; get two parameters for POKE or WAIT
0000B2F0                          6640                                  ; first parameter in a0, second in d0
0000B2F0  B03C 0008               6641      CMP.b       #$08,d0             ; only 0 to 7 are allowed
0000B2F4  6400 DE58               6642      BCC     LAB_FCER                ; branch if > 7
0000B2F8                          6643  
0000B2F8  2200                    6644      MOVE.l  d0,d1                   ; copy bit # to test
0000B2FA  6100 EAA8               6645      BSR     LAB_GBYT                ; get next BASIC byte
0000B2FE  B03C 0029               6646      CMP.b       #')',d0             ; is next character ")"
0000B302  6600 DE56               6647      BNE     LAB_SNER                ; if not ")" go do syntax error, then warm start
0000B306                          6648  
0000B306  6100 EA9A               6649      BSR     LAB_IGBY                ; update execute pointer (to character past ")")
0000B30A  7000                    6650      MOVEQ       #0,d0                   ; set the result as zero
0000B30C  0310                    6651      BTST        d1,(a0)             ; test bit
0000B30E  6700 F908               6652      BEQ     LAB_27DB                ; branch if zero (already correct)
0000B312                          6653  
0000B312  70FF                    6654      MOVEQ       #-1,d0              ; set for -1 result
0000B314  6000 F902               6655      BRA     LAB_27DB                ; go do SGN tail
0000B318                          6656  
0000B318                          6657  
0000B318                          6658  ;************************************************************************************
0000B318                          6659  ;
0000B318                          6660  ; perform USING$()
0000B318                          6661  
0000B318  =00000000               6662  fsd     EQU  0                      ;   (sp) format string descriptor pointer
0000B318  =00000004               6663  fsti    EQU  4                      ;  4(sp) format string this index
0000B318  =00000006               6664  fsli    EQU  6                      ;  6(sp) format string last index
0000B318  =00000008               6665  fsdpi   EQU  8                      ;  8(sp) format string decimal point index
0000B318  =0000000A               6666  fsdc    EQU 10                      ; 10(sp) format string decimal characters
0000B318  =00000008               6667  fend    EQU 12-4                        ;  x(sp) end-4, fsd is popped by itself
0000B318                          6668  
0000B318  =00000023               6669  ofchr   EQU '#'                     ; the overflow character
0000B318                          6670  
0000B318                          6671  LAB_USINGS
0000B318  4A2B 05B5               6672      TST.b       Dtypef(a3)              ; test data type, $80=string
0000B31C  6A00 DDE8               6673      BPL     LAB_FOER                ; if not string type go do format error
0000B320                          6674  
0000B320  246B 0590               6675      MOVEA.l FAC1_m(a3),a2           ; get the format string descriptor pointer
0000B324  3E2A 0004               6676      MOVE.w  4(a2),d7                ; get the format string length
0000B328  6700 DDDC               6677      BEQ     LAB_FOER                ; if null string go do format error
0000B32C                          6678  
0000B32C                          6679  ; clear the format string values
0000B32C                          6680  
0000B32C  7000                    6681      MOVEQ       #0,d0                   ; clear d0
0000B32E  3F00                    6682      MOVE.w  d0,-(sp)                ; clear the format string decimal characters
0000B330  3F00                    6683      MOVE.w  d0,-(sp)                ; clear the format string decimal point index
0000B332  3F00                    6684      MOVE.w  d0,-(sp)                ; clear the format string last index
0000B334  3F00                    6685      MOVE.w  d0,-(sp)                ; clear the format string this index
0000B336  2F0A                    6686      MOVE.l  a2,-(sp)                ; save the format string descriptor pointer
0000B338                          6687  
0000B338                          6688  ; make a null return string for the first string add
0000B338                          6689  
0000B338  7200                    6690      MOVEQ       #0,d1                   ; make a null string
0000B33A  2041                    6691      MOVEA.l d1,a0                   ; with a null pointer
0000B33C  6100 F0C2               6692      BSR     LAB_RTST                ; push a string on the descriptor stack
0000B340                          6693                                  ; a0 = pointer, d1 = length
0000B340                          6694  
0000B340                          6695  ; do the USING$() function next value
0000B340                          6696  
0000B340  101D                    6697      MOVE.b  (a5)+,d0                ; get the next BASIC byte
0000B342                          6698  LAB_U002
0000B342  B03C 002C               6699      CMP.b       #',',d0             ; compare with comma
0000B346  6600 DE12               6700      BNE     LAB_SNER                ; if not "," go do syntax error
0000B34A                          6701  
0000B34A  6100 028E               6702      BSR     LAB_ProcFo              ; process the format string
0000B34E  4A02                    6703      TST.b       d2                  ; test the special characters flag
0000B350  6700 DDB4               6704      BEQ     LAB_FOER                ; if no special characters go do format error
0000B354                          6705  
0000B354  6100 E8EC               6706      BSR     LAB_EVEX                ; evaluate the expression
0000B358  4A2B 05B5               6707      TST.b       Dtypef(a3)              ; test the data type
0000B35C  6B00 DDD0               6708      BMI     LAB_TMER                ; if string type go do type missmatch error
0000B360                          6709  
0000B360  4A2B 0594               6710      TST.b       FAC1_e(a3)              ; test FAC1 exponent
0000B364  6732                    6711      BEQ.s       LAB_U004                ; if FAC1 = 0 skip the rounding
0000B366                          6712  
0000B366  322F 000A               6713      MOVE.w  fsdc(sp),d1             ; get the format string decimal character count
0000B36A  B27C 0008               6714      CMP.w       #8,d1                   ; compare the fraction digit count with 8
0000B36E  6428                    6715      BCC.s       LAB_U004                ; if >= 8 skip the rounding
0000B370                          6716  
0000B370  3001                    6717      MOVE.w  d1,d0                   ; else copy the fraction digit count
0000B372  D241                    6718      ADD.w       d1,d1                   ;   ; 2
0000B374  D240                    6719      ADD.w       d0,d1                   ;   ; 3
0000B376  D241                    6720      ADD.w       d1,d1                   ;   ; 6
0000B378  41FA 0844               6721      LEA     LAB_P_10(pc),a0         ; get the rounding table base
0000B37C  2770 1002 0598          6722      MOVE.l  2(a0,d1.w),FAC2_m(a3)       ; get the rounding mantissa
0000B382  3030 1000               6723      MOVE.w  (a0,d1.w),d0            ; get the rounding exponent
0000B386  0440 0100               6724      SUB.w       #$100,d0                ; effectively divide the mantissa by 2
0000B38A  3740 059C               6725      MOVE.w  d0,FAC2_e(a3)           ; save the rounding exponent
0000B38E  177C 0000 059E          6726      MOVE.b  #$00,FAC_sc(a3)         ; clear the sign compare
0000B394  6100 F4F0               6727      BSR     LAB_ADD             ; round the value to n places
0000B398                          6728  LAB_U004
0000B398  6100 F96E               6729      BSR     LAB_2970                ; convert FAC1 to string - not on stack
0000B39C                          6730  
0000B39C  6100 01FE               6731      BSR     LAB_DupFmt              ; duplicate the processed format string section
0000B3A0                          6732                                  ; returns length in d1, pointer in a0
0000B3A0                          6733  
0000B3A0                          6734  ; process the number string, length in d6, decimal point index in d2
0000B3A0                          6735  
0000B3A0  45EB 05C6               6736      LEA     Decss(a3),a2            ; set the number string start
0000B3A4  7C00                    6737      MOVEQ       #0,d6                   ; clear the number string index
0000B3A6  782E                    6738      MOVEQ       #'.',d4             ; set the decimal point character
0000B3A8                          6739  LAB_U005
0000B3A8  3406                    6740      MOVE.w  d6,d2                   ; save the index to flag the decimal point
0000B3AA                          6741  LAB_U006
0000B3AA  5246                    6742      ADDQ.w  #1,d6                   ; increment the number string index
0000B3AC  1032 6000               6743      MOVE.b  (a2,d6.w),d0            ; get a number string character
0000B3B0  677A                    6744      BEQ.s       LAB_U010                ; if null then number complete
0000B3B2                          6745  
0000B3B2  B03C 0045               6746      CMP.b       #'E',d0             ; compare the character with an "E"
0000B3B6  6706                    6747      BEQ.s       LAB_U008                ; was sx[.x]Esxx so go handle sci notation
0000B3B8                          6748  
0000B3B8  B004                    6749      CMP.b       d4,d0                   ; compare the character with "."
0000B3BA  66EE                    6750      BNE.s       LAB_U006                ; if not decimal point go get the next digit
0000B3BC                          6751  
0000B3BC  60EA                    6752      BRA.s       LAB_U005                ; go save the index and get the next digit
0000B3BE                          6753  
0000B3BE                          6754  ; have found an sx[.x]Esxx number, the [.x] will not be present for a single digit
0000B3BE                          6755  
0000B3BE                          6756  LAB_U008
0000B3BE  3606                    6757      MOVE.w  d6,d3                   ; copy the index to the "E"
0000B3C0  5343                    6758      SUBQ.w  #1,d3                   ; -1 gives the last digit index
0000B3C2                          6759  
0000B3C2  5246                    6760      ADDQ.w  #1,d6                   ; increment the index to the exponent sign
0000B3C4  1032 6000               6761      MOVE.b  (a2,d6.w),d0            ; get the exponent sign character
0000B3C8  B03C 002D               6762      CMP.b       #'-',d0             ; compare the exponent sign with "-"
0000B3CC  6600 DD80               6763      BNE     LAB_FCER                ; if it wasn't sx[.x]E-xx go do function
0000B3D0                          6764                                  ; call error
0000B3D0                          6765  
0000B3D0                          6766  ; found an sx[.x]E-xx number so check the exponent magnitude
0000B3D0                          6767  
0000B3D0  5246                    6768      ADDQ.w  #1,d6                   ; increment the index to the exponent 10s
0000B3D2  1032 6000               6769      MOVE.b  (a2,d6.w),d0            ; get the exponent 10s character
0000B3D6  B03C 0030               6770      CMP.b       #'0',d0             ; compare the exponent 10s with "0"
0000B3DA  6704                    6771      BEQ.s       LAB_U009                ; if it was sx[.x]E-0x go get the exponent
0000B3DC                          6772                                  ; 1s character
0000B3DC                          6773  
0000B3DC  700A                    6774      MOVEQ       #10,d0              ; else start writing at index 10
0000B3DE  6008                    6775      BRA.s       LAB_U00A                ; go copy the digits
0000B3E0                          6776  
0000B3E0                          6777  ; found an sx[.x]E-0x number so get the exponent magnitude
0000B3E0                          6778  
0000B3E0                          6779  LAB_U009
0000B3E0  5246                    6780      ADDQ.w  #1,d6                   ; increment the index to the exponent 1s
0000B3E2  700F                    6781      MOVEQ       #$0F,d0             ; set the mask for the exponent 1s digit
0000B3E4  C032 6000               6782      AND.b       (a2,d6.w),d0            ; get and convert the exponent 1s digit
0000B3E8                          6783  LAB_U00A
0000B3E8  3403                    6784      MOVE.w  d3,d2                   ; copy the number last digit index
0000B3EA  0C42 0001               6785      CMPI.w  #1,d2                   ; is the number of the form sxE-0x
0000B3EE  6602                    6786      BNE.s       LAB_U00B                ; if it is sx.xE-0x skip the increment
0000B3F0                          6787  
0000B3F0                          6788                                  ; else make room for the decimal point
0000B3F0  5242                    6789      ADDQ.w  #1,d2                   ; add 1 to the write index
0000B3F2                          6790  LAB_U00B
0000B3F2  D440                    6791      ADD.w       d0,d2                   ; add the exponent 1s to the write index
0000B3F4  700A                    6792      MOVEQ       #10,d0              ; set the maximum write index
0000B3F6  9042                    6793      SUB.w       d2,d0                   ; compare the index with the maximum
0000B3F8  6E0C                    6794      BGT.s       LAB_U00C                ; if the index < the maximum continue
0000B3FA                          6795  
0000B3FA  D440                    6796      ADD.w       d0,d2                   ; else set the index to the maximum
0000B3FC  D640                    6797      ADD.w       d0,d3                   ; adjust the read index
0000B3FE  0C43 0001               6798      CMPI.w  #1,d3                   ; compare the adjusted index with 1
0000B402  6E02                    6799      BGT.s       LAB_U00C                ; if > 1 continue
0000B404                          6800  
0000B404  7600                    6801      MOVEQ       #0,d3                   ; else allow for the decimal point
0000B406                          6802  LAB_U00C
0000B406  3C02                    6803      MOVE.w      d2,d6                   ; copy the write index as the number
0000B408                          6804                                  ; string length
0000B408  7000                    6805      MOVEQ       #0,d0                   ; clear d0 to null terminate the number
0000B40A                          6806                                  ; string
0000B40A                          6807  LAB_U00D
0000B40A  1580 2000               6808      MOVE.b  d0,(a2,d2.w)            ; save the character to the number string
0000B40E  5342                    6809      SUBQ.w  #1,d2                   ; decrement the number write index
0000B410  0C42 0001               6810      CMPI.w  #1,d2                   ; compare the number write index with 1
0000B414  6712                    6811      BEQ.s       LAB_U00F                ; if at the decimal point go save it
0000B416                          6812  
0000B416                          6813                                  ; else write a digit to the number string
0000B416  7030                    6814      MOVEQ       #'0',d0             ; default to "0"
0000B418  4A43                    6815      TST.w       d3                  ; test the number read index
0000B41A  67EE                    6816      BEQ.s       LAB_U00D                ; if zero just go save the "0"
0000B41C                          6817  
0000B41C                          6818  LAB_U00E
0000B41C  1032 3000               6819      MOVE.b  (a2,d3.w),d0            ; read the next number digit
0000B420  5343                    6820      SUBQ.w  #1,d3                   ; decrement the read index
0000B422  B004                    6821      CMP.b       d4,d0                   ; compare the digit with "."
0000B424  66E4                    6822      BNE.s       LAB_U00D                ; if not "." go save the digit
0000B426                          6823  
0000B426  60F4                    6824      BRA.s       LAB_U00E                ; else go get the next digit
0000B428                          6825  
0000B428                          6826  LAB_U00F
0000B428  1584 2000               6827      MOVE.b  d4,(a2,d2.w)            ; save the decimal point
0000B42C                          6828  LAB_U010
0000B42C  4A42                    6829      TST.w       d2                  ; test the number string decimal point index
0000B42E  6602                    6830      BNE.s       LAB_U014                ; if dp present skip the reset
0000B430                          6831  
0000B430  3406                    6832      MOVE.w  d6,d2                   ; make the decimal point index = the length
0000B432                          6833  
0000B432                          6834  ; copy the fractional digit characters from the number string
0000B432                          6835  
0000B432                          6836  LAB_U014
0000B432  3602                    6837      MOVE.w  d2,d3                   ; copy the number string decimal point index
0000B434  5243                    6838      ADDQ.w  #1,d3                   ; increment the number string index
0000B436  382F 0008               6839      MOVE.w  fsdpi(sp),d4            ; get the new format string decimal point index
0000B43A                          6840  LAB_U018
0000B43A  5244                    6841      ADDQ.w  #1,d4                   ; increment the new format string index
0000B43C  B244                    6842      CMP.w       d4,d1                   ; compare it with the new format string length
0000B43E  6322                    6843      BLS.s       LAB_U022                ; if done the fraction digits go do integer
0000B440                          6844  
0000B440  1030 4000               6845      MOVE.b  (a0,d4.w),d0            ; get a new format string character
0000B444  B03C 0025               6846      CMP.b       #'%',d0             ; compare it with "%"
0000B448  6706                    6847      BEQ.s       LAB_U01C                ; if "%" go copy a number character
0000B44A                          6848  
0000B44A  B03C 0023               6849      CMP.b       #'#',d0             ; compare it with "#"
0000B44E  66EA                    6850      BNE.s       LAB_U018                ; if not "#" go do the next new format character
0000B450                          6851  
0000B450                          6852  LAB_U01C
0000B450  7030                    6853      MOVEQ       #'0',d0             ; default to "0" character
0000B452  BC43                    6854      CMP.w       d3,d6                   ; compare the number string index with length
0000B454  6306                    6855      BLS.s       LAB_U020                ; if there skip the character get
0000B456                          6856  
0000B456  1032 3000               6857      MOVE.b  (a2,d3.w),d0            ; get a character from the number string
0000B45A  5243                    6858      ADDQ.w  #1,d3                   ; increment the number string index
0000B45C                          6859  LAB_U020
0000B45C  1180 4000               6860      MOVE.b  d0,(a0,d4.w)            ; save the number character to the new format
0000B460                          6861                                  ; string
0000B460  60D8                    6862      BRA.s       LAB_U018                ; go do the next new format character
0000B462                          6863  
0000B462                          6864  ; now copy the integer digit characters from the number string
0000B462                          6865  
0000B462                          6866  LAB_U022
0000B462  7C00                    6867      MOVEQ       #0,d6                   ; clear the sign done flag
0000B464  7A00                    6868      MOVEQ       #0,d5                   ; clear the sign present flag
0000B466  5342                    6869      SUBQ.w  #1,d2                   ; decrement the number string index
0000B468  6608                    6870      BNE.s       LAB_U026                ; if not now at sign continue
0000B46A                          6871  
0000B46A  7401                    6872      MOVEQ       #1,d2                   ; increment the number string index
0000B46C  15BC 0030 2000          6873      MOVE.b  #'0',(a2,d2.w)          ; replace the point with a zero
0000B472                          6874  LAB_U026
0000B472  382F 0008               6875      MOVE.w  fsdpi(sp),d4            ; get the new format string decimal point index
0000B476  B244                    6876      CMP.w       d4,d1                   ; compare it with the new format string length
0000B478  6402                    6877      BCC.s       LAB_U02A                ; if within the string go use the index
0000B47A                          6878  
0000B47A  3801                    6879      MOVE.w  d1,d4                   ; else set the index to the end of the string
0000B47C                          6880  LAB_U02A
0000B47C  5344                    6881      SUBQ.w  #1,d4                   ; decrement the new format string index
0000B47E  6B62                    6882      BMI.s       LAB_U03E                ; if all done go test for any overflow
0000B480                          6883  
0000B480  1030 4000               6884      MOVE.b  (a0,d4.w),d0            ; else get a new format string character
0000B484                          6885  
0000B484  7E30                    6886      MOVEQ       #'0',d7             ; default to "0" character
0000B486  B03C 0025               6887      CMP.b       #'%',d0             ; compare it with "%"
0000B48A  6708                    6888      BEQ.s       LAB_U02B                ; if "%" go copy a number character
0000B48C                          6889  
0000B48C  7E20                    6890      MOVEQ       #' ',d7             ; default to " " character
0000B48E  B03C 0023               6891      CMP.b       #'#',d0             ; compare it with "#"
0000B492  6606                    6892      BNE.s       LAB_U02C                ; if not "#" go try ","
0000B494                          6893  
0000B494                          6894  LAB_U02B
0000B494  4A42                    6895      TST.w       d2                  ; test the number string index
0000B496  6634                    6896      BNE.s       LAB_U036                ; if not at the sign go get a number character
0000B498                          6897  
0000B498  6042                    6898      BRA.s       LAB_U03C                ; else go save the default character
0000B49A                          6899  
0000B49A                          6900  LAB_U02C
0000B49A  B03C 002C               6901      CMP.b       #',',d0             ; compare it with ","
0000B49E  6610                    6902      BNE.s       LAB_U030                ; if not "," go try the sign characters
0000B4A0                          6903  
0000B4A0  4A42                    6904      TST.w       d2                  ; test the number string index
0000B4A2  6608                    6905      BNE.s       LAB_U02E                ; if not at the sign keep the ","
0000B4A4                          6906  
0000B4A4  0C30 0025 40FF          6907      CMP.b       #'%',-1(a0,d4.w)            ; else compare the next format string character
0000B4AA                          6908                                  ; with "%"
0000B4AA  6630                    6909      BNE.s       LAB_U03C                ; if not "%" keep the default character
0000B4AC                          6910  
0000B4AC                          6911  LAB_U02E
0000B4AC  1E00                    6912      MOVE.b  d0,d7                   ; else use the "," character
0000B4AE  602C                    6913      BRA.s       LAB_U03C                ; go save the character to the string
0000B4B0                          6914  
0000B4B0                          6915  LAB_U030
0000B4B0  B03C 002D               6916      CMP.b       #'-',d0             ; compare it with "-"
0000B4B4  6710                    6917      BEQ.s       LAB_U034                ; if "-" go do the sign character
0000B4B6                          6918  
0000B4B6  B03C 002B               6919      CMP.b       #'+',d0             ; compare it with "+"
0000B4BA  66C0                    6920      BNE.s       LAB_U02A                ; if not "+" go do the next new format character
0000B4BC                          6921  
0000B4BC  0C12 002D               6922      CMP.b       #'-',(a2)               ; compare the sign character with "-"
0000B4C0  6704                    6923      BEQ.s       LAB_U034                ; if "-" don't change the sign character
0000B4C2                          6924  
0000B4C2  14BC 002B               6925      MOVE.b  #'+',(a2)               ; else make the sign character "+"
0000B4C6                          6926  LAB_U034
0000B4C6  1A00                    6927      MOVE.b  d0,d5                   ; set the sign present flag
0000B4C8  4A42                    6928      TST.w       d2                  ; test the number string index
0000B4CA  6708                    6929      BEQ.s       LAB_U038                ; if at the sign keep the default character
0000B4CC                          6930  
0000B4CC                          6931  LAB_U036
0000B4CC  1E32 2000               6932      MOVE.b  (a2,d2.w),d7            ; else get a character from the number string
0000B4D0  5342                    6933      SUBQ.w  #1,d2                   ; decrement the number string index
0000B4D2  6008                    6934      BRA.s       LAB_U03C                ; go save the character
0000B4D4                          6935  
0000B4D4                          6936  LAB_U038
0000B4D4  4A06                    6937      TST.b       d6                  ; test the sign done flag
0000B4D6  6604                    6938      BNE.s       LAB_U03C                ; if the sign has been done go use the space
0000B4D8                          6939                                  ; character
0000B4D8                          6940  
0000B4D8  1E12                    6941      MOVE.b  (a2),d7             ; else get the sign character
0000B4DA  1C07                    6942      MOVE.b  d7,d6                   ; flag that the sign has been done
0000B4DC                          6943  LAB_U03C
0000B4DC  1187 4000               6944      MOVE.b  d7,(a0,d4.w)            ; save the number character to the new format
0000B4E0                          6945                                  ; string
0000B4E0  609A                    6946      BRA.s       LAB_U02A                ; go do the next new format character
0000B4E2                          6947  
0000B4E2                          6948  ; test for overflow conditions
0000B4E2                          6949  
0000B4E2                          6950  LAB_U03E
0000B4E2  4A42                    6951      TST.w       d2                  ; test the number string index
0000B4E4  6614                    6952      BNE.s       LAB_U040                ; if all the digits aren't done go output
0000B4E6                          6953                                  ; an overflow indication
0000B4E6                          6954  
0000B4E6                          6955  ; test for sign overflows
0000B4E6                          6956  
0000B4E6  4A05                    6957      TST.b       d5                  ; test the sign present flag
0000B4E8  6754                    6958      BEQ.s       LAB_U04A                ; if no sign present go add the string
0000B4EA                          6959  
0000B4EA                          6960  ; there was a sign in the format string
0000B4EA                          6961  
0000B4EA  4A06                    6962      TST.b       d6                  ; test the sign done flag
0000B4EC  6650                    6963      BNE.s       LAB_U04A                ; if the sign is done go add the string
0000B4EE                          6964  
0000B4EE                          6965  ; the sign isn't done so see if it was mandatory
0000B4EE                          6966  
0000B4EE  0C05 002B               6967      CMPI.b  #'+',d5             ; compare the sign with "+"
0000B4F2  6706                    6968      BEQ.s       LAB_U040                ; if it was "+" go output an overflow
0000B4F4                          6969                                  ; indication
0000B4F4                          6970  
0000B4F4                          6971  ; the sign wasn't mandatory but the number may have been negative
0000B4F4                          6972  
0000B4F4  0C12 002D               6973      CMP.b       #'-',(a2)               ; compare the sign character with "-"
0000B4F8  6644                    6974      BNE.s       LAB_U04A                ; if it wasn't "-" go add the string
0000B4FA                          6975  
0000B4FA                          6976  ; else the sign was "-" and a sign hasn't been output so ..
0000B4FA                          6977  
0000B4FA                          6978  ; the number overflowed the format string so replace all the special format characters
0000B4FA                          6979  ; with the overflow character
0000B4FA                          6980  
0000B4FA                          6981  LAB_U040
0000B4FA  7A23                    6982      MOVEQ       #ofchr,d5               ; set the overflow character
0000B4FC  3E01                    6983      MOVE.w  d1,d7                   ; copy the new format string length
0000B4FE  5347                    6984      SUBQ.w  #1,d7                   ; adjust for the loop type
0000B500  3C2F 0004               6985      MOVE.w  fsti(sp),d6             ; copy the new format string last index
0000B504  5346                    6986      SUBQ.w  #1,d6                   ; -1 gives the last character of this string
0000B506  6E02                    6987      BGT.s       LAB_U044                ; if not zero continue
0000B508                          6988  
0000B508  3C07                    6989      MOVE.w  d7,d6                   ; else set the format string index to the end
0000B50A                          6990  LAB_U044
0000B50A  1031 6000               6991      MOVE.b  (a1,d6.w),d0            ; get a character from the format string
0000B50E  0C00 0023               6992      CMPI.b  #'#',d0             ; compare it with "#" special format character
0000B512  671E                    6993      BEQ.s       LAB_U046                ; if "#" go use the overflow character
0000B514                          6994  
0000B514  0C00 0025               6995      CMPI.b  #'%',d0             ; compare it with "%" special format character
0000B518  6718                    6996      BEQ.s       LAB_U046                ; if "%" go use the overflow character
0000B51A                          6997  
0000B51A  0C00 002C               6998      CMPI.b  #',',d0             ; compare it with "," special format character
0000B51E  6712                    6999      BEQ.s       LAB_U046                ; if "," go use the overflow character
0000B520                          7000  
0000B520  0C00 002B               7001      CMPI.b  #'+',d0             ; compare it with "+" special format character
0000B524  670C                    7002      BEQ.s       LAB_U046                ; if "+" go use the overflow character
0000B526                          7003  
0000B526  0C00 002D               7004      CMPI.b  #'-',d0             ; compare it with "-" special format character
0000B52A  6706                    7005      BEQ.s       LAB_U046                ; if "-" go use the overflow character
0000B52C                          7006  
0000B52C  0C00 002E               7007      CMPI.b  #'.',d0             ; compare it with "." special format character
0000B530  6602                    7008      BNE.s       LAB_U048                ; if not "." skip the using overflow character
0000B532                          7009  
0000B532                          7010  LAB_U046
0000B532  1005                    7011      MOVE.b  d5,d0                   ; use the overflow character
0000B534                          7012  LAB_U048
0000B534  1180 7000               7013      MOVE.b  d0,(a0,d7.w)            ; save the character to the new format string
0000B538  5346                    7014      SUBQ.w  #1,d6                   ; decrement the format string index
0000B53A  51CF FFCE               7015      DBF     d7,LAB_U044             ; decrement the count and loop if not all done
0000B53E                          7016  
0000B53E                          7017  ; add the new string to the previous string
0000B53E                          7018  
0000B53E                          7019  LAB_U04A
0000B53E  41EC 0006               7020      LEA     6(a4),a0                ; get the descriptor pointer for string 1
0000B542  274C 0590               7021      MOVE.l  a4,FAC1_m(a3)           ; save the descriptor pointer for string 2
0000B546  6100 F008               7022      BSR     LAB_224E                ; concatenate the strings
0000B54A                          7023  
0000B54A                          7024  ; now check for any tail on the format string
0000B54A                          7025  
0000B54A  302F 0004               7026      MOVE.w  fsti(sp),d0             ; get this index
0000B54E  6720                    7027      BEQ.s       LAB_U04C                ; if at start of string skip the output
0000B550                          7028  
0000B550  3F40 0006               7029      MOVE.w  d0,fsli(sp)             ; save this index to the last index
0000B554  6100 0084               7030      BSR     LAB_ProcFo              ; now process the format string
0000B558  4A02                    7031      TST.b       d2                  ; test the special characters flag
0000B55A  6614                    7032      BNE.s       LAB_U04C                ; if special characters present skip the output
0000B55C                          7033  
0000B55C                          7034  ; else output the new string part
0000B55C                          7035  
0000B55C  613E                    7036      BSR.s       LAB_DupFmt              ; duplicate the processed format string section
0000B55E  3F6F 0004 0006          7037      MOVE.w  fsti(sp),fsli(sp)           ; copy this index to the last index
0000B564                          7038  
0000B564                          7039  ; add the new string to the previous string
0000B564                          7040  
0000B564  41EC 0006               7041      LEA     6(a4),a0                ; get the descriptor pointer for string 1
0000B568  274C 0590               7042      MOVE.l  a4,FAC1_m(a3)           ; save the descriptor pointer for string 2
0000B56C  6100 EFE2               7043      BSR     LAB_224E                ; concatenate the strings
0000B570                          7044  
0000B570                          7045  ; check for another value or end of function
0000B570                          7046  
0000B570                          7047  LAB_U04C
0000B570  101D                    7048      MOVE.b  (a5)+,d0                ; get the next BASIC byte
0000B572  B03C 0029               7049      CMP.b       #')',d0             ; compare with close bracket
0000B576  6600 FDCA               7050      BNE     LAB_U002                ; if not ")" go do next value
0000B57A                          7051  
0000B57A                          7052  ; pop the result string off the descriptor stack
0000B57A                          7053  
0000B57A  204C                    7054      MOVEA.l a4,a0                   ; copy the result string descriptor pointer
0000B57C  222B 0446               7055      MOVE.l  Sstorl(a3),d1           ; save the bottom of string space
0000B580  6100 F030               7056      BSR     LAB_22BA                ; pop (a0) descriptor, returns with ..
0000B584                          7057                                  ; d0 = length, a0 = pointer
0000B584  2741 0446               7058      MOVE.l  d1,Sstorl(a3)           ; restore the bottom of string space
0000B588  2248                    7059      MOVEA.l a0,a1                   ; copy the string result pointer
0000B58A  3200                    7060      MOVE.w  d0,d1                   ; copy the string result length
0000B58C                          7061  
0000B58C                          7062  ; pop the format string off the descriptor stack
0000B58C                          7063  
0000B58C  205F                    7064      MOVEA.l (sp)+,a0                ; pull the format string descriptor pointer
0000B58E  6100 F022               7065      BSR     LAB_22BA                ; pop (a0) descriptor, returns with ..
0000B592                          7066                                  ; d0 = length, a0 = pointer
0000B592                          7067  
0000B592  4FEF 0008               7068      LEA     fend(sp),sp             ; dump the saved values
0000B596                          7069  
0000B596                          7070  ; push the result string back on the descriptor stack and return
0000B596                          7071  
0000B596  2049                    7072      MOVEA.l a1,a0                   ; copy the result string pointer back
0000B598  6000 EE66               7073      BRA     LAB_RTST                ; push a string on the descriptor stack and
0000B59C                          7074                                  ; return. a0 = pointer, d1 = length
0000B59C                          7075  
0000B59C                          7076  
0000B59C                          7077  ;************************************************************************************
0000B59C                          7078  ;
0000B59C                          7079  ; duplicate the processed format string section
0000B59C                          7080  
0000B59C                          7081                                  ; make a string as long as the format string
0000B59C                          7082  LAB_DupFmt
0000B59C  226F 0004               7083      MOVEA.l 4+fsd(sp),a1            ; get the format string descriptor pointer
0000B5A0  3E29 0004               7084      MOVE.w  4(a1),d7                ; get the format string length
0000B5A4  342F 000A               7085      MOVE.w  4+fsli(sp),d2           ; get the format string last index
0000B5A8  3C2F 0008               7086      MOVE.w  4+fsti(sp),d6           ; get the format string this index
0000B5AC  3206                    7087      MOVE.w  d6,d1                   ; copy the format string this index
0000B5AE  9242                    7088      SUB.w       d2,d1                   ; subtract the format string last index
0000B5B0  6202                    7089      BHI.s       LAB_D002                ; if > 0 skip the correction
0000B5B2                          7090  
0000B5B2  D247                    7091      ADD.w       d7,d1                   ; else add the format string length as the
0000B5B4                          7092                                  ; correction
0000B5B4                          7093  LAB_D002
0000B5B4  6100 EE64               7094      BSR     LAB_2115                ; make string space d1 bytes long
0000B5B8                          7095                                  ; return a0/Sutill = pointer, others unchanged
0000B5B8                          7096  
0000B5B8                          7097  ; push the new string on the descriptor stack
0000B5B8                          7098  
0000B5B8  6100 EE46               7099      BSR     LAB_RTST                ; push a string on the descriptor stack and
0000B5BC                          7100                                  ; return. a0 = pointer, d1 = length
0000B5BC                          7101  
0000B5BC                          7102  ; copy the characters from the format string
0000B5BC                          7103  
0000B5BC  226F 0004               7104      MOVEA.l 4+fsd(sp),a1            ; get the format string descriptor pointer
0000B5C0  2251                    7105      MOVEA.l (a1),a1             ; get the format string pointer
0000B5C2  7800                    7106      MOVEQ       #0,d4                   ; clear the new string index
0000B5C4                          7107  LAB_D00A
0000B5C4  11B1 2000 4000          7108      MOVE.b  (a1,d2.w),(a0,d4.w)     ; get a character from the format string and
0000B5CA                          7109                                  ; save it to the new string
0000B5CA  5244                    7110      ADDQ.w  #1,d4                   ; increment the new string index
0000B5CC  5242                    7111      ADDQ.w  #1,d2                   ; increment the format string index
0000B5CE  BE42                    7112      CMP.w       d2,d7                   ; compare the format index with the length
0000B5D0  6602                    7113      BNE.s       LAB_D00E                ; if not there skip the reset
0000B5D2                          7114  
0000B5D2  7400                    7115      MOVEQ       #0,d2                   ; else reset the format string index
0000B5D4                          7116  LAB_D00E
0000B5D4  BC42                    7117      CMP.w       d2,d6                   ; compare the index with this index
0000B5D6  66EC                    7118      BNE.s       LAB_D00A                ; if not equal go do the next character
0000B5D8                          7119  
0000B5D8  4E75                    7120      RTS
0000B5DA                          7121  
0000B5DA                          7122  
0000B5DA                          7123  ;************************************************************************************
0000B5DA                          7124  ;
0000B5DA                          7125  ; process the format string
0000B5DA                          7126  
0000B5DA                          7127  LAB_ProcFo
0000B5DA  226F 0004               7128      MOVEA.l 4+fsd(sp),a1            ; get the format string descriptor pointer
0000B5DE  3E29 0004               7129      MOVE.w  4(a1),d7                ; get the format string length
0000B5E2  2251                    7130      MOVEA.l (a1),a1             ; get the format string pointer
0000B5E4  3C2F 000A               7131      MOVE.w  4+fsli(sp),d6           ; get the format string last index
0000B5E8                          7132  
0000B5E8  3F47 000C               7133      MOVE.w  d7,4+fsdpi(sp)          ; set the format string decimal point index
0000B5EC                          7134  ;## MOVE.w  #-1,4+fsdpi(sp)         ; set the format string decimal point index
0000B5EC  7A00                    7135      MOVEQ       #0,d5                   ; no decimal point
0000B5EE  7600                    7136      MOVEQ       #0,d3                   ; no decimal characters
0000B5F0  7400                    7137      MOVEQ       #0,d2                   ; no special characters
0000B5F2                          7138  LAB_P004
0000B5F2  1031 6000               7139      MOVE.b  (a1,d6.w),d0            ; get a format string byte
0000B5F6                          7140  
0000B5F6  B03C 002C               7141      CMP.b       #',',d0             ; compare it with ","
0000B5FA  6742                    7142      BEQ.s       LAB_P01A                ; if "," go do the next format string byte
0000B5FC                          7143  
0000B5FC  B03C 0023               7144      CMP.b       #'#',d0             ; compare it with "#"
0000B600  6706                    7145      BEQ.s       LAB_P008                ; if "#" go flag special characters
0000B602                          7146  
0000B602  B03C 0025               7147      CMP.b       #'%',d0             ; compare it with "%"
0000B606  6608                    7148      BNE.s       LAB_P00C                ; if not "%" go try "+"
0000B608                          7149  
0000B608                          7150  LAB_P008
0000B608  4A85                    7151      TST.l       d5                  ; test the decimal point flag
0000B60A  6A10                    7152      BPL.s       LAB_P00E                ; if no point skip counting decimal characters
0000B60C                          7153  
0000B60C  5243                    7154      ADDQ.w  #1,d3                   ; else increment the decimal character count
0000B60E  602E                    7155      BRA.s       LAB_P01A                ; go do the next character
0000B610                          7156  
0000B610                          7157  LAB_P00C
0000B610  B03C 002B               7158      CMP.b       #'+',d0             ; compare it with "+"
0000B614  6706                    7159      BEQ.s       LAB_P00E                ; if "+" go flag special characters
0000B616                          7160  
0000B616  B03C 002D               7161      CMP.b       #'-',d0             ; compare it with "-"
0000B61A  6604                    7162      BNE.s       LAB_P010                ; if not "-" go check decimal point
0000B61C                          7163  
0000B61C                          7164  LAB_P00E
0000B61C  8400                    7165      OR.b        d0,d2                   ; flag special characters
0000B61E  601E                    7166      BRA.s       LAB_P01A                ; go do the next character
0000B620                          7167  
0000B620                          7168  LAB_P010
0000B620  B03C 002E               7169      CMP.b       #'.',d0             ; compare it with "."
0000B624  6614                    7170      BNE.s       LAB_P018                ; if not "." go check next
0000B626                          7171  
0000B626                          7172  ; "." a decimal point
0000B626                          7173  
0000B626  4A85                    7174      TST.l       d5                  ; if there is already a decimal point
0000B628  6B14                    7175      BMI.s       LAB_P01A                ; go do the next character
0000B62A                          7176  
0000B62A  3006                    7177      MOVE.w  d6,d0                   ; copy the decimal point index
0000B62C  906F 000A               7178      SUB.w       4+fsli(sp),d0           ; calculate it from the scan start
0000B630  3F40 000C               7179      MOVE.w  d0,4+fsdpi(sp)          ; save the decimal point index
0000B634  7AFF                    7180      MOVEQ       #-1,d5              ; flag decimal point
0000B636  8400                    7181      OR.b        d0,d2                   ; flag special characters
0000B638  6004                    7182      BRA.s       LAB_P01A                ; go do the next character
0000B63A                          7183  
0000B63A                          7184  ; was not a special character
0000B63A                          7185  
0000B63A                          7186  LAB_P018
0000B63A  4A02                    7187      TST.b       d2                  ; test if there have been special characters
0000B63C  6608                    7188      BNE.s       LAB_P01E                ; if so exit the format string process
0000B63E                          7189  
0000B63E                          7190  LAB_P01A
0000B63E  5246                    7191      ADDQ.w  #1,d6                   ; increment the format string index
0000B640  BE46                    7192      CMP.w       d6,d7                   ; compare it with the format string length
0000B642  62AE                    7193      BHI.s       LAB_P004                ; if length > index go get the next character
0000B644                          7194  
0000B644  7C00                    7195      MOVEQ       #0,d6                   ; length = index so reset the format string
0000B646                          7196                                  ; index
0000B646                          7197  LAB_P01E
0000B646  3F46 0008               7198      MOVE.w  d6,4+fsti(sp)           ; save the format string this index
0000B64A  3F43 000E               7199      MOVE.w  d3,4+fsdc(sp)           ; save the format string decimal characters
0000B64E                          7200  
0000B64E  4E75                    7201      RTS
0000B650                          7202  
0000B650                          7203  
0000B650                          7204  ;************************************************************************************
0000B650                          7205  ;
0000B650                          7206  ; perform BIN$()
0000B650                          7207  ; # of leading 0s is in d1, the number is in d0
0000B650                          7208  
0000B650                          7209  LAB_BINS
0000B650  B23C 0021               7210      CMP.b       #$21,d1             ; max + 1
0000B654  6400 DAF8               7211      BCC     LAB_FCER                ; exit if too big ( > or = )
0000B658                          7212  
0000B658  741F                    7213      MOVEQ       #$1F,d2             ; bit count-1
0000B65A  41EB 05B6               7214      LEA     Binss(a3),a0            ; point to string
0000B65E  7830                    7215      MOVEQ       #$30,d4             ; "0" character for ADDX
0000B660                          7216  NextB1
0000B660  7600                    7217      MOVEQ       #0,d3                   ; clear byte
0000B662  E288                    7218      LSR.l       #1,d0                   ; shift bit into Xb
0000B664  D704                    7219      ADDX.b  d4,d3                   ; add carry and character to zero
0000B666  1183 2000               7220      MOVE.b  d3,(a0,d2.w)            ; save character to string
0000B66A  51CA FFF4               7221      DBF     d2,NextB1               ; decrement and loop if not done
0000B66E                          7222  
0000B66E                          7223  ; this is the exit code and is also used by HEX$()
0000B66E                          7224  
0000B66E                          7225  EndBHS
0000B66E  177C 0000 05D6          7226      MOVE.b  #0,BHsend(a3)           ; null terminate the string
0000B674  4A01                    7227      TST.b       d1                  ; test # of characters
0000B676  670E                    7228      BEQ.s       NextB2              ; go truncate string
0000B678                          7229  
0000B678  4481                    7230      NEG.l       d1                  ; make -ve
0000B67A  0681 000005D6           7231      ADD.l       #BHsend,d1              ; effectively (end-length)
0000B680  41F3 1000               7232      LEA     0(a3,d1.w),a0           ; effectively add (end-length) to pointer
0000B684  600E                    7233      BRA.s       BinPr                   ; go print string
0000B686                          7234  
0000B686                          7235  ; truncate string to remove leading "0"s
0000B686                          7236  
0000B686                          7237  NextB2
0000B686  1010                    7238      MOVE.b  (a0),d0             ; get byte
0000B688  670A                    7239      BEQ.s       BinPr                   ; if null then end of string so add 1 and go
0000B68A                          7240                                  ; print it
0000B68A                          7241  
0000B68A  B03C 0030               7242      CMP.b       #'0',d0             ; compare with "0"
0000B68E  660E                    7243      BNE.s       GoPr                    ; if not "0" then go print string from here
0000B690                          7244  
0000B690  5248                    7245      ADDQ.w  #1,a0                   ; else increment pointer
0000B692  60F2                    7246      BRA.s       NextB2              ; loop always
0000B694                          7247  
0000B694                          7248  ; make fixed length output string - ignore overflows!
0000B694                          7249  
0000B694                          7250  BinPr
0000B694  43EB 05D6               7251      LEA     BHsend(a3),a1           ; get string end
0000B698  B1C9                    7252      CMPA.l  a1,a0                   ; are we at the string end
0000B69A  6602                    7253      BNE.s       GoPr                    ; branch if not
0000B69C                          7254  
0000B69C  5348                    7255      SUBQ.w  #1,a0                   ; else need at least one zero
0000B69E                          7256  GoPr
0000B69E  6000 ED1A               7257      BRA     LAB_20AE                ; print " terminated string to FAC1, stack & RET
0000B6A2                          7258  
0000B6A2                          7259  
0000B6A2                          7260  ;************************************************************************************
0000B6A2                          7261  ;
0000B6A2                          7262  ; perform HEX$()
0000B6A2                          7263  ; # of leading 0s is in d1, the number is in d0
0000B6A2                          7264  
0000B6A2                          7265  LAB_HEXS
0000B6A2  B23C 0009               7266      CMP.b       #$09,d1             ; max + 1
0000B6A6  6400 DAA6               7267      BCC     LAB_FCER                ; exit if too big ( > or = )
0000B6AA                          7268  
0000B6AA  7407                    7269      MOVEQ       #$07,d2             ; nibble count-1
0000B6AC  41EB 05CE               7270      LEA     Hexss(a3),a0            ; point to string
0000B6B0  7830                    7271      MOVEQ       #$30,d4             ; "0" character for ABCD
0000B6B2                          7272  NextH1
0000B6B2  1600                    7273      MOVE.b  d0,d3                   ; copy lowest byte
0000B6B4  E898                    7274      ROR.l       #4,d0                   ; shift nibble into 0-3
0000B6B6  C63C 000F               7275      AND.b       #$0F,d3             ; just this nibble
0000B6BA  1A03                    7276      MOVE.b  d3,d5                   ; copy it
0000B6BC  0605 00F6               7277      ADD.b       #$F6,d5             ; set extend bit
0000B6C0  C704                    7278      ABCD        d4,d3                   ; decimal add extend and character to zero
0000B6C2  1183 2000               7279      MOVE.b  d3,(a0,d2.w)            ; save character to string
0000B6C6  51CA FFEA               7280      DBF     d2,NextH1               ; decrement and loop if not done
0000B6CA                          7281  
0000B6CA  60A2                    7282      BRA.s       EndBHS              ; go process string
0000B6CC                          7283  
0000B6CC                          7284  
0000B6CC                          7285  ;************************************************************************************
0000B6CC                          7286  ;
0000B6CC                          7287  ; ctrl-c check routine. includes limited "life" byte save for INGET routine
0000B6CC                          7288  
0000B6CC                          7289  VEC_CC
0000B6CC  4A2B 05E8               7290      TST.b       ccflag(a3)              ; check [CTRL-C] check flag
0000B6D0  661E                    7291      BNE.s       RTS_022             ; exit if [CTRL-C] check inhibited
0000B6D2                          7292  
0000B6D2  4EAB 040C               7293      JSR     V_INPT(a3)              ; scan input device
0000B6D6  640E                    7294      BCC.s       LAB_FBA0                ; exit if buffer empty
0000B6D8                          7295  
0000B6D8  1740 05E9               7296      MOVE.b  d0,ccbyte(a3)           ; save received byte
0000B6DC  177C 0020 05EA          7297      MOVE.b  #$20,ccnull(a3)         ; set "life" timer for bytes countdown
0000B6E2  6000 DEE0               7298      BRA     LAB_1636                ; return to BASIC
0000B6E6                          7299  
0000B6E6                          7300  LAB_FBA0
0000B6E6  4A2B 05EA               7301      TST.b       ccnull(a3)              ; get countdown byte
0000B6EA  6704                    7302      BEQ.s       RTS_022             ; exit if finished
0000B6EC                          7303  
0000B6EC  532B 05EA               7304      SUBQ.b  #1,ccnull(a3)           ; else decrement countdown
0000B6F0                          7305  RTS_022
0000B6F0  4E75                    7306      RTS
0000B6F2                          7307  
0000B6F2                          7308  
0000B6F2                          7309  ;************************************************************************************
0000B6F2                          7310  ;
0000B6F2                          7311  ; get byte from input device, no waiting
0000B6F2                          7312  ; returns with carry set if byte in A
0000B6F2                          7313  
0000B6F2                          7314  INGET
0000B6F2  4EAB 040C               7315      JSR     V_INPT(a3)              ; call scan input device
0000B6F6  650A                    7316      BCS.s       LAB_FB95                ; if byte go reset timer
0000B6F8                          7317  
0000B6F8  102B 05EA               7318      MOVE.b  ccnull(a3),d0           ; get countdown
0000B6FC  67F2                    7319      BEQ.s       RTS_022             ; exit if empty
0000B6FE                          7320  
0000B6FE  102B 05E9               7321      MOVE.b  ccbyte(a3),d0           ; get last received byte
0000B702                          7322  LAB_FB95
0000B702  177C 0000 05EA          7323      MOVE.b  #$00,ccnull(a3)         ; clear timer because we got a byte
0000B708  003C 0001               7324      ORI.b       #1,CCR              ; set carry, flag we got a byte
0000B70C  4E75                    7325      RTS
0000B70E                          7326  
0000B70E                          7327  
0000B70E                          7328  ;************************************************************************************
0000B70E                          7329  ;
0000B70E                          7330  ; perform MAX()
0000B70E                          7331  
0000B70E                          7332  LAB_MAX
0000B70E  6100 E534               7333      BSR     LAB_EVEZ                ; evaluate expression (no decrement)
0000B712  4A2B 05B5               7334      TST.b       Dtypef(a3)              ; test data type
0000B716  6B00 DA16               7335      BMI     LAB_TMER                ; if string do Type missmatch Error/warm start
0000B71A                          7336  
0000B71A                          7337  LAB_MAXN
0000B71A  612E                    7338      BSR.s       LAB_PHFA                ; push FAC1, evaluate expression,
0000B71C                          7339                                  ; pull FAC2 & compare with FAC1
0000B71C  64FC                    7340      BCC.s       LAB_MAXN                ; branch if no swap to do
0000B71E                          7341  
0000B71E  6100 F4A4               7342      BSR     LAB_279B                ; copy FAC2 to FAC1
0000B722  60F6                    7343      BRA.s       LAB_MAXN                ; go do next
0000B724                          7344  
0000B724                          7345  
0000B724                          7346  ;************************************************************************************
0000B724                          7347  ;
0000B724                          7348  ; perform MIN()
0000B724                          7349  
0000B724                          7350  LAB_MIN
0000B724  6100 E51E               7351      BSR     LAB_EVEZ                ; evaluate expression (no decrement)
0000B728  4A2B 05B5               7352      TST.b       Dtypef(a3)              ; test data type
0000B72C  6B00 DA00               7353      BMI     LAB_TMER                ; if string do Type missmatch Error/warm start
0000B730                          7354  
0000B730                          7355  LAB_MINN
0000B730  6118                    7356      BSR.s       LAB_PHFA                ; push FAC1, evaluate expression,
0000B732                          7357                                  ; pull FAC2 & compare with FAC1
0000B732  63FC                    7358      BLS.s       LAB_MINN                ; branch if no swap to do
0000B734                          7359  
0000B734  6100 F48E               7360      BSR     LAB_279B                ; copy FAC2 to FAC1
0000B738  60F6                    7361      BRA.s       LAB_MINN                ; go do next (branch always)
0000B73A                          7362  
0000B73A                          7363  ; exit routine. don't bother returning to the loop code
0000B73A                          7364  ; check for correct exit, else so syntax error
0000B73A                          7365  
0000B73A                          7366  LAB_MMEC
0000B73A  B03C 0029               7367      CMP.b       #')',d0             ; is it end of function?
0000B73E  6600 DA1A               7368      BNE     LAB_SNER                ; if not do MAX MIN syntax error
0000B742                          7369  
0000B742  4FEF 0004               7370      LEA     4(sp),sp                ; dump return address (faster)
0000B746  6000 E65A               7371      BRA     LAB_IGBY                ; update BASIC execute pointer (to chr past ")")
0000B74A                          7372                                  ; and return
0000B74A                          7373  
0000B74A                          7374  ; check for next, evaluate & return or exit
0000B74A                          7375  ; this is the routine that does most of the work
0000B74A                          7376  
0000B74A                          7377  LAB_PHFA
0000B74A  6100 E658               7378      BSR     LAB_GBYT                ; get next BASIC byte
0000B74E  B03C 002C               7379      CMP.b       #',',d0             ; is there more ?
0000B752  66E6                    7380      BNE.s       LAB_MMEC                ; if not go do end check
0000B754                          7381  
0000B754  3F2B 0594               7382      MOVE.w  FAC1_e(a3),-(sp)            ; push exponent and sign
0000B758  2F2B 0590               7383      MOVE.l  FAC1_m(a3),-(sp)            ; push mantissa
0000B75C                          7384  
0000B75C  6100 E4E6               7385      BSR     LAB_EVEZ                ; evaluate expression (no decrement)
0000B760  4A2B 05B5               7386      TST.b       Dtypef(a3)              ; test data type
0000B764  6B00 D9C8               7387      BMI     LAB_TMER                ; if string do Type missmatch Error/warm start
0000B768                          7388  
0000B768                          7389  
0000B768                          7390                                  ; pop FAC2 (MAX/MIN expression so far)
0000B768  275F 0598               7391      MOVE.l  (sp)+,FAC2_m(a3)            ; pop mantissa
0000B76C                          7392  
0000B76C  301F                    7393      MOVE.w  (sp)+,d0                ; pop exponent and sign
0000B76E  3740 059C               7394      MOVE.w  d0,FAC2_e(a3)           ; save exponent and sign
0000B772  176B 0595 059E          7395      MOVE.b  FAC1_s(a3),FAC_sc(a3)       ; get FAC1 sign
0000B778  B12B 059E               7396      EOR.b       d0,FAC_sc(a3)           ; EOR to create sign compare
0000B77C  6000 F4B2               7397      BRA     LAB_27FA                ; compare FAC1 with FAC2 & return
0000B780                          7398                                  ; returns d0=+1 Cb=0 if FAC1 > FAC2
0000B780                          7399                                  ; returns d0= 0 Cb=0 if FAC1 = FAC2
0000B780                          7400                                  ; returns d0=-1 Cb=1 if FAC1 < FAC2
0000B780                          7401  
0000B780                          7402  
0000B780                          7403  ;************************************************************************************
0000B780                          7404  ;
0000B780                          7405  ; perform WIDTH
0000B780                          7406  
0000B780                          7407  LAB_WDTH
0000B780  B03C 002C               7408      CMP.b       #',',d0             ; is next byte ","
0000B784  672C                    7409      BEQ.s       LAB_TBSZ                ; if so do tab size
0000B786                          7410  
0000B786  6100 EF86               7411      BSR     LAB_GTBY                ; get byte parameter, result in d0 and Itemp
0000B78A  4A00                    7412      TST.b       d0                  ; test result
0000B78C  6712                    7413      BEQ.s       LAB_NSTT                ; branch if set for infinite line
0000B78E                          7414  
0000B78E  B03C 0010               7415      CMP.b       #$10,d0             ; else make min width = 16d
0000B792  6500 D9BA               7416      BCS     LAB_FCER                ; if less do function call error & exit
0000B796                          7417  
0000B796                          7418  ; this next compare ensures that we can't exit WIDTH via an error leaving the
0000B796                          7419  ; tab size greater than the line length.
0000B796                          7420  
0000B796  B02B 05E2               7421      CMP.b       TabSiz(a3),d0           ; compare with tab size
0000B79A  6404                    7422      BCC.s       LAB_NSTT                ; branch if >= tab size
0000B79C                          7423  
0000B79C  1740 05E2               7424      MOVE.b  d0,TabSiz(a3)           ; else make tab size = terminal width
0000B7A0                          7425  LAB_NSTT
0000B7A0  1740 05E6               7426      MOVE.b  d0,TWidth(a3)           ; set the terminal width
0000B7A4  6100 E5FE               7427      BSR     LAB_GBYT                ; get BASIC byte back
0000B7A8  672C                    7428      BEQ.s       WExit                   ; exit if no following
0000B7AA                          7429  
0000B7AA  B03C 002C               7430      CMP.b       #',',d0             ; else is it ","
0000B7AE  6600 D9AA               7431      BNE     LAB_SNER                ; if not do syntax error
0000B7B2                          7432  
0000B7B2                          7433  LAB_TBSZ
0000B7B2  6100 EF56               7434      BSR     LAB_SGBY                ; increment and get byte, result in d0 and Itemp
0000B7B6  4A00                    7435      TST.b       d0                  ; test TAB size
0000B7B8  6B00 D994               7436      BMI     LAB_FCER                ; if >127 do function call error & exit
0000B7BC                          7437  
0000B7BC  B03C 0001               7438      CMP.b       #1,d0                   ; compare with min-1
0000B7C0  6500 D98C               7439      BCS     LAB_FCER                ; if <=1 do function call error & exit
0000B7C4                          7440  
0000B7C4  122B 05E6               7441      MOVE.b  TWidth(a3),d1           ; set flags for width
0000B7C8  6708                    7442      BEQ.s       LAB_SVTB                ; skip check if infinite line
0000B7CA                          7443  
0000B7CA  B02B 05E6               7444      CMP.b       TWidth(a3),d0           ; compare TAB with width
0000B7CE  6E00 D97E               7445      BGT     LAB_FCER                ; branch if too big
0000B7D2                          7446  
0000B7D2                          7447  LAB_SVTB
0000B7D2  1740 05E2               7448      MOVE.b  d0,TabSiz(a3)           ; save TAB size
0000B7D6                          7449  
0000B7D6                          7450  ; calculate tab column limit from TAB size. The Iclim is set to the last tab
0000B7D6                          7451  ; position on a line that still has at least one whole tab width between it
0000B7D6                          7452  ; and the end of the line.
0000B7D6                          7453  
0000B7D6                          7454  WExit
0000B7D6  102B 05E6               7455      MOVE.b  TWidth(a3),d0           ; get width
0000B7DA  670A                    7456      BEQ.s       LAB_WDLP                ; branch if infinite line
0000B7DC                          7457  
0000B7DC  B02B 05E2               7458      CMP.b       TabSiz(a3),d0           ; compare with tab size
0000B7E0  6404                    7459      BCC.s       LAB_WDLP                ; branch if >= tab size
0000B7E2                          7460  
0000B7E2  1740 05E2               7461      MOVE.b  d0,TabSiz(a3)           ; else make tab size = terminal width
0000B7E6                          7462  LAB_WDLP
0000B7E6  902B 05E2               7463      SUB.b       TabSiz(a3),d0           ; subtract tab size
0000B7EA  64FA                    7464      BCC.s       LAB_WDLP                ; loop while no borrow
0000B7EC                          7465  
0000B7EC  D02B 05E2               7466      ADD.b       TabSiz(a3),d0           ; add tab size back
0000B7F0  D02B 05E2               7467      ADD.b       TabSiz(a3),d0           ; add tab size back again
0000B7F4                          7468  
0000B7F4  4400                    7469      NEG.b       d0                  ; make -ve
0000B7F6  D02B 05E6               7470      ADD.b       TWidth(a3),d0           ; subtract remainder from width
0000B7FA  1740 05E7               7471      MOVE.b  d0,Iclim(a3)            ; save tab column limit
0000B7FE                          7472  RTS_023
0000B7FE  4E75                    7473      RTS
0000B800                          7474  
0000B800                          7475  
0000B800                          7476  ;************************************************************************************
0000B800                          7477  ;
0000B800                          7478  ; perform SQR()
0000B800                          7479  
0000B800                          7480  ; d0 is number to find the root of
0000B800                          7481  ; d1 is the root result
0000B800                          7482  ; d2 is the remainder
0000B800                          7483  ; d3 is a counter
0000B800                          7484  ; d4 is temp
0000B800                          7485  
0000B800                          7486  LAB_SQR
0000B800  4A2B 0595               7487      TST.b       FAC1_s(a3)              ; test FAC1 sign
0000B804  6B00 D948               7488      BMI     LAB_FCER                ; if -ve do function call error
0000B808                          7489  
0000B808  4A2B 0594               7490      TST.b       FAC1_e(a3)              ; test exponent
0000B80C  67F0                    7491      BEQ.s       RTS_023             ; exit if zero
0000B80E                          7492  
0000B80E  48E7 7800               7493      MOVEM.l d1-d4,-(sp)             ; save registers
0000B812  202B 0590               7494      MOVE.l  FAC1_m(a3),d0           ; copy FAC1
0000B816  7400                    7495      MOVEQ       #0,d2                   ; clear remainder
0000B818  2202                    7496      MOVE.l  d2,d1                   ; clear root
0000B81A                          7497  
0000B81A  761F                    7498      MOVEQ       #$1F,d3             ; $1F for DBF, 64 pairs of bits to
0000B81C                          7499                                  ; do for a 32 bit result
0000B81C  082B 0000 0594          7500      BTST        #0,FAC1_e(a3)           ; test exponent odd/even
0000B822  6606                    7501      BNE.s       LAB_SQE2                ; if odd only 1 shift first time
0000B824                          7502  
0000B824                          7503  LAB_SQE1
0000B824  D080                    7504      ADD.l       d0,d0                   ; shift highest bit of number ..
0000B826  D582                    7505      ADDX.l  d2,d2                   ; .. into remainder .. never overflows
0000B828  D281                    7506      ADD.l       d1,d1                   ; root = root   ; 2 .. never overflows
0000B82A                          7507  LAB_SQE2
0000B82A  D080                    7508      ADD.l       d0,d0                   ; shift highest bit of number ..
0000B82C  D582                    7509      ADDX.l  d2,d2                   ; .. into remainder .. never overflows
0000B82E                          7510  
0000B82E  2801                    7511      MOVE.l  d1,d4                   ; copy root
0000B830  D884                    7512      ADD.l       d4,d4                   ; 2n
0000B832  5284                    7513      ADDQ.l  #1,d4                   ; 2n+1
0000B834                          7514  
0000B834  B484                    7515      CMP.l       d4,d2                   ; compare 2n+1 to remainder
0000B836  6504                    7516      BCS.s       LAB_SQNS                ; skip sub if remainder smaller
0000B838                          7517  
0000B838  9484                    7518      SUB.l       d4,d2                   ; subtract temp from remainder
0000B83A  5281                    7519      ADDQ.l  #1,d1                   ; increment root
0000B83C                          7520  LAB_SQNS
0000B83C  51CB FFE6               7521      DBF     d3,LAB_SQE1             ; loop if not all done
0000B840                          7522  
0000B840  2741 0590               7523      MOVE.l  d1,FAC1_m(a3)           ; save result mantissa
0000B844  102B 0594               7524      MOVE.b  FAC1_e(a3),d0           ; get exponent (d0 is clear here)
0000B848  0440 0080               7525      SUB.w       #$80,d0             ; normalise
0000B84C  E248                    7526      LSR.w       #1,d0                   ; /2
0000B84E  6402                    7527      BCC.s       LAB_SQNA                ; skip increment if carry clear
0000B850                          7528  
0000B850  5240                    7529      ADDQ.w  #1,d0                   ; add bit zero back in (allow for half shift)
0000B852                          7530  LAB_SQNA
0000B852  0640 0080               7531      ADD.w       #$80,d0             ; re-bias to $80
0000B856  1740 0594               7532      MOVE.b  d0,FAC1_e(a3)           ; save it
0000B85A  4CDF 001E               7533      MOVEM.l (sp)+,d1-d4             ; restore registers
0000B85E  6000 F0A2               7534      BRA     LAB_24D5                ; normalise FAC1 & return
0000B862                          7535  
0000B862                          7536  
0000B862                          7537  ;************************************************************************************
0000B862                          7538  ;
0000B862                          7539  ; perform VARPTR()
0000B862                          7540  
0000B862                          7541  LAB_VARPTR
0000B862  101D                    7542      MOVE.b  (a5)+,d0                ; increment pointer
0000B864                          7543  LAB_VARCALL
0000B864  6100 E74E               7544      BSR     LAB_GVAR                ; get variable address in a0
0000B868  6100 E526               7545      BSR     LAB_1BFB                ; scan for ")", else do syntax error/warm start
0000B86C  2008                    7546      MOVE.l  a0,d0                   ; copy the variable address
0000B86E  6000 EA34               7547      BRA     LAB_AYFC                ; convert d0 to signed longword in FAC1 & return
0000B872                          7548  
0000B872                          7549  
0000B872                          7550  ;************************************************************************************
0000B872                          7551  ;
0000B872                          7552  ; perform RAMBASE
0000B872                          7553  
0000B872                          7554  LAB_RAM
0000B872  41F8 0400               7555      LEA     ehram_base,a0           ; get start of EhBASIC RAM
0000B876  2008                    7556      MOVE.l  a0,d0                   ; copy it
0000B878  6000 EA2A               7557      BRA     LAB_AYFC                ; convert d0 to signed longword in FAC1 & return
0000B87C                          7558  
0000B87C                          7559  
0000B87C                          7560  ;************************************************************************************
0000B87C                          7561  ;
0000B87C                          7562  ; perform PI
0000B87C                          7563  
0000B87C                          7564  LAB_PI
0000B87C  277C C90FDAA2 0590      7565      MOVE.l  #$C90FDAA2,FAC1_m(a3)       ; pi mantissa (32 bit)
0000B884  377C 8200 0594          7566      MOVE.w  #$8200,FAC1_e(a3)           ; pi exponent and sign
0000B88A  4E75                    7567      RTS
0000B88C                          7568  
0000B88C                          7569  
0000B88C                          7570  ;************************************************************************************
0000B88C                          7571  ;
0000B88C                          7572  ; perform TWOPI
0000B88C                          7573  
0000B88C                          7574  LAB_TWOPI
0000B88C  277C C90FDAA2 0590      7575      MOVE.l  #$C90FDAA2,FAC1_m(a3)       ; 2pi mantissa (32 bit)
0000B894  377C 8300 0594          7576      MOVE.w  #$8300,FAC1_e(a3)           ; 2pi exponent and sign
0000B89A  4E75                    7577      RTS
0000B89C                          7578  
0000B89C                          7579  
0000B89C                          7580  ;************************************************************************************
0000B89C                          7581  ;
0000B89C                          7582  ; get ASCII string equivalent into FAC1 as integer32 or float
0000B89C                          7583  
0000B89C                          7584  ; entry is with a5 pointing to the first character of the string
0000B89C                          7585  ; exit with a5 pointing to the first character after the string
0000B89C                          7586  
0000B89C                          7587  ; d0 is character
0000B89C                          7588  ; d1 is mantissa
0000B89C                          7589  ; d2 is partial and table mantissa
0000B89C                          7590  ; d3 is mantissa exponent (decimal & binary)
0000B89C                          7591  ; d4 is decimal exponent
0000B89C                          7592  
0000B89C                          7593  ; get FAC1 from string
0000B89C                          7594  ; this routine now handles hex and binary values from strings
0000B89C                          7595  ; starting with "$" and "%" respectively
0000B89C                          7596  
0000B89C                          7597  LAB_2887
0000B89C  48E7 7C00               7598      MOVEM.l d1-d5,-(sp)             ; save registers
0000B8A0  7200                    7599      MOVEQ       #$00,d1             ; clear temp accumulator
0000B8A2  2601                    7600      MOVE.l  d1,d3                   ; set mantissa decimal exponent count
0000B8A4  2801                    7601      MOVE.l  d1,d4                   ; clear decimal exponent
0000B8A6  1741 0595               7602      MOVE.b  d1,FAC1_s(a3)           ; clear sign byte
0000B8AA  1741 05B5               7603      MOVE.b  d1,Dtypef(a3)           ; set float data type
0000B8AE  1741 05AF               7604      MOVE.b  d1,expneg(a3)           ; clear exponent sign
0000B8B2  6100 E4F0               7605      BSR     LAB_GBYT                ; get first byte back
0000B8B6  653C                    7606      BCS.s       LAB_28FE                ; go get floating if 1st character numeric
0000B8B8                          7607  
0000B8B8  B03C 002D               7608      CMP.b       #'-',d0             ; or is it -ve number
0000B8BC  6608                    7609      BNE.s       LAB_289A                ; branch if not
0000B8BE                          7610  
0000B8BE  177C 00FF 0595          7611      MOVE.b  #$FF,FAC1_s(a3)         ; set sign byte
0000B8C4  6006                    7612      BRA.s       LAB_289C                ; now go scan & check for hex/bin/int
0000B8C6                          7613  
0000B8C6                          7614  LAB_289A
0000B8C6                          7615                                  ; first character wasn't numeric or -
0000B8C6  B03C 002B               7616      CMP.b       #'+',d0             ; compare with '+'
0000B8CA  6606                    7617      BNE.s       LAB_289D                ; branch if not '+' (go check for '.'/hex/binary
0000B8CC                          7618                                  ; /integer)
0000B8CC                          7619      
0000B8CC                          7620  LAB_289C
0000B8CC                          7621                                  ; was "+" or "-" to start, so get next character
0000B8CC  6100 E4D4               7622      BSR     LAB_IGBY                ; increment & scan memory
0000B8D0  6522                    7623      BCS.s       LAB_28FE                ; branch if numeric character
0000B8D2                          7624  
0000B8D2                          7625  LAB_289D
0000B8D2  B03C 002E               7626      CMP.b       #'.',d0             ; else compare with '.'
0000B8D6  6700 0092               7627      BEQ     LAB_2904                ; branch if '.'
0000B8DA                          7628  
0000B8DA                          7629                                  ; code here for hex/binary/integer numbers
0000B8DA  B03C 0024               7630      CMP.b       #'$',d0             ; compare with '$'
0000B8DE  6700 010A               7631      BEQ     LAB_CHEX                ; branch if '$'
0000B8E2                          7632  
0000B8E2  B03C 0025               7633      CMP.b       #'%',d0             ; else compare with '%'
0000B8E6  6700 0164               7634      BEQ     LAB_CBIN                ; branch if '%'
0000B8EA                          7635  
0000B8EA  6000 008C               7636      BRA     LAB_2Y01                ; not #.$%& so return 0
0000B8EE                          7637  
0000B8EE                          7638  LAB_28FD
0000B8EE  6100 E4B2               7639      BSR     LAB_IGBY                ; get next character
0000B8F2  646C                    7640      BCC.s       LAB_2902                ; exit loop if not a digit
0000B8F4                          7641  
0000B8F4                          7642  LAB_28FE
0000B8F4  6100 01A8               7643      BSR     d1x10                   ; multiply d1 by 10 and add character
0000B8F8  64F4                    7644      BCC.s       LAB_28FD                ; loop for more if no overflow
0000B8FA                          7645  
0000B8FA                          7646  LAB_28FF
0000B8FA                          7647                                  ; overflowed mantissa, count 10s exponent
0000B8FA  5283                    7648      ADDQ.l  #1,d3                   ; increment mantissa decimal exponent count
0000B8FC  6100 E4A4               7649      BSR     LAB_IGBY                ; get next character
0000B900  65F8                    7650      BCS.s       LAB_28FF                ; loop while numeric character
0000B902                          7651  
0000B902                          7652                                  ; done overflow, now flush fraction or do E
0000B902  B03C 002E               7653      CMP.b       #'.',d0             ; else compare with '.'
0000B906  6606                    7654      BNE.s       LAB_2901                ; branch if not '.'
0000B908                          7655  
0000B908                          7656  LAB_2900
0000B908                          7657                                  ; flush remaining fraction digits
0000B908  6100 E498               7658      BSR     LAB_IGBY                ; get next character
0000B90C  65FA                    7659      BCS     LAB_2900                ; loop while numeric character
0000B90E                          7660  
0000B90E                          7661  LAB_2901
0000B90E                          7662                                  ; done number, only (possible) exponent remains
0000B90E  B03C 0045               7663      CMP.b       #'E',d0             ; else compare with 'E'
0000B912  6664                    7664      BNE.s       LAB_2Y01                ; if not 'E' all done, go evaluate
0000B914                          7665  
0000B914                          7666                                  ; process exponent
0000B914  6100 E48C               7667      BSR     LAB_IGBY                ; get next character
0000B918  6528                    7668      BCS.s       LAB_2X04                ; branch if digit
0000B91A                          7669  
0000B91A  B03C 002D               7670      CMP.b       #'-',d0             ; or is it -ve number
0000B91E  6706                    7671      BEQ.s       LAB_2X01                ; branch if so
0000B920                          7672  
0000B920  B03C 00B3               7673      CMP.b       #TK_MINUS,d0            ; or is it -ve number
0000B924  6608                    7674      BNE.s       LAB_2X02                ; branch if not
0000B926                          7675  
0000B926                          7676  LAB_2X01
0000B926  177C 00FF 05AF          7677      MOVE.b  #$FF,expneg(a3)         ; set exponent sign
0000B92C  600E                    7678      BRA.s       LAB_2X03                ; now go scan & check exponent
0000B92E                          7679  
0000B92E                          7680  LAB_2X02
0000B92E  B03C 002B               7681      CMP.b       #'+',d0             ; or is it +ve number
0000B932  6708                    7682      BEQ.s       LAB_2X03                ; branch if so
0000B934                          7683  
0000B934  B03C 00B2               7684      CMP.b       #TK_PLUS,d0             ; or is it +ve number
0000B938  6600 D820               7685      BNE     LAB_SNER                ; wasn't - + TK_MINUS TK_PLUS or # so do error
0000B93C                          7686  
0000B93C                          7687  LAB_2X03
0000B93C  6100 E464               7688      BSR     LAB_IGBY                ; get next character
0000B940  6436                    7689      BCC.s       LAB_2Y01                ; if not digit all done, go evaluate
0000B942                          7690  LAB_2X04
0000B942  C8FC 000A               7691      MULU        #10,d4              ; multiply decimal exponent by 10
0000B946  C0BC 000000FF           7692      AND.l       #$FF,d0             ; mask character
0000B94C  0400 0030               7693      SUB.b       #'0',d0             ; convert to value
0000B950  D880                    7694      ADD.l       d0,d4                   ; add to decimal exponent
0000B952  B83C 0030               7695      CMP.b       #48,d4              ; compare with decimal exponent limit+10
0000B956  6FE4                    7696      BLE.s       LAB_2X03                ; loop if no overflow/underflow
0000B958                          7697  
0000B958                          7698  LAB_2X05
0000B958                          7699                                  ; exponent value has overflowed
0000B958  6100 E448               7700      BSR     LAB_IGBY                ; get next character
0000B95C  65FA                    7701      BCS.s       LAB_2X05                ; loop while numeric digit
0000B95E                          7702  
0000B95E  6018                    7703      BRA.s       LAB_2Y01                ; all done, go evaluate
0000B960                          7704  
0000B960                          7705  LAB_2902
0000B960  B03C 002E               7706      CMP.b       #'.',d0             ; else compare with '.'
0000B964  6704                    7707      BEQ.s       LAB_2904                ; branch if was '.'
0000B966                          7708  
0000B966  60A6                    7709      BRA.s       LAB_2901                ; branch if not '.' (go check/do 'E')
0000B968                          7710  
0000B968                          7711  LAB_2903
0000B968  5383                    7712      SUBQ.l  #1,d3                   ; decrement mantissa decimal exponent
0000B96A                          7713  LAB_2904
0000B96A                          7714                                  ; was dp so get fraction part
0000B96A  6100 E436               7715      BSR     LAB_IGBY                ; get next character
0000B96E  649E                    7716      BCC.s       LAB_2901                ; exit loop if not a digit (go check/do 'E')
0000B970                          7717  
0000B970  6100 012C               7718      BSR     d1x10                   ; multiply d1 by 10 and add character
0000B974  64F2                    7719      BCC.s       LAB_2903                ; loop for more if no overflow
0000B976                          7720  
0000B976  6090                    7721      BRA.s       LAB_2900                ; else go flush remaining fraction part
0000B978                          7722  
0000B978                          7723  LAB_2Y01
0000B978                          7724                                  ; now evaluate result
0000B978  4A2B 05AF               7725      TST.b       expneg(a3)              ; test exponent sign
0000B97C  6A02                    7726      BPL.s       LAB_2Y02                ; branch if sign positive
0000B97E                          7727  
0000B97E  4484                    7728      NEG.l       d4                  ; negate decimal exponent
0000B980                          7729  LAB_2Y02
0000B980  D883                    7730      ADD.l       d3,d4                   ; add mantissa decimal exponent
0000B982  7620                    7731      MOVEQ       #32,d3              ; set up max binary exponent
0000B984  4A81                    7732      TST.l       d1                  ; test mantissa
0000B986  6752                    7733      BEQ.s       LAB_rtn0                ; if mantissa=0 return 0
0000B988                          7734  
0000B988  6B08                    7735      BMI.s       LAB_2Y04                ; branch if already mormalised
0000B98A                          7736  
0000B98A  5383                    7737      SUBQ.l  #1,d3                   ; decrement bianry exponent for DBMI loop
0000B98C                          7738  LAB_2Y03
0000B98C  D281                    7739      ADD.l       d1,d1                   ; shift mantissa
0000B98E  5BCB FFFC               7740      DBMI        d3,LAB_2Y03             ; decrement & loop if not normalised
0000B992                          7741  
0000B992                          7742                                  ; ensure not too big or small
0000B992                          7743  LAB_2Y04
0000B992  B8BC 00000026           7744      CMP.l       #38,d4              ; compare decimal exponent with max exponent
0000B998  6E00 D7B0               7745      BGT     LAB_OFER                ; if greater do overflow error and warm start
0000B99C                          7746  
0000B99C  B8BC FFFFFFDA           7747      CMP.l       #-38,d4             ; compare decimal exponent with min exponent
0000B9A2  6D34                    7748      BLT.s       LAB_ret0                ; if less just return zero
0000B9A4                          7749  
0000B9A4  4484                    7750      NEG.l       d4                  ; negate decimal exponent to go right way
0000B9A6  C9FC 0006               7751      MULS        #6,d4                   ; 6 bytes per entry
0000B9AA  2F08                    7752      MOVE.l  a0,-(sp)                ; save register
0000B9AC  41FA 0210               7753      LEA     LAB_P_10(pc),a0         ; point to table
0000B9B0  1770 4000 059C          7754      MOVE.b  (a0,d4.w),FAC2_e(a3)        ; copy exponent for multiply
0000B9B6  2770 4002 0598          7755      MOVE.l  2(a0,d4.w),FAC2_m(a3)       ; copy table mantissa
0000B9BC  205F                    7756      MOVE.l  (sp)+,a0                ; restore register
0000B9BE                          7757  
0000B9BE  0A03 0080               7758      EORI.b  #$80,d3             ; normalise input exponent
0000B9C2  2741 0590               7759      MOVE.l  d1,FAC1_m(a3)           ; save input mantissa
0000B9C6  1743 0594               7760      MOVE.b  d3,FAC1_e(a3)           ; save input exponent
0000B9CA  176B 0595 059E          7761      MOVE.b  FAC1_s(a3),FAC_sc(a3)       ; set sign as sign compare
0000B9D0                          7762  
0000B9D0  4CDF 003E               7763      MOVEM.l (sp)+,d1-d5             ; restore registers
0000B9D4  6000 F054               7764      BRA     LAB_MULTIPLY            ; go multiply input by table
0000B9D8                          7765  
0000B9D8                          7766  LAB_ret0
0000B9D8  7200                    7767      MOVEQ       #0,d1                   ; clear mantissa
0000B9DA                          7768  LAB_rtn0
0000B9DA  2601                    7769      MOVE.l  d1,d3                   ; clear exponent
0000B9DC  1743 0594               7770      MOVE.b  d3,FAC1_e(a3)           ; save exponent
0000B9E0  2741 0590               7771      MOVE.l  d1,FAC1_m(a3)           ; save mantissa
0000B9E4  4CDF 003E               7772      MOVEM.l (sp)+,d1-d5             ; restore registers
0000B9E8  4E75                    7773      RTS
0000B9EA                          7774  
0000B9EA                          7775  
0000B9EA                          7776  ;************************************************************************************
0000B9EA                          7777  ;
0000B9EA                          7778  ; $ for hex add-on
0000B9EA                          7779  
0000B9EA                          7780  ; gets here if the first character was "$" for hex
0000B9EA                          7781  ; get hex number
0000B9EA                          7782  
0000B9EA                          7783  LAB_CHEX
0000B9EA  177C 0040 05B5          7784      MOVE.b  #$40,Dtypef(a3)         ; set integer numeric data type
0000B9F0  7620                    7785      MOVEQ       #32,d3              ; set up max binary exponent
0000B9F2                          7786  LAB_CHXX
0000B9F2  6100 E3AE               7787      BSR     LAB_IGBY                ; increment & scan memory
0000B9F6  6514                    7788      BCS.s       LAB_ISHN                ; branch if numeric character
0000B9F8                          7789  
0000B9F8  803C 0020               7790      OR.b        #$20,d0             ; case convert, allow "A" to "F" and "a" to "f"
0000B9FC  0400 0061               7791      SUB.b       #'a',d0             ; subtract "a"
0000BA00  652A                    7792      BCS.s       LAB_CHX3                ; exit if <"a"
0000BA02                          7793  
0000BA02  B03C 0006               7794      CMP.b       #$06,d0             ; compare normalised with $06 (max+1)
0000BA06  6424                    7795      BCC.s       LAB_CHX3                ; exit if >"f"
0000BA08                          7796  
0000BA08  0600 003A               7797      ADD.b       #$3A,d0             ; convert to nibble+"0"
0000BA0C                          7798  LAB_ISHN
0000BA0C  616C                    7799      BSR.s       d1x16                   ; multiply d1 by 16 and add the character
0000BA0E  64E2                    7800      BCC.s       LAB_CHXX                ; loop for more if no overflow
0000BA10                          7801  
0000BA10                          7802                                  ; overflowed mantissa, count 16s exponent
0000BA10                          7803  LAB_CHX1
0000BA10  5883                    7804      ADDQ.l  #4,d3                   ; increment mantissa exponent count
0000BA12  6900 D736               7805      BVS     LAB_OFER                ; do overflow error if overflowed
0000BA16                          7806  
0000BA16  6100 E38A               7807      BSR     LAB_IGBY                ; get next character
0000BA1A  65F4                    7808      BCS.s       LAB_CHX1                ; loop while numeric character
0000BA1C                          7809  
0000BA1C  803C 0020               7810      OR.b        #$20,d0             ; case convert, allow "A" to "F" and "a" to "f"
0000BA20  0400 0061               7811      SUB.b       #'a',d0             ; subtract "a"
0000BA24  6506                    7812      BCS.s       LAB_CHX3                ; exit if <"a"
0000BA26                          7813  
0000BA26  B03C 0006               7814      CMP.b       #$06,d0             ; compare normalised with $06 (max+1)
0000BA2A  65E4                    7815      BCS.s       LAB_CHX1                ; loop if <="f"
0000BA2C                          7816  
0000BA2C                          7817                                  ; now return value
0000BA2C                          7818  LAB_CHX3
0000BA2C  4A81                    7819      TST.l       d1                  ; test mantissa
0000BA2E  67AA                    7820      BEQ.s       LAB_rtn0                ; if mantissa=0 return 0
0000BA30                          7821  
0000BA30  6B08                    7822      BMI.s       LAB_exxf                ; branch if already mormalised
0000BA32                          7823  
0000BA32  5383                    7824      SUBQ.l  #1,d3                   ; decrement bianry exponent for DBMI loop
0000BA34                          7825  LAB_CHX2
0000BA34  D281                    7826      ADD.l       d1,d1                   ; shift mantissa
0000BA36  5BCB FFFC               7827      DBMI        d3,LAB_CHX2             ; decrement & loop if not normalised
0000BA3A                          7828  
0000BA3A                          7829  LAB_exxf
0000BA3A  0A03 0080               7830      EORI.b  #$80,d3             ; normalise exponent
0000BA3E  1743 0594               7831      MOVE.b  d3,FAC1_e(a3)           ; save exponent
0000BA42  2741 0590               7832      MOVE.l  d1,FAC1_m(a3)           ; save mantissa
0000BA46  4CDF 003E               7833      MOVEM.l (sp)+,d1-d5             ; restore registers
0000BA4A                          7834  RTS_024
0000BA4A  4E75                    7835      RTS
0000BA4C                          7836  
0000BA4C                          7837  
0000BA4C                          7838  ;************************************************************************************
0000BA4C                          7839  ;
0000BA4C                          7840  ; % for binary add-on
0000BA4C                          7841  
0000BA4C                          7842  ; gets here if the first character was "%" for binary
0000BA4C                          7843  ; get binary number
0000BA4C                          7844  
0000BA4C                          7845  LAB_CBIN
0000BA4C  177C 0040 05B5          7846      MOVE.b  #$40,Dtypef(a3)         ; set integer numeric data type
0000BA52  7620                    7847      MOVEQ       #32,d3              ; set up max binary exponent
0000BA54                          7848  LAB_CBXN
0000BA54  6100 E34C               7849      BSR     LAB_IGBY                ; increment & scan memory
0000BA58  64D2                    7850      BCC.s       LAB_CHX3                ; if not numeric character go return value
0000BA5A                          7851  
0000BA5A  B03C 0032               7852      CMP.b       #'2',d0             ; compare with "2" (max+1)
0000BA5E  64CC                    7853      BCC.s       LAB_CHX3                ; if >="2" go return value
0000BA60                          7854  
0000BA60  2401                    7855      MOVE.l  d1,d2                   ; copy value
0000BA62  6124                    7856      BSR.s       d1x02                   ; multiply d1 by 2 and add character
0000BA64  64EE                    7857      BCC.s       LAB_CBXN                ; loop for more if no overflow
0000BA66                          7858  
0000BA66                          7859                                  ; overflowed mantissa, count 2s exponent
0000BA66                          7860  LAB_CBX1
0000BA66  5283                    7861      ADDQ.l  #1,d3                   ; increment mantissa exponent count
0000BA68  6900 D6E0               7862      BVS     LAB_OFER                ; do overflow error if overflowed
0000BA6C                          7863  
0000BA6C  6100 E334               7864      BSR     LAB_IGBY                ; get next character
0000BA70  64BA                    7865      BCC.s       LAB_CHX3                ; if not numeric character go return value
0000BA72                          7866  
0000BA72  B03C 0032               7867      CMP.b       #'2',d0             ; compare with "2" (max+1)
0000BA76  65EE                    7868      BCS.s       LAB_CBX1                ; loop if <"2"
0000BA78                          7869  
0000BA78  60B2                    7870      BRA.s       LAB_CHX3                ; if not numeric character go return value
0000BA7A                          7871  
0000BA7A                          7872  ; half way decent times 16 and times 2 with overflow checks
0000BA7A                          7873  
0000BA7A                          7874  d1x16
0000BA7A  2401                    7875      MOVE.l  d1,d2                   ; copy value
0000BA7C  D482                    7876      ADD.l       d2,d2                   ; times two
0000BA7E  65CA                    7877      BCS.s       RTS_024             ; return if overflow
0000BA80                          7878  
0000BA80  D482                    7879      ADD.l       d2,d2                   ; times four
0000BA82  65C6                    7880      BCS.s       RTS_024             ; return if overflow
0000BA84                          7881  
0000BA84  D482                    7882      ADD.l       d2,d2                   ; times eight
0000BA86  65C2                    7883      BCS.s       RTS_024             ; return if overflow
0000BA88                          7884  
0000BA88                          7885  d1x02
0000BA88  D482                    7886      ADD.l       d2,d2                   ; times sixteen (ten/two)
0000BA8A  65BE                    7887      BCS.s       RTS_024             ; return if overflow
0000BA8C                          7888  
0000BA8C                          7889  ; now add in new digit
0000BA8C                          7890  
0000BA8C  C0BC 000000FF           7891      AND.l       #$FF,d0             ; mask character
0000BA92  0400 0030               7892      SUB.b       #'0',d0             ; convert to value
0000BA96  D480                    7893      ADD.l       d0,d2                   ; add to result
0000BA98  65B0                    7894      BCS.s       RTS_024             ; return if overflow, it should never ever do
0000BA9A                          7895                                  ; this
0000BA9A                          7896  
0000BA9A  2202                    7897      MOVE.l  d2,d1                   ; copy result
0000BA9C  4E75                    7898      RTS
0000BA9E                          7899  
0000BA9E                          7900  ; half way decent times 10 with overflow checks
0000BA9E                          7901  
0000BA9E                          7902  d1x10
0000BA9E  2401                    7903      MOVE.l  d1,d2                   ; copy value
0000BAA0  D482                    7904      ADD.l       d2,d2                   ; times two
0000BAA2  6508                    7905      BCS.s       RTS_025             ; return if overflow
0000BAA4                          7906  
0000BAA4  D482                    7907      ADD.l       d2,d2                   ; times four
0000BAA6  6504                    7908      BCS.s       RTS_025             ; return if overflow
0000BAA8                          7909  
0000BAA8  D481                    7910      ADD.l       d1,d2                   ; times five
0000BAAA  64DC                    7911      BCC.s       d1x02                   ; do times two and add in new digit if ok
0000BAAC                          7912  
0000BAAC                          7913  RTS_025
0000BAAC  4E75                    7914      RTS
0000BAAE                          7915  
0000BAAE                          7916  
0000BAAE                          7917  ;************************************************************************************
0000BAAE                          7918  ;
0000BAAE                          7919  ; token values needed for BASIC
0000BAAE                          7920  
0000BAAE  =00000080               7921  TK_END      EQU $80             ; $80
0000BAAE  =00000081               7922  TK_FOR      EQU TK_END+1            ; $81
0000BAAE  =00000082               7923  TK_NEXT     EQU TK_FOR+1            ; $82
0000BAAE  =00000083               7924  TK_DATA     EQU TK_NEXT+1           ; $83
0000BAAE  =00000084               7925  TK_INPUT        EQU TK_DATA+1           ; $84
0000BAAE  =00000085               7926  TK_DIM      EQU TK_INPUT+1          ; $85
0000BAAE  =00000086               7927  TK_READ     EQU TK_DIM+1            ; $86
0000BAAE  =00000087               7928  TK_LET      EQU TK_READ+1           ; $87
0000BAAE  =00000088               7929  TK_DEC      EQU TK_LET+1            ; $88
0000BAAE  =00000089               7930  TK_GOTO     EQU TK_DEC+1            ; $89
0000BAAE  =0000008A               7931  TK_RUN      EQU TK_GOTO+1           ; $8A
0000BAAE  =0000008B               7932  TK_IF           EQU TK_RUN+1            ; $8B
0000BAAE  =0000008C               7933  TK_RESTORE      EQU TK_IF+1             ; $8C
0000BAAE  =0000008D               7934  TK_GOSUB        EQU TK_RESTORE+1            ; $8D
0000BAAE  =0000008E               7935  TK_RETURN       EQU TK_GOSUB+1          ; $8E
0000BAAE  =0000008F               7936  TK_REM      EQU TK_RETURN+1         ; $8F
0000BAAE  =00000090               7937  TK_STOP     EQU TK_REM+1            ; $90
0000BAAE  =00000091               7938  TK_ON           EQU TK_STOP+1           ; $91
0000BAAE  =00000092               7939  TK_NULL     EQU TK_ON+1             ; $92
0000BAAE  =00000093               7940  TK_INC      EQU TK_NULL+1           ; $93
0000BAAE  =00000094               7941  TK_WAIT     EQU TK_INC+1            ; $94
0000BAAE  =00000095               7942  TK_LOAD     EQU TK_WAIT+1           ; $95
0000BAAE  =00000096               7943  TK_SAVE     EQU TK_LOAD+1           ; $96
0000BAAE  =00000097               7944  TK_DEF      EQU TK_SAVE+1           ; $97
0000BAAE  =00000098               7945  TK_POKE     EQU TK_DEF+1            ; $98
0000BAAE  =00000099               7946  TK_DOKE     EQU TK_POKE+1           ; $99
0000BAAE  =0000009A               7947  TK_LOKE     EQU TK_DOKE+1           ; $9A
0000BAAE  =0000009B               7948  TK_CALL     EQU TK_LOKE+1           ; $9B
0000BAAE  =0000009C               7949  TK_DO           EQU TK_CALL+1           ; $9C
0000BAAE  =0000009D               7950  TK_LOOP     EQU TK_DO+1             ; $9D
0000BAAE  =0000009E               7951  TK_PRINT        EQU TK_LOOP+1           ; $9E
0000BAAE  =0000009F               7952  TK_CONT     EQU TK_PRINT+1          ; $9F
0000BAAE  =000000A0               7953  TK_LIST     EQU TK_CONT+1           ; $A0
0000BAAE  =000000A1               7954  TK_CLEAR        EQU TK_LIST+1           ; $A1
0000BAAE  =000000A2               7955  TK_NEW      EQU TK_CLEAR+1          ; $A2
0000BAAE  =000000A3               7956  TK_WIDTH        EQU TK_NEW+1            ; $A3
0000BAAE  =000000A4               7957  TK_GET      EQU TK_WIDTH+1          ; $A4
0000BAAE  =000000A5               7958  TK_SWAP     EQU TK_GET+1            ; $A5
0000BAAE  =000000A6               7959  TK_BITSET       EQU TK_SWAP+1           ; $A6
0000BAAE  =000000A7               7960  TK_BITCLR       EQU TK_BITSET+1         ; $A7
0000BAAE  =000000A8               7961  TK_TAB      EQU TK_BITCLR+1         ; $A8
0000BAAE  =000000A9               7962  TK_ELSE     EQU TK_TAB+1            ; $A9
0000BAAE  =000000AA               7963  TK_TO           EQU TK_ELSE+1           ; $AA
0000BAAE  =000000AB               7964  TK_FN           EQU TK_TO+1             ; $AB
0000BAAE  =000000AC               7965  TK_SPC      EQU TK_FN+1             ; $AC
0000BAAE  =000000AD               7966  TK_THEN     EQU TK_SPC+1            ; $AD
0000BAAE  =000000AE               7967  TK_NOT      EQU TK_THEN+1           ; $AE
0000BAAE  =000000AF               7968  TK_STEP     EQU TK_NOT+1            ; $AF
0000BAAE  =000000B0               7969  TK_UNTIL        EQU TK_STEP+1           ; $B0
0000BAAE  =000000B1               7970  TK_WHILE        EQU TK_UNTIL+1          ; $B1
0000BAAE  =000000B2               7971  TK_PLUS     EQU TK_WHILE+1          ; $B2
0000BAAE  =000000B3               7972  TK_MINUS        EQU TK_PLUS+1           ; $B3
0000BAAE  =000000B4               7973  TK_MULT     EQU TK_MINUS+1          ; $B4
0000BAAE  =000000B5               7974  TK_DIV      EQU TK_MULT+1           ; $B5
0000BAAE  =000000B6               7975  TK_POWER        EQU TK_DIV+1            ; $B6
0000BAAE  =000000B7               7976  TK_AND      EQU TK_POWER+1          ; $B7
0000BAAE  =000000B8               7977  TK_EOR      EQU TK_AND+1            ; $B8
0000BAAE  =000000B9               7978  TK_OR           EQU TK_EOR+1            ; $B9
0000BAAE  =000000BA               7979  TK_RSHIFT       EQU TK_OR+1             ; $BA
0000BAAE  =000000BB               7980  TK_LSHIFT       EQU TK_RSHIFT+1         ; $BB
0000BAAE  =000000BC               7981  TK_GT           EQU TK_LSHIFT+1         ; $BC
0000BAAE  =000000BD               7982  TK_EQUAL        EQU TK_GT+1             ; $BD
0000BAAE  =000000BE               7983  TK_LT           EQU TK_EQUAL+1          ; $BE
0000BAAE  =000000BF               7984  TK_SGN      EQU TK_LT+1             ; $BF
0000BAAE  =000000C0               7985  TK_INT      EQU TK_SGN+1            ; $C0
0000BAAE  =000000C1               7986  TK_ABS      EQU TK_INT+1            ; $C1
0000BAAE  =000000C2               7987  TK_USR      EQU TK_ABS+1            ; $C2
0000BAAE  =000000C3               7988  TK_FRE      EQU TK_USR+1            ; $C3
0000BAAE  =000000C4               7989  TK_POS      EQU TK_FRE+1            ; $C4
0000BAAE  =000000C5               7990  TK_SQR      EQU TK_POS+1            ; $C5
0000BAAE  =000000C6               7991  TK_RND      EQU TK_SQR+1            ; $C6
0000BAAE  =000000C7               7992  TK_LOG      EQU TK_RND+1            ; $C7
0000BAAE  =000000C8               7993  TK_EXP      EQU TK_LOG+1            ; $C8
0000BAAE  =000000C9               7994  TK_COS      EQU TK_EXP+1            ; $C9
0000BAAE  =000000CA               7995  TK_SIN      EQU TK_COS+1            ; $CA
0000BAAE  =000000CB               7996  TK_TAN      EQU TK_SIN+1            ; $CB
0000BAAE  =000000CC               7997  TK_ATN      EQU TK_TAN+1            ; $CC
0000BAAE  =000000CD               7998  TK_PEEK     EQU TK_ATN+1            ; $CD
0000BAAE  =000000CE               7999  TK_DEEK     EQU TK_PEEK+1           ; $CE
0000BAAE  =000000CF               8000  TK_LEEK     EQU TK_DEEK+1           ; $CF
0000BAAE  =000000D0               8001  TK_LEN      EQU TK_LEEK+1           ; $D0
0000BAAE  =000000D1               8002  TK_STRS     EQU TK_LEN+1            ; $D1
0000BAAE  =000000D2               8003  TK_VAL      EQU TK_STRS+1           ; $D2
0000BAAE  =000000D3               8004  TK_ASC      EQU TK_VAL+1            ; $D3
0000BAAE  =000000D4               8005  TK_UCASES       EQU TK_ASC+1            ; $D4
0000BAAE  =000000D5               8006  TK_LCASES       EQU TK_UCASES+1         ; $D5
0000BAAE  =000000D6               8007  TK_CHRS     EQU TK_LCASES+1         ; $D6
0000BAAE  =000000D7               8008  TK_HEXS     EQU TK_CHRS+1           ; $D7
0000BAAE  =000000D8               8009  TK_BINS     EQU TK_HEXS+1           ; $D8
0000BAAE  =000000D9               8010  TK_BITTST       EQU TK_BINS+1           ; $D9
0000BAAE  =000000DA               8011  TK_MAX      EQU TK_BITTST+1         ; $DA
0000BAAE  =000000DB               8012  TK_MIN      EQU TK_MAX+1            ; $DB
0000BAAE  =000000DC               8013  TK_RAM      EQU TK_MIN+1            ; $DC
0000BAAE  =000000DD               8014  TK_PI           EQU TK_RAM+1            ; $DD
0000BAAE  =000000DE               8015  TK_TWOPI        EQU TK_PI+1             ; $DE
0000BAAE  =000000DF               8016  TK_VPTR     EQU TK_TWOPI+1          ; $DF
0000BAAE  =000000E0               8017  TK_SADD     EQU TK_VPTR+1           ; $E0
0000BAAE  =000000E1               8018  TK_LEFTS        EQU TK_SADD+1           ; $E1
0000BAAE  =000000E2               8019  TK_RIGHTS       EQU TK_LEFTS+1          ; $E2
0000BAAE  =000000E3               8020  TK_MIDS     EQU TK_RIGHTS+1         ; $E3
0000BAAE  =000000E4               8021  TK_USINGS       EQU TK_MIDS+1           ; $E4
0000BAAE                          8022  
0000BAAE                          8023  
0000BAAE                          8024  ;************************************************************************************
0000BAAE                          8025  ;
0000BAAE                          8026  ; binary to unsigned decimal table
0000BAAE                          8027  
0000BAAE                          8028  Bin2dec
0000BAAE= 3B9ACA00                8029      dc.l    $3B9ACA00                   ; 1000000000
0000BAB2= 05F5E100                8030      dc.l    $05F5E100                   ; 100000000
0000BAB6= 00989680                8031      dc.l    $00989680                   ; 10000000
0000BABA= 000F4240                8032      dc.l    $000F4240                   ; 1000000
0000BABE= 000186A0                8033      dc.l    $000186A0                   ; 100000
0000BAC2= 00002710                8034      dc.l    $00002710                   ; 10000
0000BAC6= 000003E8                8035      dc.l    $000003E8                   ; 1000
0000BACA= 00000064                8036      dc.l    $00000064                   ; 100
0000BACE= 0000000A                8037      dc.l    $0000000A                   ; 10
0000BAD2= 00000000                8038      dc.l    $00000000                   ; 0 end marker
0000BAD6                          8039  
0000BAD6                          8040  LAB_RSED
0000BAD6= 332E3232                8041      dc.l    $332E3232                   ; 858665522
0000BADA                          8042  
0000BADA                          8043  ; string to value exponent table
0000BADA                          8044  
0000BADA= FF00                    8045      dc.w    255<<8                  ; 10**38
0000BADC= 96769951                8046      dc.l    $96769951
0000BAE0= FB00                    8047      dc.w    251<<8                  ; 10**37
0000BAE2= F0BDC21B                8048      dc.l    $F0BDC21B
0000BAE6= F800                    8049      dc.w    248<<8                  ; 10**36
0000BAE8= C097CE7C                8050      dc.l    $C097CE7C
0000BAEC= F500                    8051      dc.w    245<<8                  ; 10**35
0000BAEE= 9A130B96                8052      dc.l    $9A130B96
0000BAF2= F100                    8053      dc.w    241<<8                  ; 10**34
0000BAF4= F684DF57                8054      dc.l    $F684DF57
0000BAF8= EE00                    8055      dc.w    238<<8                  ; 10**33
0000BAFA= C5371912                8056      dc.l    $C5371912
0000BAFE= EB00                    8057      dc.w    235<<8                  ; 10**32
0000BB00= 9DC5ADA8                8058      dc.l    $9DC5ADA8
0000BB04= E700                    8059      dc.w    231<<8                  ; 10**31
0000BB06= FC6F7C40                8060      dc.l    $FC6F7C40
0000BB0A= E400                    8061      dc.w    228<<8                  ; 10**30
0000BB0C= C9F2C9CD                8062      dc.l    $C9F2C9CD
0000BB10= E100                    8063      dc.w    225<<8                  ; 10**29
0000BB12= A18F07D7                8064      dc.l    $A18F07D7
0000BB16= DE00                    8065      dc.w    222<<8                  ; 10**28
0000BB18= 813F3979                8066      dc.l    $813F3979
0000BB1C= DA00                    8067      dc.w    218<<8                  ; 10**27
0000BB1E= CECB8F28                8068      dc.l    $CECB8F28
0000BB22= D700                    8069      dc.w    215<<8                  ; 10**26
0000BB24= A56FA5BA                8070      dc.l    $A56FA5BA
0000BB28= D400                    8071      dc.w    212<<8                  ; 10**25
0000BB2A= 84595161                8072      dc.l    $84595161
0000BB2E= D000                    8073      dc.w    208<<8                  ; 10**24
0000BB30= D3C21BCF                8074      dc.l    $D3C21BCF
0000BB34= CD00                    8075      dc.w    205<<8                  ; 10**23
0000BB36= A968163F                8076      dc.l    $A968163F
0000BB3A= CA00                    8077      dc.w    202<<8                  ; 10**22
0000BB3C= 87867832                8078      dc.l    $87867832
0000BB40= C600                    8079      dc.w    198<<8                  ; 10**21
0000BB42= D8D726B7                8080      dc.l    $D8D726B7
0000BB46= C300                    8081      dc.w    195<<8                  ; 10**20
0000BB48= AD78EBC6                8082      dc.l    $AD78EBC6
0000BB4C= C000                    8083      dc.w    192<<8                  ; 10**19
0000BB4E= 8AC72305                8084      dc.l    $8AC72305
0000BB52= BC00                    8085      dc.w    188<<8                  ; 10**18
0000BB54= DE0B6B3A                8086      dc.l    $DE0B6B3A
0000BB58= B900                    8087      dc.w    185<<8                  ; 10**17
0000BB5A= B1A2BC2F                8088      dc.l    $B1A2BC2F
0000BB5E= B600                    8089      dc.w    182<<8                  ; 10**16
0000BB60= 8E1BC9BF                8090      dc.l    $8E1BC9BF
0000BB64= B200                    8091      dc.w    178<<8                  ; 10**15
0000BB66= E35FA932                8092      dc.l    $E35FA932
0000BB6A= AF00                    8093      dc.w    175<<8                  ; 10**14
0000BB6C= B5E620F5                8094      dc.l    $B5E620F5
0000BB70= AC00                    8095      dc.w    172<<8                  ; 10**13
0000BB72= 9184E72A                8096      dc.l    $9184E72A
0000BB76= A800                    8097      dc.w    168<<8                  ; 10**12
0000BB78= E8D4A510                8098      dc.l    $E8D4A510
0000BB7C= A500                    8099      dc.w    165<<8                  ; 10**11
0000BB7E= BA43B740                8100      dc.l    $BA43B740
0000BB82= A200                    8101      dc.w    162<<8                  ; 10**10
0000BB84= 9502F900                8102      dc.l    $9502F900
0000BB88= 9E00                    8103      dc.w    158<<8                  ; 10**9
0000BB8A= EE6B2800                8104      dc.l    $EE6B2800
0000BB8E= 9B00                    8105      dc.w    155<<8                  ; 10**8
0000BB90= BEBC2000                8106      dc.l    $BEBC2000
0000BB94= 9800                    8107      dc.w    152<<8                  ; 10**7
0000BB96= 98968000                8108      dc.l    $98968000
0000BB9A= 9400                    8109      dc.w    148<<8                  ; 10**6
0000BB9C= F4240000                8110      dc.l    $F4240000
0000BBA0= 9100                    8111      dc.w    145<<8                  ; 10**5
0000BBA2= C3500000                8112      dc.l    $C3500000
0000BBA6= 8E00                    8113      dc.w    142<<8                  ; 10**4
0000BBA8= 9C400000                8114      dc.l    $9C400000
0000BBAC= 8A00                    8115      dc.w    138<<8                  ; 10**3
0000BBAE= FA000000                8116      dc.l    $FA000000
0000BBB2= 8700                    8117      dc.w    135<<8                  ; 10**2
0000BBB4= C8000000                8118      dc.l    $C8000000
0000BBB8= 8400                    8119      dc.w    132<<8                  ; 10**1
0000BBBA= A0000000                8120      dc.l    $A0000000
0000BBBE                          8121  LAB_P_10
0000BBBE= 8100                    8122      dc.w    129<<8                  ; 10**0
0000BBC0= 80000000                8123      dc.l    $80000000
0000BBC4= 7D00                    8124      dc.w    125<<8                  ; 10**-1
0000BBC6= CCCCCCCD                8125      dc.l    $CCCCCCCD
0000BBCA= 7A00                    8126      dc.w    122<<8                  ; 10**-2
0000BBCC= A3D70A3D                8127      dc.l    $A3D70A3D
0000BBD0= 7700                    8128      dc.w    119<<8                  ; 10**-3
0000BBD2= 83126E98                8129      dc.l    $83126E98
0000BBD6= 7300                    8130      dc.w    115<<8                  ; 10**-4
0000BBD8= D1B71759                8131      dc.l    $D1B71759
0000BBDC= 7000                    8132      dc.w    112<<8                  ; 10**-5
0000BBDE= A7C5AC47                8133      dc.l    $A7C5AC47
0000BBE2= 6D00                    8134      dc.w    109<<8                  ; 10**-6
0000BBE4= 8637BD06                8135      dc.l    $8637BD06
0000BBE8= 6900                    8136      dc.w    105<<8                  ; 10**-7
0000BBEA= D6BF94D6                8137      dc.l    $D6BF94D6
0000BBEE= 6600                    8138      dc.w    102<<8                  ; 10**-8
0000BBF0= ABCC7712                8139      dc.l    $ABCC7712
0000BBF4= 6300                    8140      dc.w    99<<8                       ; 10**-9
0000BBF6= 89705F41                8141      dc.l    $89705F41
0000BBFA= 5F00                    8142      dc.w    95<<8                       ; 10**-10
0000BBFC= DBE6FECF                8143      dc.l    $DBE6FECF
0000BC00= 5C00                    8144      dc.w    92<<8                       ; 10**-11
0000BC02= AFEBFF0C                8145      dc.l    $AFEBFF0C
0000BC06= 5900                    8146      dc.w    89<<8                       ; 10**-12
0000BC08= 8CBCCC09                8147      dc.l    $8CBCCC09
0000BC0C= 5500                    8148      dc.w    85<<8                       ; 10**-13
0000BC0E= E12E1342                8149      dc.l    $E12E1342
0000BC12= 5200                    8150      dc.w    82<<8                       ; 10**-14
0000BC14= B424DC35                8151      dc.l    $B424DC35
0000BC18= 4F00                    8152      dc.w    79<<8                       ; 10**-15
0000BC1A= 901D7CF7                8153      dc.l    $901D7CF7
0000BC1E= 4B00                    8154      dc.w    75<<8                       ; 10**-16
0000BC20= E69594BF                8155      dc.l    $E69594BF
0000BC24= 4800                    8156      dc.w    72<<8                       ; 10**-17
0000BC26= B877AA32                8157      dc.l    $B877AA32
0000BC2A= 4500                    8158      dc.w    69<<8                       ; 10**-18
0000BC2C= 9392EE8F                8159      dc.l    $9392EE8F
0000BC30= 4100                    8160      dc.w    65<<8                       ; 10**-19
0000BC32= EC1E4A7E                8161      dc.l    $EC1E4A7E
0000BC36= 3E00                    8162      dc.w    62<<8                       ; 10**-20
0000BC38= BCE50865                8163      dc.l    $BCE50865
0000BC3C= 3B00                    8164      dc.w    59<<8                       ; 10**-21
0000BC3E= 971DA050                8165      dc.l    $971DA050
0000BC42= 3700                    8166      dc.w    55<<8                       ; 10**-22
0000BC44= F1C90081                8167      dc.l    $F1C90081
0000BC48= 3400                    8168      dc.w    52<<8                       ; 10**-23
0000BC4A= C16D9A01                8169      dc.l    $C16D9A01
0000BC4E= 3100                    8170      dc.w    49<<8                       ; 10**-24
0000BC50= 9ABE14CD                8171      dc.l    $9ABE14CD
0000BC54= 2D00                    8172      dc.w    45<<8                       ; 10**-25
0000BC56= F79687AE                8173      dc.l    $F79687AE
0000BC5A= 2A00                    8174      dc.w    42<<8                       ; 10**-26
0000BC5C= C6120625                8175      dc.l    $C6120625
0000BC60= 2700                    8176      dc.w    39<<8                       ; 10**-27
0000BC62= 9E74D1B8                8177      dc.l    $9E74D1B8
0000BC66= 2300                    8178      dc.w    35<<8                       ; 10**-28
0000BC68= FD87B5F3                8179      dc.l    $FD87B5F3
0000BC6C= 2000                    8180      dc.w    32<<8                       ; 10**-29
0000BC6E= CAD2F7F5                8181      dc.l    $CAD2F7F5
0000BC72= 1D00                    8182      dc.w    29<<8                       ; 10**-30
0000BC74= A2425FF7                8183      dc.l    $A2425FF7
0000BC78= 1A00                    8184      dc.w    26<<8                       ; 10**-31
0000BC7A= 81CEB32C                8185      dc.l    $81CEB32C
0000BC7E= 1600                    8186      dc.w    22<<8                       ; 10**-32
0000BC80= CFB11EAD                8187      dc.l    $CFB11EAD
0000BC84= 1300                    8188      dc.w    19<<8                       ; 10**-33
0000BC86= A6274BBE                8189      dc.l    $A6274BBE
0000BC8A= 1000                    8190      dc.w    16<<8                       ; 10**-34
0000BC8C= 84EC3C98                8191      dc.l    $84EC3C98
0000BC90= 0C00                    8192      dc.w    12<<8                       ; 10**-35
0000BC92= D4AD2DC0                8193      dc.l    $D4AD2DC0
0000BC96= 0900                    8194      dc.w    9<<8                        ; 10**-36
0000BC98= AA242499                8195      dc.l    $AA242499
0000BC9C= 0600                    8196      dc.w    6<<8                        ; 10**-37
0000BC9E= 881CEA14                8197      dc.l    $881CEA14
0000BCA2= 0200                    8198      dc.w    2<<8                        ; 10**-38
0000BCA4= D9C7DCED                8199      dc.l    $D9C7DCED
0000BCA8                          8200  
0000BCA8                          8201  
0000BCA8                          8202  ;************************************************************************************
0000BCA8                          8203  ;
0000BCA8                          8204  ; table of constants for cordic SIN/COS/TAN calculations
0000BCA8                          8205  ; constants are un normalised fractions and are atn(2^-i)/2pi
0000BCA8                          8206  
0000BCA8= 4DBA76D4                8207      dc.l    $4DBA76D4                   ; SIN/COS multiply constant
0000BCAC                          8208  TAB_SNCO
0000BCAC= 20000000                8209      dc.l    $20000000                   ; atn(2^0)/2pi
0000BCB0= 12E4051E                8210      dc.l    $12E4051E                   ; atn(2^1)/2pi
0000BCB4= 09FB385C                8211      dc.l    $09FB385C                   ; atn(2^2)/2pi
0000BCB8= 051111D5                8212      dc.l    $051111D5                   ; atn(2^3)/2pi
0000BCBC= 028B0D44                8213      dc.l    $028B0D44                   ; atn(2^4)/2pi
0000BCC0= 0145D7E2                8214      dc.l    $0145D7E2                   ; atn(2^5)/2pi
0000BCC4= 00A2F61F                8215      dc.l    $00A2F61F                   ; atn(2^6)/2pi
0000BCC8= 00517C56                8216      dc.l    $00517C56                   ; atn(2^7)/2pi
0000BCCC= 0028BE54                8217      dc.l    $0028BE54                   ; atn(2^8)/2pi
0000BCD0= 00145F2F                8218      dc.l    $00145F2F                   ; atn(2^9)/2pi
0000BCD4= 000A2F99                8219      dc.l    $000A2F99                   ; atn(2^10)/2pi
0000BCD8= 000517CD                8220      dc.l    $000517CD                   ; atn(2^11)/2pi
0000BCDC= 00028BE7                8221      dc.l    $00028BE7                   ; atn(2^12)/2pi
0000BCE0= 000145F4                8222      dc.l    $000145F4                   ; atn(2^13)/2pi
0000BCE4= 0000A2FA                8223      dc.l    $0000A2FA                   ; atn(2^14)/2pi
0000BCE8= 0000517D                8224      dc.l    $0000517D                   ; atn(2^15)/2pi
0000BCEC= 000028BF                8225      dc.l    $000028BF                   ; atn(2^16)/2pi
0000BCF0= 00001460                8226      dc.l    $00001460                   ; atn(2^17)/2pi
0000BCF4= 00000A30                8227      dc.l    $00000A30                   ; atn(2^18)/2pi
0000BCF8= 00000518                8228      dc.l    $00000518                   ; atn(2^19)/2pi
0000BCFC= 0000028C                8229      dc.l    $0000028C                   ; atn(2^20)/2pi
0000BD00= 00000146                8230      dc.l    $00000146                   ; atn(2^21)/2pi
0000BD04= 000000A3                8231      dc.l    $000000A3                   ; atn(2^22)/2pi
0000BD08= 00000052                8232      dc.l    $00000052                   ; atn(2^23)/2pi
0000BD0C= 00000029                8233      dc.l    $00000029                   ; atn(2^24)/2pi
0000BD10= 00000015                8234      dc.l    $00000015                   ; atn(2^25)/2pi
0000BD14= 0000000B                8235      dc.l    $0000000B                   ; atn(2^26)/2pi
0000BD18= 00000006                8236      dc.l    $00000006                   ; atn(2^27)/2pi
0000BD1C= 00000003                8237      dc.l    $00000003                   ; atn(2^28)/2pi
0000BD20= 00000002                8238      dc.l    $00000002                   ; atn(2^29)/2pi
0000BD24= 00000001                8239      dc.l    $00000001                   ; atn(2^30)/2pi
0000BD28= 00000001                8240      dc.l    $00000001                   ; atn(2^31)/2pi
0000BD2C                          8241  
0000BD2C                          8242  
0000BD2C                          8243  ;************************************************************************************
0000BD2C                          8244  ;
0000BD2C                          8245  ; table of constants for cordic ATN calculation
0000BD2C                          8246  ; constants are normalised to two integer bits and are atn(2^-i)
0000BD2C                          8247  
0000BD2C                          8248  TAB_ATNC
0000BD2C= 1DAC6705                8249      dc.l    $1DAC6705                   ; atn(2^-1)
0000BD30= 0FADBAFD                8250      dc.l    $0FADBAFD                   ; atn(2^-2)
0000BD34= 07F56EA7                8251      dc.l    $07F56EA7                   ; atn(2^-3)
0000BD38= 03FEAB77                8252      dc.l    $03FEAB77                   ; atn(2^-4)
0000BD3C= 01FFD55C                8253      dc.l    $01FFD55C                   ; atn(2^-5)
0000BD40= 00FFFAAB                8254      dc.l    $00FFFAAB                   ; atn(2^-6)
0000BD44= 007FFF55                8255      dc.l    $007FFF55                   ; atn(2^-7)
0000BD48= 003FFFEB                8256      dc.l    $003FFFEB                   ; atn(2^-8)
0000BD4C= 001FFFFD                8257      dc.l    $001FFFFD                   ; atn(2^-9)
0000BD50= 00100000                8258      dc.l    $00100000                   ; atn(2^-10)
0000BD54= 00080000                8259      dc.l    $00080000                   ; atn(2^-11)
0000BD58= 00040000                8260      dc.l    $00040000                   ; atn(2^-12)
0000BD5C= 00020000                8261      dc.l    $00020000                   ; atn(2^-13)
0000BD60= 00010000                8262      dc.l    $00010000                   ; atn(2^-14)
0000BD64= 00008000                8263      dc.l    $00008000                   ; atn(2^-15)
0000BD68= 00004000                8264      dc.l    $00004000                   ; atn(2^-16)
0000BD6C= 00002000                8265      dc.l    $00002000                   ; atn(2^-17)
0000BD70= 00001000                8266      dc.l    $00001000                   ; atn(2^-18)
0000BD74= 00000800                8267      dc.l    $00000800                   ; atn(2^-19)
0000BD78= 00000400                8268      dc.l    $00000400                   ; atn(2^-20)
0000BD7C= 00000200                8269      dc.l    $00000200                   ; atn(2^-21)
0000BD80= 00000100                8270      dc.l    $00000100                   ; atn(2^-22)
0000BD84= 00000080                8271      dc.l    $00000080                   ; atn(2^-23)
0000BD88= 00000040                8272      dc.l    $00000040                   ; atn(2^-24)
0000BD8C= 00000020                8273      dc.l    $00000020                   ; atn(2^-25)
0000BD90= 00000010                8274      dc.l    $00000010                   ; atn(2^-26)
0000BD94= 00000008                8275      dc.l    $00000008                   ; atn(2^-27)
0000BD98= 00000004                8276      dc.l    $00000004                   ; atn(2^-28)
0000BD9C= 00000002                8277      dc.l    $00000002                   ; atn(2^-29)
0000BDA0= 00000001                8278      dc.l    $00000001                   ; atn(2^-30)
0000BDA4                          8279  LAB_1D96
0000BDA4= 00000000                8280      dc.l    $00000000                   ; atn(2^-31)
0000BDA8= 00000000                8281      dc.l    $00000000                   ; atn(2^-32)
0000BDAC                          8282  
0000BDAC                          8283  ; constants are normalised to n integer bits and are tanh(2^-i)
0000BDAC  =00000002               8284  n   equ 2
0000BDAC                          8285  TAB_HTHET
0000BDAC= 2327D4F4                8286      dc.l    $2327d4f4               ; atnh(2^-1) .549306144
0000BDB0= 1058AEFA                8287      dc.l    $1058aefa               ; atnh(2^-2) .255412812
0000BDB4= 080AC48E                8288      dc.l    $080ac48e               ; atnh(2^-3)
0000BDB8= 04015622                8289      dc.l    $04015622               ; atnh(2^-4)
0000BDBC= 02002AB0                8290      dc.l    $02002ab0               ; atnh(2^-5)
0000BDC0= 01000554                8291      dc.l    $01000554               ; atnh(2^-6)
0000BDC4= 008000AA                8292      dc.l    $008000aa               ; atnh(2^-7)
0000BDC8= 00400014                8293      dc.l    $00400014               ; atnh(2^-8)
0000BDCC= 00200002                8294      dc.l    $00200002               ; atnh(2^-9)
0000BDD0= 00100000                8295      dc.l    $00100000               ; atnh(2^-10)
0000BDD4= 00080000                8296      dc.l    $00080000               ; atnh(2^-11)
0000BDD8= 00040000                8297      dc.l    $00040000               ; atnh(2^-12)
0000BDDC= 00020000                8298      dc.l    $00020000               ; atnh(2^-13)
0000BDE0= 00010000                8299      dc.l    $00010000               ; atnh(2^-14)
0000BDE4= 00008000                8300      dc.l    $00008000               ; atnh(2^-15)
0000BDE8= 00004000                8301      dc.l    $00004000               ; atnh(2^-16)
0000BDEC= 00002000                8302      dc.l    $00002000               ; atnh(2^-17)
0000BDF0= 00001000                8303      dc.l    $00001000               ; atnh(2^-18)
0000BDF4= 00000800                8304      dc.l    $00000800               ; atnh(2^-19)
0000BDF8= 00000400                8305      dc.l    $00000400               ; atnh(2^-20)
0000BDFC= 00000200                8306      dc.l    $00000200               ; atnh(2^-21)
0000BE00= 00000100                8307      dc.l    $00000100               ; atnh(2^-22)
0000BE04= 00000080                8308      dc.l    $00000080               ; atnh(2^-23)
0000BE08= 00000040                8309      dc.l    $00000040               ; atnh(2^-24)
0000BE0C= 00000020                8310      dc.l    $00000020               ; atnh(2^-25)
0000BE10= 00000010                8311      dc.l    $00000010               ; atnh(2^-26)
0000BE14= 00000008                8312      dc.l    $00000008               ; atnh(2^-27)
0000BE18= 00000004                8313      dc.l    $00000004               ; atnh(2^-28)
0000BE1C= 00000002                8314      dc.l    $00000002               ; atnh(2^-29)
0000BE20= 00000001                8315      dc.l    $00000001               ; atnh(2^-30)
0000BE24= 00000000                8316      dc.l    $00000000               ; atnh(2^-31)
0000BE28= 00000000                8317      dc.l    $00000000               ; atnh(2^-32)
0000BE2C  =26A3D110               8318  KFCTSEED    equ $26A3D110           ; $26A3D110
0000BE2C                          8319  
0000BE2C                          8320  
0000BE2C                          8321  ;************************************************************************************
0000BE2C                          8322  ;
0000BE2C                          8323  ; command vector table
0000BE2C                          8324  
0000BE2C                          8325  LAB_CTBL
0000BE2C= D7A0                    8326      dc.w    LAB_END-LAB_CTBL                ; END
0000BE2E= D6D4                    8327      dc.w    LAB_FOR-LAB_CTBL                ; FOR
0000BE30= DD48                    8328      dc.w    LAB_NEXT-LAB_CTBL               ; NEXT
0000BE32= D8F4                    8329      dc.w    LAB_DATA-LAB_CTBL               ; DATA
0000BE34= DC3C                    8330      dc.w    LAB_INPUT-LAB_CTBL          ; INPUT
0000BE36= E11A                    8331      dc.w    LAB_DIM-LAB_CTBL                ; DIM
0000BE38= DC62                    8332      dc.w    LAB_READ-LAB_CTBL               ; READ
0000BE3A= DA6C                    8333      dc.w    LAB_LET-LAB_CTBL                ; LET
0000BE3C= DA08                    8334      dc.w    LAB_DEC-LAB_CTBL                ; DEC   
0000BE3E= D85C                    8335      dc.w    LAB_GOTO-LAB_CTBL               ; GOTO
0000BE40= D824                    8336      dc.w    LAB_RUN-LAB_CTBL                ; RUN
0000BE42= D91C                    8337      dc.w    LAB_IF-LAB_CTBL             ; IF
0000BE44= D7CE                    8338      dc.w    LAB_RESTORE-LAB_CTBL            ; RESTORE
0000BE46= D84A                    8339      dc.w    LAB_GOSUB-LAB_CTBL          ; GOSUB
0000BE48= D8E0                    8340      dc.w    LAB_RETURN-LAB_CTBL         ; RETURN
0000BE4A= D98E                    8341      dc.w    LAB_REM-LAB_CTBL                ; REM
0000BE4C= D7A8                    8342      dc.w    LAB_STOP-LAB_CTBL               ; STOP
0000BE4E= D996                    8343      dc.w    LAB_ON-LAB_CTBL             ; ON
0000BE50= D7FC                    8344      dc.w    LAB_NULL-LAB_CTBL               ; NULL
0000BE52= DA0E                    8345      dc.w    LAB_INC-LAB_CTBL                ; INC   
0000BE54= EA22                    8346      dc.w    LAB_WAIT-LAB_CTBL               ; WAIT
0000BE56= EA10                    8347      dc.w    LAB_LOAD-LAB_CTBL               ; LOAD
0000BE58= EA14                    8348      dc.w    LAB_SAVE-LAB_CTBL               ; SAVE
0000BE5A= E4AA                    8349      dc.w    LAB_DEF-LAB_CTBL                ; DEF
0000BE5C= E990                    8350      dc.w    LAB_POKE-LAB_CTBL               ; POKE
0000BE5E= E9C0                    8351      dc.w    LAB_DOKE-LAB_CTBL               ; DOKE
0000BE60= E9C6                    8352      dc.w    LAB_LOKE-LAB_CTBL               ; LOKE
0000BE62= EA18                    8353      dc.w    LAB_CALL-LAB_CTBL               ; CALL
0000BE64= D838                    8354      dc.w    LAB_DO-LAB_CTBL             ; DO    
0000BE66= D88A                    8355      dc.w    LAB_LOOP-LAB_CTBL               ; LOOP
0000BE68= DB00                    8356      dc.w    LAB_PRINT-LAB_CTBL          ; PRINT
0000BE6A= D806                    8357      dc.w    LAB_CONT-LAB_CTBL               ; CONT
0000BE6C= D61E                    8358      dc.w    LAB_LIST-LAB_CTBL               ; LIST
0000BE6E= D61A                    8359      dc.w    LAB_CLEAR-LAB_CTBL          ; CLEAR
0000BE70= D5C8                    8360      dc.w    LAB_NEW-LAB_CTBL                ; NEW
0000BE72= F954                    8361      dc.w    LAB_WDTH-LAB_CTBL               ; WIDTH
0000BE74= DAC6                    8362      dc.w    LAB_GET-LAB_CTBL                ; GET
0000BE76= E9DA                    8363      dc.w    LAB_SWAP-LAB_CTBL               ; SWAP
0000BE78= F49E                    8364      dc.w    LAB_BITSET-LAB_CTBL         ; BITSET
0000BE7A= F4AE                    8365      dc.w    LAB_BITCLR-LAB_CTBL         ; BITCLR
0000BE7C                          8366  
0000BE7C                          8367  
0000BE7C                          8368  ;************************************************************************************
0000BE7C                          8369  ;
0000BE7C                          8370  ; function pre process routine table
0000BE7C                          8371  
0000BE7C                          8372  LAB_FTPP
0000BE7C= DFC8                    8373      dc.w    LAB_PPFN-LAB_FTPP               ; SGN(n)    process numeric expression in ()
0000BE7E= DFC8                    8374      dc.w    LAB_PPFN-LAB_FTPP               ; INT(n)        "
0000BE80= DFC8                    8375      dc.w    LAB_PPFN-LAB_FTPP               ; ABS(n)        "
0000BE82= DDC8                    8376      dc.w    LAB_EVEZ-LAB_FTPP               ; USR(x)    process any expression
0000BE84= DF10                    8377      dc.w    LAB_1BF7-LAB_FTPP               ; FRE(x)    process any expression in ()
0000BE86= DF10                    8378      dc.w    LAB_1BF7-LAB_FTPP               ; POS(x)        "
0000BE88= DFC8                    8379      dc.w    LAB_PPFN-LAB_FTPP               ; SQR(n)    process numeric expression in ()
0000BE8A= DFC8                    8380      dc.w    LAB_PPFN-LAB_FTPP               ; RND(n)        "
0000BE8C= DFC8                    8381      dc.w    LAB_PPFN-LAB_FTPP               ; LOG(n)        "
0000BE8E= DFC8                    8382      dc.w    LAB_PPFN-LAB_FTPP               ; EXP(n)        "
0000BE90= DFC8                    8383      dc.w    LAB_PPFN-LAB_FTPP               ; COS(n)        "
0000BE92= DFC8                    8384      dc.w    LAB_PPFN-LAB_FTPP               ; SIN(n)        "
0000BE94= DFC8                    8385      dc.w    LAB_PPFN-LAB_FTPP               ; TAN(n)        "
0000BE96= DFC8                    8386      dc.w    LAB_PPFN-LAB_FTPP               ; ATN(n)        "
0000BE98= DFC8                    8387      dc.w    LAB_PPFN-LAB_FTPP               ; PEEK(n)       "
0000BE9A= DFC8                    8388      dc.w    LAB_PPFN-LAB_FTPP               ; DEEK(n)       "
0000BE9C= DFC8                    8389      dc.w    LAB_PPFN-LAB_FTPP               ; LEEK(n)       "
0000BE9E= DFBA                    8390      dc.w    LAB_PPFS-LAB_FTPP               ; LEN($)    process string expression in ()
0000BEA0= DFC8                    8391      dc.w    LAB_PPFN-LAB_FTPP               ; STR$(n)   process numeric expression in ()
0000BEA2= DFBA                    8392      dc.w    LAB_PPFS-LAB_FTPP               ; VAL($)    process string expression in ()
0000BEA4= DFBA                    8393      dc.w    LAB_PPFS-LAB_FTPP               ; ASC($)        "
0000BEA6= DFBA                    8394      dc.w    LAB_PPFS-LAB_FTPP               ; UCASE$($)     "
0000BEA8= DFBA                    8395      dc.w    LAB_PPFS-LAB_FTPP               ; LCASE$($)     "
0000BEAA= DFC8                    8396      dc.w    LAB_PPFN-LAB_FTPP               ; CHR$(n)   process numeric expression in ()
0000BEAC= E002                    8397      dc.w    LAB_BHSS-LAB_FTPP               ; HEX$()    bin/hex pre process
0000BEAE= E002                    8398      dc.w    LAB_BHSS-LAB_FTPP               ; BIN$()        "
0000BEB0= 0000                    8399      dc.w    $0000                       ; BITTST()  none
0000BEB2= 0000                    8400      dc.w    $0000                       ; MAX()     "
0000BEB4= 0000                    8401      dc.w    $0000                       ; MIN()     "
0000BEB6= DFD6                    8402      dc.w    LAB_PPBI-LAB_FTPP               ; RAMBASE   advance pointer
0000BEB8= DFD6                    8403      dc.w    LAB_PPBI-LAB_FTPP               ; PI            "
0000BEBA= DFD6                    8404      dc.w    LAB_PPBI-LAB_FTPP               ; TWOPI     "
0000BEBC= 0000                    8405      dc.w    $0000                       ; VARPTR()  none
0000BEBE= 0000                    8406      dc.w    $0000                       ; SADD()        "
0000BEC0= DFE0                    8407      dc.w    LAB_LRMS-LAB_FTPP               ; LEFT$()   process string expression
0000BEC2= DFE0                    8408      dc.w    LAB_LRMS-LAB_FTPP               ; RIGHT$()      "
0000BEC4= DFE0                    8409      dc.w    LAB_LRMS-LAB_FTPP               ; MID$()        "
0000BEC6= DDC8                    8410      dc.w    LAB_EVEZ-LAB_FTPP               ; USING$(x) process any expression
0000BEC8                          8411  
0000BEC8                          8412  
0000BEC8                          8413  ;************************************************************************************
0000BEC8                          8414  ;
0000BEC8                          8415  ; action addresses for functions
0000BEC8                          8416  
0000BEC8                          8417  LAB_FTBL
0000BEC8= ED4E                    8418      dc.w    LAB_SGN-LAB_FTBL                ; SGN()
0000BECA= EDD2                    8419      dc.w    LAB_INT-LAB_FTBL                ; INT()
0000BECC= ED60                    8420      dc.w    LAB_ABS-LAB_FTBL                ; ABS()
0000BECE= E96C                    8421      dc.w    LAB_USR-LAB_FTBL                ; USR()
0000BED0= E3C6                    8422      dc.w    LAB_FRE-LAB_FTBL                ; FRE()
0000BED2= E3F8                    8423      dc.w    LAB_POS-LAB_FTBL                ; POS()
0000BED4= F938                    8424      dc.w    LAB_SQR-LAB_FTBL                ; SQR()
0000BED6= F21C                    8425      dc.w    LAB_RND-LAB_FTBL                ; RND()
0000BED8= EA70                    8426      dc.w    LAB_LOG-LAB_FTBL                ; LOG()
0000BEDA= F102                    8427      dc.w    LAB_EXP-LAB_FTBL                ; EXP()
0000BEDC= F270                    8428      dc.w    LAB_COS-LAB_FTBL                ; COS()
0000BEDE= F288                    8429      dc.w    LAB_SIN-LAB_FTBL                ; SIN()
0000BEE0= F24E                    8430      dc.w    LAB_TAN-LAB_FTBL                ; TAN()
0000BEE2= F34E                    8431      dc.w    LAB_ATN-LAB_FTBL                ; ATN()
0000BEE4= E8E8                    8432      dc.w    LAB_PEEK-LAB_FTBL               ; PEEK()
0000BEE6= E8FA                    8433      dc.w    LAB_DEEK-LAB_FTBL               ; DEEK()
0000BEE8= E910                    8434      dc.w    LAB_LEEK-LAB_FTBL               ; LEEK()
0000BEEA= E82A                    8435      dc.w    LAB_LENS-LAB_FTBL               ; LEN()
0000BEEC= E4EE                    8436      dc.w    LAB_STRS-LAB_FTBL               ; STR$()
0000BEEE= E870                    8437      dc.w    LAB_VAL-LAB_FTBL                ; VAL()
0000BEF0= E832                    8438      dc.w    LAB_ASC-LAB_FTBL                ; ASC()
0000BEF2= E7E0                    8439      dc.w    LAB_UCASE-LAB_FTBL          ; UCASE$()
0000BEF4= E7B0                    8440      dc.w    LAB_LCASE-LAB_FTBL          ; LCASE$()
0000BEF6= E718                    8441      dc.w    LAB_CHRS-LAB_FTBL               ; CHR$()
0000BEF8= F7DA                    8442      dc.w    LAB_HEXS-LAB_FTBL               ; HEX$()
0000BEFA= F788                    8443      dc.w    LAB_BINS-LAB_FTBL               ; BIN$()
0000BEFC= F422                    8444      dc.w    LAB_BTST-LAB_FTBL               ; BITTST()
0000BEFE= F846                    8445      dc.w    LAB_MAX-LAB_FTBL                ; MAX()
0000BF00= F85C                    8446      dc.w    LAB_MIN-LAB_FTBL                ; MIN()
0000BF02= F9AA                    8447      dc.w    LAB_RAM-LAB_FTBL                ; RAMBASE
0000BF04= F9B4                    8448      dc.w    LAB_PI-LAB_FTBL             ; PI
0000BF06= F9C4                    8449      dc.w    LAB_TWOPI-LAB_FTBL          ; TWOPI
0000BF08= F99A                    8450      dc.w    LAB_VARPTR-LAB_FTBL         ; VARPTR()
0000BF0A= E812                    8451      dc.w    LAB_SADD-LAB_FTBL               ; SADD()
0000BF0C= E728                    8452      dc.w    LAB_LEFT-LAB_FTBL               ; LEFT$()
0000BF0E= E73C                    8453      dc.w    LAB_RIGHT-LAB_FTBL          ; RIGHT$()
0000BF10= E76C                    8454      dc.w    LAB_MIDS-LAB_FTBL               ; MID$()
0000BF12= F450                    8455      dc.w    LAB_USINGS-LAB_FTBL         ; USING$()
0000BF14                          8456  
0000BF14                          8457  
0000BF14                          8458  ;************************************************************************************
0000BF14                          8459  ;
0000BF14                          8460  ; hierarchy and action addresses for operator
0000BF14                          8461  
0000BF14                          8462  LAB_OPPT
0000BF14= 0079                    8463      dc.w    $0079                       ; +
0000BF16= E972                    8464      dc.w    LAB_ADD-LAB_OPPT
0000BF18= 0079                    8465      dc.w    $0079                       ; -
0000BF1A= E95E                    8466      dc.w    LAB_SUBTRACT-LAB_OPPT
0000BF1C= 007B                    8467      dc.w    $007B                       ; *
0000BF1E= EB16                    8468      dc.w    LAB_MULTIPLY-LAB_OPPT
0000BF20= 007B                    8469      dc.w    $007B                       ; /
0000BF22= EBA2                    8470      dc.w    LAB_DIVIDE-LAB_OPPT
0000BF24= 007F                    8471      dc.w    $007F                       ; ^
0000BF26= F000                    8472      dc.w    LAB_POWER-LAB_OPPT
0000BF28= 0050                    8473      dc.w    $0050                       ; AND
0000BF2A= DFAA                    8474      dc.w    LAB_AND-LAB_OPPT
0000BF2C= 0046                    8475      dc.w    $0046                       ; EOR
0000BF2E= DF9A                    8476      dc.w    LAB_EOR-LAB_OPPT
0000BF30= 0046                    8477      dc.w    $0046                       ; OR
0000BF32= DFA2                    8478      dc.w    LAB_OR-LAB_OPPT
0000BF34= 0056                    8479      dc.w    $0056                       ; >>
0000BF36= E04E                    8480      dc.w    LAB_RSHIFT-LAB_OPPT
0000BF38= 0056                    8481      dc.w    $0056                       ; <<
0000BF3A= E03E                    8482      dc.w    LAB_LSHIFT-LAB_OPPT
0000BF3C= 007D                    8483      dc.w    $007D                       ; >
0000BF3E= F064                    8484      dc.w    LAB_GTHAN-LAB_OPPT          ; used to evaluate -n
0000BF40= 005A                    8485      dc.w    $005A                       ; =
0000BF42= DFC0                    8486      dc.w    LAB_EQUAL-LAB_OPPT          ; used to evaluate NOT
0000BF44= 0064                    8487      dc.w    $0064                       ; <
0000BF46= DFCA                    8488      dc.w    LAB_LTHAN-LAB_OPPT
0000BF48                          8489  
0000BF48                          8490  
0000BF48                          8491  ;************************************************************************************
0000BF48                          8492  ;
0000BF48                          8493  ; misc constants
0000BF48                          8494  
0000BF48                          8495  ; This table is used in converting numbers to ASCII.
0000BF48                          8496  ; first four entries for expansion to 9.25 digits
0000BF48                          8497  
0000BF48                          8498  LAB_2A9A
0000BF48= FFF0BDC0                8499      dc.l    $FFF0BDC0                   ; -1000000
0000BF4C= 000186A0                8500      dc.l    $000186A0                   ; 100000
0000BF50= FFFFD8F0                8501      dc.l    $FFFFD8F0                   ; -10000
0000BF54= 000003E8                8502      dc.l    $000003E8                   ; 1000
0000BF58= FFFFFF9C                8503      dc.l    $FFFFFF9C                   ; -100
0000BF5C= 0000000A                8504      dc.l    $0000000A                   ; 10
0000BF60= FFFFFFFF                8505      dc.l    $FFFFFFFF                   ; -1
0000BF64                          8506  LAB_2A9B
0000BF64                          8507  
0000BF64                          8508  
0000BF64                          8509  ;************************************************************************************
0000BF64                          8510  ;
0000BF64                          8511  ; new keyword tables
0000BF64                          8512  
0000BF64                          8513  ; offsets to keyword tables
0000BF64                          8514  
0000BF64                          8515  TAB_CHRT
0000BF64= 0000                    8516      dc.w    TAB_STAR-TAB_STAR               ; "*"   $2A
0000BF66= 0002                    8517      dc.w    TAB_PLUS-TAB_STAR               ; "+"   $2B
0000BF68= FFFF                    8518      dc.w    -1                      ; "," $2C no keywords
0000BF6A= 0004                    8519      dc.w    TAB_MNUS-TAB_STAR               ; "-"   $2D
0000BF6C= FFFF                    8520      dc.w    -1                      ; "." $2E no keywords
0000BF6E= 0006                    8521      dc.w    TAB_SLAS-TAB_STAR               ; "/"   $2F
0000BF70= FFFF                    8522      dc.w    -1                      ; "0" $30 no keywords
0000BF72= FFFF                    8523      dc.w    -1                      ; "1" $31 no keywords
0000BF74= FFFF                    8524      dc.w    -1                      ; "2" $32 no keywords
0000BF76= FFFF                    8525      dc.w    -1                      ; "3" $33 no keywords
0000BF78= FFFF                    8526      dc.w    -1                      ; "4" $34 no keywords
0000BF7A= FFFF                    8527      dc.w    -1                      ; "5" $35 no keywords
0000BF7C= FFFF                    8528      dc.w    -1                      ; "6" $36 no keywords
0000BF7E= FFFF                    8529      dc.w    -1                      ; "7" $37 no keywords
0000BF80= FFFF                    8530      dc.w    -1                      ; "8" $38 no keywords
0000BF82= FFFF                    8531      dc.w    -1                      ; "9" $39 no keywords
0000BF84= FFFF                    8532      dc.w    -1                      ; ";" $3A no keywords
0000BF86= FFFF                    8533      dc.w    -1                      ; ":" $3B no keywords
0000BF88= 0008                    8534      dc.w    TAB_LESS-TAB_STAR               ; "<"   $3C
0000BF8A= 000C                    8535      dc.w    TAB_EQUL-TAB_STAR               ; "="   $3D
0000BF8C= 000E                    8536      dc.w    TAB_MORE-TAB_STAR               ; ">"   $3E
0000BF8E= 0012                    8537      dc.w    TAB_QEST-TAB_STAR               ; "?"   $3F
0000BF90= FFFF                    8538      dc.w    -1                      ; "@" $40 no keywords
0000BF92= 0014                    8539      dc.w    TAB_ASCA-TAB_STAR               ; "A"   $41
0000BF94= 0024                    8540      dc.w    TAB_ASCB-TAB_STAR               ; "B"   $42
0000BF96= 003D                    8541      dc.w    TAB_ASCC-TAB_STAR               ; "C"   $43
0000BF98= 0054                    8542      dc.w    TAB_ASCD-TAB_STAR               ; "D"   $44
0000BF9A= 006D                    8543      dc.w    TAB_ASCE-TAB_STAR               ; "E"   $45
0000BF9C= 007C                    8544      dc.w    TAB_ASCF-TAB_STAR               ; "F"   $46
0000BF9E= 0086                    8545      dc.w    TAB_ASCG-TAB_STAR               ; "G"   $47
0000BFA0= 0093                    8546      dc.w    TAB_ASCH-TAB_STAR               ; "H"   $48
0000BFA2= 0099                    8547      dc.w    TAB_ASCI-TAB_STAR               ; "I"   $49
0000BFA4= FFFF                    8548      dc.w    -1                      ; "J" $4A no keywords
0000BFA6= FFFF                    8549      dc.w    -1                      ; "K" $4B no keywords
0000BFA8= 00A8                    8550      dc.w    TAB_ASCL-TAB_STAR               ; "L"   $4C
0000BFAA= 00D6                    8551      dc.w    TAB_ASCM-TAB_STAR               ; "M"   $4D
0000BFAC= 00E4                    8552      dc.w    TAB_ASCN-TAB_STAR               ; "N"   $4E
0000BFAE= 00F3                    8553      dc.w    TAB_ASCO-TAB_STAR               ; "O"   $4F
0000BFB0= 00F8                    8554      dc.w    TAB_ASCP-TAB_STAR               ; "P"   $50
0000BFB2= FFFF                    8555      dc.w    -1                      ; "Q" $51 no keywords
0000BFB4= 010D                    8556      dc.w    TAB_ASCR-TAB_STAR               ; "R"   $52
0000BFB6= 0137                    8557      dc.w    TAB_ASCS-TAB_STAR               ; "S"   $53
0000BFB8= 0162                    8558      dc.w    TAB_ASCT-TAB_STAR               ; "T"   $54
0000BFBA= 0176                    8559      dc.w    TAB_ASCU-TAB_STAR               ; "U"   $55
0000BFBC= 018E                    8560      dc.w    TAB_ASCV-TAB_STAR               ; "V"   $56
0000BFBE= 019A                    8561      dc.w    TAB_ASCW-TAB_STAR               ; "W"   $57
0000BFC0= FFFF                    8562      dc.w    -1                      ; "X" $58 no keywords
0000BFC2= FFFF                    8563      dc.w    -1                      ; "Y" $59 no keywords
0000BFC4= FFFF                    8564      dc.w    -1                      ; "Z" $5A no keywords
0000BFC6= FFFF                    8565      dc.w    -1                      ; "[" $5B no keywords
0000BFC8= FFFF                    8566      dc.w    -1                      ; "\" $5C no keywords
0000BFCA= FFFF                    8567      dc.w    -1                      ; "]" $5D no keywords
0000BFCC= 01A9                    8568      dc.w    TAB_POWR-TAB_STAR               ; "^"   $5E
0000BFCE                          8569  
0000BFCE                          8570  
0000BFCE                          8571  ;************************************************************************************
0000BFCE                          8572  ;
0000BFCE                          8573  ; Table of Basic keywords for LIST command
0000BFCE                          8574  ; [byte]first character,[byte]remaining length -1
0000BFCE                          8575  ; [word]offset from table start
0000BFCE                          8576  
0000BFCE                          8577  LAB_KEYT
0000BFCE= 45 01                   8578      dc.b    'E',1
0000BFD0= 0071                    8579      dc.w    KEY_END-TAB_STAR                ; END
0000BFD2= 46 01                   8580      dc.b    'F',1
0000BFD4= 007C                    8581      dc.w    KEY_FOR-TAB_STAR                ; FOR
0000BFD6= 4E 02                   8582      dc.b    'N',2
0000BFD8= 00E7                    8583      dc.w    KEY_NEXT-TAB_STAR               ; NEXT
0000BFDA= 44 02                   8584      dc.b    'D',2
0000BFDC= 0054                    8585      dc.w    KEY_DATA-TAB_STAR               ; DATA
0000BFDE= 49 03                   8586      dc.b    'I',3
0000BFE0= 009E                    8587      dc.w    KEY_INPUT-TAB_STAR          ; INPUT
0000BFE2= 44 01                   8588      dc.b    'D',1
0000BFE4= 0063                    8589      dc.w    KEY_DIM-TAB_STAR                ; DIM
0000BFE6= 52 02                   8590      dc.b    'R',2
0000BFE8= 0114                    8591      dc.w    KEY_READ-TAB_STAR               ; READ
0000BFEA= 4C 01                   8592      dc.b    'L',1
0000BFEC= 00BE                    8593      dc.w    KEY_LET-TAB_STAR                ; LET
0000BFEE= 44 01                   8594      dc.b    'D',1
0000BFF0= 0058                    8595      dc.w    KEY_DEC-TAB_STAR                ; DEC
0000BFF2= 47 02                   8596      dc.b    'G',2
0000BFF4= 0089                    8597      dc.w    KEY_GOTO-TAB_STAR               ; GOTO
0000BFF6= 52 01                   8598      dc.b    'R',1
0000BFF8= 0133                    8599      dc.w    KEY_RUN-TAB_STAR                ; RUN
0000BFFA= 49 00                   8600      dc.b    'I',0
0000BFFC= 0099                    8601      dc.w    KEY_IF-TAB_STAR             ; IF
0000BFFE= 52 05                   8602      dc.b    'R',5
0000C000= 011B                    8603      dc.w    KEY_RESTORE-TAB_STAR            ; RESTORE
0000C002= 47 03                   8604      dc.b    'G',3
0000C004= 008D                    8605      dc.w    KEY_GOSUB-TAB_STAR          ; GOSUB
0000C006= 52 04                   8606      dc.b    'R',4
0000C008= 0122                    8607      dc.w    KEY_RETURN-TAB_STAR         ; RETURN
0000C00A= 52 01                   8608      dc.b    'R',1
0000C00C= 0118                    8609      dc.w    KEY_REM-TAB_STAR                ; REM
0000C00E= 53 02                   8610      dc.b    'S',2
0000C010= 0154                    8611      dc.w    KEY_STOP-TAB_STAR               ; STOP
0000C012= 4F 00                   8612      dc.b    'O',0
0000C014= 00F3                    8613      dc.w    KEY_ON-TAB_STAR             ; ON
0000C016= 4E 02                   8614      dc.b    'N',2
0000C018= 00EE                    8615      dc.w    KEY_NULL-TAB_STAR               ; NULL
0000C01A= 49 01                   8616      dc.b    'I',1
0000C01C= 009B                    8617      dc.w    KEY_INC-TAB_STAR                ; INC
0000C01E= 57 02                   8618      dc.b    'W',2
0000C020= 019A                    8619      dc.w    KEY_WAIT-TAB_STAR               ; WAIT
0000C022= 4C 02                   8620      dc.b    'L',2
0000C024= 00C5                    8621      dc.w    KEY_LOAD-TAB_STAR               ; LOAD
0000C026= 53 02                   8622      dc.b    'S',2
0000C028= 013C                    8623      dc.w    KEY_SAVE-TAB_STAR               ; SAVE
0000C02A= 44 01                   8624      dc.b    'D',1
0000C02C= 0060                    8625      dc.w    KEY_DEF-TAB_STAR                ; DEF
0000C02E= 50 02                   8626      dc.b    'P',2
0000C030= 00FF                    8627      dc.w    KEY_POKE-TAB_STAR               ; POKE
0000C032= 44 02                   8628      dc.b    'D',2
0000C034= 0066                    8629      dc.w    KEY_DOKE-TAB_STAR               ; DOKE
0000C036= 4C 02                   8630      dc.b    'L',2
0000C038= 00CD                    8631      dc.w    KEY_LOKE-TAB_STAR               ; LOKE
0000C03A= 43 02                   8632      dc.b    'C',2
0000C03C= 003D                    8633      dc.w    KEY_CALL-TAB_STAR               ; CALL
0000C03E= 44 00                   8634      dc.b    'D',0
0000C040= 006A                    8635      dc.w    KEY_DO-TAB_STAR             ; DO
0000C042= 4C 02                   8636      dc.b    'L',2
0000C044= 00D1                    8637      dc.w    KEY_LOOP-TAB_STAR               ; LOOP
0000C046= 50 03                   8638      dc.b    'P',3
0000C048= 0107                    8639      dc.w    KEY_PRINT-TAB_STAR          ; PRINT
0000C04A= 43 02                   8640      dc.b    'C',2
0000C04C= 004B                    8641      dc.w    KEY_CONT-TAB_STAR               ; CONT
0000C04E= 4C 02                   8642      dc.b    'L',2
0000C050= 00C1                    8643      dc.w    KEY_LIST-TAB_STAR               ; LIST
0000C052= 43 03                   8644      dc.b    'C',3
0000C054= 0046                    8645      dc.w    KEY_CLEAR-TAB_STAR          ; CLEAR
0000C056= 4E 01                   8646      dc.b    'N',1
0000C058= 00E4                    8647      dc.w    KEY_NEW-TAB_STAR                ; NEW
0000C05A= 57 03                   8648      dc.b    'W',3
0000C05C= 01A3                    8649      dc.w    KEY_WIDTH-TAB_STAR          ; WIDTH
0000C05E= 47 01                   8650      dc.b    'G',1
0000C060= 0086                    8651      dc.w    KEY_GET-TAB_STAR                ; GET
0000C062= 53 02                   8652      dc.b    'S',2
0000C064= 015D                    8653      dc.w    KEY_SWAP-TAB_STAR               ; SWAP
0000C066= 42 04                   8654      dc.b    'B',4
0000C068= 002F                    8655      dc.w    KEY_BITSET-TAB_STAR         ; BITSET
0000C06A= 42 04                   8656      dc.b    'B',4
0000C06C= 0029                    8657      dc.w    KEY_BITCLR-TAB_STAR         ; BITCLR
0000C06E= 54 02                   8658      dc.b    'T',2
0000C070= 0162                    8659      dc.w    KEY_TAB-TAB_STAR                ; TAB(
0000C072= 45 02                   8660      dc.b    'E',2
0000C074= 006D                    8661      dc.w    KEY_ELSE-TAB_STAR               ; ELSE
0000C076= 54 00                   8662      dc.b    'T',0
0000C078= 016E                    8663      dc.w    KEY_TO-TAB_STAR             ; TO
0000C07A= 46 00                   8664      dc.b    'F',0
0000C07C= 007F                    8665      dc.w    KEY_FN-TAB_STAR             ; FN
0000C07E= 53 02                   8666      dc.b    'S',2
0000C080= 0148                    8667      dc.w    KEY_SPC-TAB_STAR                ; SPC(
0000C082= 54 02                   8668      dc.b    'T',2
0000C084= 016A                    8669      dc.w    KEY_THEN-TAB_STAR               ; THEN
0000C086= 4E 01                   8670      dc.b    'N',1
0000C088= 00EB                    8671      dc.w    KEY_NOT-TAB_STAR                ; NOT
0000C08A= 53 02                   8672      dc.b    'S',2
0000C08C= 0150                    8673      dc.w    KEY_STEP-TAB_STAR               ; STEP
0000C08E= 55 03                   8674      dc.b    'U',3
0000C090= 017D                    8675      dc.w    KEY_UNTIL-TAB_STAR          ; UNTIL
0000C092= 57 03                   8676      dc.b    'W',3
0000C094= 019E                    8677      dc.w    KEY_WHILE-TAB_STAR          ; WHILE
0000C096                          8678  
0000C096= 2B FF                   8679      dc.b    '+',-1
0000C098= 0002                    8680      dc.w    KEY_PLUS-TAB_STAR               ; +
0000C09A= 2D FF                   8681      dc.b    '-',-1
0000C09C= 0004                    8682      dc.w    KEY_MINUS-TAB_STAR          ; -
0000C09E= 2A FF                   8683      dc.b    '*',-1
0000C0A0= 0000                    8684      dc.w    KEY_MULT-TAB_STAR               ; *
0000C0A2= 2F FF                   8685      dc.b    '/',-1
0000C0A4= 0006                    8686      dc.w    KEY_DIV-TAB_STAR                ; /
0000C0A6= 5E FF                   8687      dc.b    '^',-1
0000C0A8= 01A9                    8688      dc.w    KEY_POWER-TAB_STAR          ; ^
0000C0AA= 41 01                   8689      dc.b    'A',1
0000C0AC= 0018                    8690      dc.w    KEY_AND-TAB_STAR                ; AND
0000C0AE= 45 01                   8691      dc.b    'E',1
0000C0B0= 0074                    8692      dc.w    KEY_EOR-TAB_STAR                ; EOR
0000C0B2= 4F 00                   8693      dc.b    'O',0
0000C0B4= 00F5                    8694      dc.w    KEY_OR-TAB_STAR             ; OR
0000C0B6= 3E 00                   8695      dc.b    '>',0
0000C0B8= 000E                    8696      dc.w    KEY_RSHIFT-TAB_STAR         ; >>
0000C0BA= 3C 00                   8697      dc.b    '<',0
0000C0BC= 0008                    8698      dc.w    KEY_LSHIFT-TAB_STAR         ; <<
0000C0BE= 3E FF                   8699      dc.b    '>',-1
0000C0C0= 0010                    8700      dc.w    KEY_GT-TAB_STAR             ; >
0000C0C2= 3D FF                   8701      dc.b    '=',-1
0000C0C4= 000C                    8702      dc.w    KEY_EQUAL-TAB_STAR          ; =
0000C0C6= 3C FF                   8703      dc.b    '<',-1
0000C0C8= 000A                    8704      dc.w    KEY_LT-TAB_STAR             ; <
0000C0CA                          8705  
0000C0CA= 53 02                   8706      dc.b    'S',2
0000C0CC= 0140                    8707      dc.w    KEY_SGN-TAB_STAR                ; SGN(
0000C0CE= 49 02                   8708      dc.b    'I',2
0000C0D0= 00A3                    8709      dc.w    KEY_INT-TAB_STAR                ; INT(
0000C0D2= 41 02                   8710      dc.b    'A',2
0000C0D4= 0014                    8711      dc.w    KEY_ABS-TAB_STAR                ; ABS(
0000C0D6= 55 02                   8712      dc.b    'U',2
0000C0D8= 0189                    8713      dc.w    KEY_USR-TAB_STAR                ; USR(
0000C0DA= 46 02                   8714      dc.b    'F',2
0000C0DC= 0081                    8715      dc.w    KEY_FRE-TAB_STAR                ; FRE(
0000C0DE= 50 02                   8716      dc.b    'P',2
0000C0E0= 0103                    8717      dc.w    KEY_POS-TAB_STAR                ; POS(
0000C0E2= 53 02                   8718      dc.b    'S',2
0000C0E4= 014C                    8719      dc.w    KEY_SQR-TAB_STAR                ; SQR(
0000C0E6= 52 02                   8720      dc.b    'R',2
0000C0E8= 012F                    8721      dc.w    KEY_RND-TAB_STAR                ; RND(
0000C0EA= 4C 02                   8722      dc.b    'L',2
0000C0EC= 00C9                    8723      dc.w    KEY_LOG-TAB_STAR                ; LOG(
0000C0EE= 45 02                   8724      dc.b    'E',2
0000C0F0= 0077                    8725      dc.w    KEY_EXP-TAB_STAR                ; EXP(
0000C0F2= 43 02                   8726      dc.b    'C',2
0000C0F4= 004F                    8727      dc.w    KEY_COS-TAB_STAR                ; COS(
0000C0F6= 53 02                   8728      dc.b    'S',2
0000C0F8= 0144                    8729      dc.w    KEY_SIN-TAB_STAR                ; SIN(
0000C0FA= 54 02                   8730      dc.b    'T',2
0000C0FC= 0166                    8731      dc.w    KEY_TAN-TAB_STAR                ; TAN(
0000C0FE= 41 02                   8732      dc.b    'A',2
0000C100= 001F                    8733      dc.w    KEY_ATN-TAB_STAR                ; ATN(
0000C102= 50 03                   8734      dc.b    'P',3
0000C104= 00F8                    8735      dc.w    KEY_PEEK-TAB_STAR               ; PEEK(
0000C106= 44 03                   8736      dc.b    'D',3
0000C108= 005B                    8737      dc.w    KEY_DEEK-TAB_STAR               ; DEEK(
0000C10A= 4C 03                   8738      dc.b    'L',3
0000C10C= 00AF                    8739      dc.w    KEY_LEEK-TAB_STAR               ; LEEK(
0000C10E= 4C 02                   8740      dc.b    'L',2
0000C110= 00BA                    8741      dc.w    KEY_LEN-TAB_STAR                ; LEN(
0000C112= 53 03                   8742      dc.b    'S',3
0000C114= 0158                    8743      dc.w    KEY_STRS-TAB_STAR               ; STR$(
0000C116= 56 02                   8744      dc.b    'V',2
0000C118= 018E                    8745      dc.w    KEY_VAL-TAB_STAR                ; VAL(
0000C11A= 41 02                   8746      dc.b    'A',2
0000C11C= 001B                    8747      dc.w    KEY_ASC-TAB_STAR                ; ASC(
0000C11E= 55 05                   8748      dc.b    'U',5
0000C120= 0176                    8749      dc.w    KEY_UCASES-TAB_STAR         ; UCASE$(
0000C122= 4C 05                   8750      dc.b    'L',5
0000C124= 00A8                    8751      dc.w    KEY_LCASES-TAB_STAR         ; LCASE$(
0000C126= 43 03                   8752      dc.b    'C',3
0000C128= 0041                    8753      dc.w    KEY_CHRS-TAB_STAR               ; CHR$(
0000C12A= 48 03                   8754      dc.b    'H',3
0000C12C= 0093                    8755      dc.w    KEY_HEXS-TAB_STAR               ; HEX$(
0000C12E= 42 03                   8756      dc.b    'B',3
0000C130= 0024                    8757      dc.w    KEY_BINS-TAB_STAR               ; BIN$(
0000C132= 42 05                   8758      dc.b    'B',5
0000C134= 0035                    8759      dc.w    KEY_BITTST-TAB_STAR         ; BITTST(
0000C136= 4D 02                   8760      dc.b    'M',2
0000C138= 00D6                    8761      dc.w    KEY_MAX-TAB_STAR                ; MAX(
0000C13A= 4D 02                   8762      dc.b    'M',2
0000C13C= 00DF                    8763      dc.w    KEY_MIN-TAB_STAR                ; MIN(
0000C13E= 52 05                   8764      dc.b    'R',5
0000C140= 010D                    8765      dc.w    KEY_RAM-TAB_STAR                ; RAMBASE
0000C142= 50 00                   8766      dc.b    'P',0
0000C144= 00FD                    8767      dc.w    KEY_PI-TAB_STAR             ; PI
0000C146= 54 03                   8768      dc.b    'T',3
0000C148= 0170                    8769      dc.w    KEY_TWOPI-TAB_STAR          ; TWOPI
0000C14A= 56 05                   8770      dc.b    'V',5
0000C14C= 0192                    8771      dc.w    KEY_VPTR-TAB_STAR               ; VARPTR(
0000C14E= 53 03                   8772      dc.b    'S',3
0000C150= 0137                    8773      dc.w    KEY_SADD-TAB_STAR               ; SADD(
0000C152= 4C 04                   8774      dc.b    'L',4
0000C154= 00B4                    8775      dc.w    KEY_LEFTS-TAB_STAR          ; LEFT$(
0000C156= 52 05                   8776      dc.b    'R',5
0000C158= 0128                    8777      dc.w    KEY_RIGHTS-TAB_STAR         ; RIGHT$(
0000C15A= 4D 03                   8778      dc.b    'M',3
0000C15C= 00DA                    8779      dc.w    KEY_MIDS-TAB_STAR               ; MID$(
0000C15E= 55 05                   8780      dc.b    'U',5
0000C160= 0182                    8781      dc.w    KEY_USINGS-TAB_STAR         ; USING$(
0000C162                          8782  
0000C162                          8783  
0000C162                          8784  ;************************************************************************************
0000C162                          8785  ;
0000C162                          8786  ; BASIC error messages
0000C162                          8787  
0000C162                          8788  LAB_BAER
0000C162= 0030                    8789      dc.w    LAB_NF-LAB_BAER             ; $00 NEXT without FOR
0000C164= 0041                    8790      dc.w    LAB_SN-LAB_BAER             ; $02 syntax
0000C166= 0048                    8791      dc.w    LAB_RG-LAB_BAER             ; $04 RETURN without GOSUB
0000C168= 005D                    8792      dc.w    LAB_OD-LAB_BAER             ; $06 out of data
0000C16A= 0069                    8793      dc.w    LAB_FC-LAB_BAER             ; $08 function call
0000C16C= 0077                    8794      dc.w    LAB_OV-LAB_BAER             ; $0A overflow
0000C16E= 0080                    8795      dc.w    LAB_OM-LAB_BAER             ; $0C out of memory
0000C170= 008E                    8796      dc.w    LAB_US-LAB_BAER             ; $0E undefined statement
0000C172= 00A2                    8797      dc.w    LAB_BS-LAB_BAER             ; $10 array bounds
0000C174= 00AF                    8798      dc.w    LAB_DD-LAB_BAER             ; $12 double dimension array
0000C176= 00C0                    8799      dc.w    LAB_D0-LAB_BAER             ; $14 divide by 0
0000C178= 00CF                    8800      dc.w    LAB_ID-LAB_BAER             ; $16 illegal direct
0000C17A= 00DE                    8801      dc.w    LAB_TM-LAB_BAER             ; $18 type mismatch
0000C17C= 00EC                    8802      dc.w    LAB_LS-LAB_BAER             ; $1A long string
0000C17E= 00FC                    8803      dc.w    LAB_ST-LAB_BAER             ; $1C string too complex
0000C180= 010F                    8804      dc.w    LAB_CN-LAB_BAER             ; $1E continue error
0000C182= 011E                    8805      dc.w    LAB_UF-LAB_BAER             ; $20 undefined function
0000C184= 0131                    8806      dc.w    LAB_LD-LAB_BAER             ; $22 LOOP without DO
0000C186= 0141                    8807      dc.w    LAB_UV-LAB_BAER             ; $24 undefined variable
0000C188= 0154                    8808      dc.w    LAB_UA-LAB_BAER             ; $26 undimensioned array
0000C18A= 0168                    8809      dc.w    LAB_WD-LAB_BAER             ; $28 wrong dimensions
0000C18C= 0179                    8810      dc.w    LAB_AD-LAB_BAER             ; $2A address
0000C18E= 0181                    8811      dc.w    LAB_FO-LAB_BAER             ; $2C format
0000C190= 0188                    8812      dc.w    LAB_NI-LAB_BAER             ; $2E not implemented
0000C192                          8813  
0000C192= 4E 45 58 54 20 77 ...   8814  LAB_NF  dc.b    'NEXT without FOR',$00
0000C1A3= 53 79 6E 74 61 78 00    8815  LAB_SN  dc.b    'Syntax',$00
0000C1AA= 52 45 54 55 52 4E ...   8816  LAB_RG  dc.b    'RETURN without GOSUB',$00
0000C1BF= 4F 75 74 20 6F 66 ...   8817  LAB_OD  dc.b    'Out of DATA',$00
0000C1CB= 46 75 6E 63 74 69 ...   8818  LAB_FC  dc.b    'Function call',$00
0000C1D9= 4F 76 65 72 66 6C ...   8819  LAB_OV  dc.b    'Overflow',$00
0000C1E2= 4F 75 74 20 6F 66 ...   8820  LAB_OM  dc.b    'Out of memory',$00
0000C1F0= 55 6E 64 65 66 69 ...   8821  LAB_US  dc.b    'Undefined statement',$00
0000C204= 41 72 72 61 79 20 ...   8822  LAB_BS  dc.b    'Array bounds',$00
0000C211= 44 6F 75 62 6C 65 ...   8823  LAB_DD  dc.b    'Double dimension',$00
0000C222= 44 69 76 69 64 65 ...   8824  LAB_D0  dc.b    'Divide by zero',$00
0000C231= 49 6C 6C 65 67 61 ...   8825  LAB_ID  dc.b    'Illegal direct',$00
0000C240= 54 79 70 65 20 6D ...   8826  LAB_TM  dc.b    'Type mismatch',$00
0000C24E= 53 74 72 69 6E 67 ...   8827  LAB_LS  dc.b    'String too long',$00
0000C25E= 53 74 72 69 6E 67 ...   8828  LAB_ST  dc.b    'String too complex',$00
0000C271= 43 61 6E 27 74 20 ...   8829  LAB_CN  dc.b    'Can''t continue',$00
0000C280= 55 6E 64 65 66 69 ...   8830  LAB_UF  dc.b    'Undefined function',$00
0000C293= 4C 4F 4F 50 20 77 ...   8831  LAB_LD  dc.b    'LOOP without DO',$00
0000C2A3= 55 6E 64 65 66 69 ...   8832  LAB_UV  dc.b    'Undefined variable',$00
0000C2B6= 55 6E 64 69 6D 65 ...   8833  LAB_UA  dc.b    'Undimensioned array',$00
0000C2CA= 57 72 6F 6E 67 20 ...   8834  LAB_WD  dc.b    'Wrong dimensions',$00
0000C2DB= 41 64 64 72 65 73 ...   8835  LAB_AD  dc.b    'Address',$00
0000C2E3= 46 6F 72 6D 61 74 00    8836  LAB_FO  dc.b    'Format',$00
0000C2EA= 4E 6F 74 20 69 6D ...   8837  LAB_NI  dc.b    'Not implemented',$00
0000C2FA                          8838  
0000C2FA                          8839  
0000C2FA                          8840  ;************************************************************************************
0000C2FA                          8841  ;
0000C2FA                          8842  ; keyword table for line (un)crunching
0000C2FA                          8843  
0000C2FA                          8844  ; [keyword,token
0000C2FA                          8845  ; [keyword,token]]
0000C2FA                          8846  ; end marker (#$00)
0000C2FA                          8847  
0000C2FA                          8848  TAB_STAR
0000C2FA                          8849  KEY_MULT
0000C2FA= B4 00                   8850      dc.b TK_MULT,$00                    ; *
0000C2FC                          8851  TAB_PLUS
0000C2FC                          8852  KEY_PLUS
0000C2FC= B2 00                   8853      dc.b TK_PLUS,$00                    ; +
0000C2FE                          8854  TAB_MNUS
0000C2FE                          8855  KEY_MINUS
0000C2FE= B3 00                   8856      dc.b TK_MINUS,$00                   ; -
0000C300                          8857  TAB_SLAS
0000C300                          8858  KEY_DIV
0000C300= B5 00                   8859      dc.b TK_DIV,$00                 ; /
0000C302                          8860  TAB_LESS
0000C302                          8861  KEY_LSHIFT
0000C302= 3C BB                   8862      dc.b    '<',TK_LSHIFT               ; <<
0000C304                          8863  KEY_LT
0000C304= BE                      8864      dc.b TK_LT                      ; <
0000C305= 00                      8865      dc.b    $00
0000C306                          8866  TAB_EQUL
0000C306                          8867  KEY_EQUAL
0000C306= BD 00                   8868      dc.b TK_EQUAL,$00                   ; =
0000C308                          8869  TAB_MORE
0000C308                          8870  KEY_RSHIFT
0000C308= 3E BA                   8871      dc.b    '>',TK_RSHIFT               ; >>
0000C30A                          8872  KEY_GT
0000C30A= BC                      8873      dc.b TK_GT                      ; >
0000C30B= 00                      8874      dc.b    $00
0000C30C                          8875  TAB_QEST
0000C30C= 9E 00                   8876      dc.b TK_PRINT,$00                   ; ?
0000C30E                          8877  TAB_ASCA
0000C30E                          8878  KEY_ABS
0000C30E= 42 53 28 C1             8879      dc.b    'BS(',TK_ABS                ; ABS(
0000C312                          8880  KEY_AND
0000C312= 4E 44 B7                8881      dc.b    'ND',TK_AND                 ; AND
0000C315                          8882  KEY_ASC
0000C315= 53 43 28 D3             8883      dc.b    'SC(',TK_ASC                ; ASC(
0000C319                          8884  KEY_ATN
0000C319= 54 4E 28 CC             8885      dc.b    'TN(',TK_ATN                ; ATN(
0000C31D= 00                      8886      dc.b    $00
0000C31E                          8887  TAB_ASCB
0000C31E                          8888  KEY_BINS
0000C31E= 49 4E 24 28 D8          8889      dc.b    'IN$(',TK_BINS              ; BIN$(
0000C323                          8890  KEY_BITCLR
0000C323= 49 54 43 4C 52 A7       8891      dc.b    'ITCLR',TK_BITCLR               ; BITCLR
0000C329                          8892  KEY_BITSET
0000C329= 49 54 53 45 54 A6       8893      dc.b    'ITSET',TK_BITSET               ; BITSET
0000C32F                          8894  KEY_BITTST
0000C32F= 49 54 54 53 54 28 D9    8895      dc.b    'ITTST(',TK_BITTST          ; BITTST(
0000C336= 00                      8896      dc.b    $00
0000C337                          8897  TAB_ASCC
0000C337                          8898  KEY_CALL
0000C337= 41 4C 4C 9B             8899      dc.b    'ALL',TK_CALL               ; CALL
0000C33B                          8900  KEY_CHRS
0000C33B= 48 52 24 28 D6          8901      dc.b    'HR$(',TK_CHRS              ; CHR$(
0000C340                          8902  KEY_CLEAR
0000C340= 4C 45 41 52 A1          8903      dc.b    'LEAR',TK_CLEAR             ; CLEAR
0000C345                          8904  KEY_CONT
0000C345= 4F 4E 54 9F             8905      dc.b    'ONT',TK_CONT               ; CONT
0000C349                          8906  KEY_COS
0000C349= 4F 53 28 C9             8907      dc.b    'OS(',TK_COS                ; COS(
0000C34D= 00                      8908      dc.b    $00
0000C34E                          8909  TAB_ASCD
0000C34E                          8910  KEY_DATA
0000C34E= 41 54 41 83             8911      dc.b    'ATA',TK_DATA               ; DATA
0000C352                          8912  KEY_DEC
0000C352= 45 43 88                8913      dc.b    'EC',TK_DEC                 ; DEC
0000C355                          8914  KEY_DEEK
0000C355= 45 45 4B 28 CE          8915      dc.b    'EEK(',TK_DEEK              ; DEEK(
0000C35A                          8916  KEY_DEF
0000C35A= 45 46 97                8917      dc.b    'EF',TK_DEF                 ; DEF
0000C35D                          8918  KEY_DIM
0000C35D= 49 4D 85                8919      dc.b    'IM',TK_DIM                 ; DIM
0000C360                          8920  KEY_DOKE
0000C360= 4F 4B 45 99             8921      dc.b    'OKE',TK_DOKE               ; DOKE
0000C364                          8922  KEY_DO
0000C364= 4F 9C                   8923      dc.b    'O',TK_DO                   ; DO
0000C366= 00                      8924      dc.b    $00
0000C367                          8925  TAB_ASCE
0000C367                          8926  KEY_ELSE
0000C367= 4C 53 45 A9             8927      dc.b    'LSE',TK_ELSE               ; ELSE
0000C36B                          8928  KEY_END
0000C36B= 4E 44 80                8929      dc.b    'ND',TK_END                 ; END
0000C36E                          8930  KEY_EOR
0000C36E= 4F 52 B8                8931      dc.b    'OR',TK_EOR                 ; EOR
0000C371                          8932  KEY_EXP
0000C371= 58 50 28 C8             8933      dc.b    'XP(',TK_EXP                ; EXP(
0000C375= 00                      8934      dc.b    $00
0000C376                          8935  TAB_ASCF
0000C376                          8936  KEY_FOR
0000C376= 4F 52 81                8937      dc.b    'OR',TK_FOR                 ; FOR
0000C379                          8938  KEY_FN
0000C379= 4E AB                   8939      dc.b    'N',TK_FN                   ; FN
0000C37B                          8940  KEY_FRE
0000C37B= 52 45 28 C3             8941      dc.b    'RE(',TK_FRE                ; FRE(
0000C37F= 00                      8942      dc.b    $00
0000C380                          8943  TAB_ASCG
0000C380                          8944  KEY_GET
0000C380= 45 54 A4                8945      dc.b    'ET',TK_GET                 ; GET
0000C383                          8946  KEY_GOTO
0000C383= 4F 54 4F 89             8947      dc.b    'OTO',TK_GOTO               ; GOTO
0000C387                          8948  KEY_GOSUB
0000C387= 4F 53 55 42 8D          8949      dc.b    'OSUB',TK_GOSUB             ; GOSUB
0000C38C= 00                      8950      dc.b    $00
0000C38D                          8951  TAB_ASCH
0000C38D                          8952  KEY_HEXS
0000C38D= 45 58 24 28 D7 00       8953      dc.b    'EX$(',TK_HEXS,$00          ; HEX$(
0000C393                          8954  TAB_ASCI
0000C393                          8955  KEY_IF
0000C393= 46 8B                   8956      dc.b    'F',TK_IF                   ; IF
0000C395                          8957  KEY_INC
0000C395= 4E 43 93                8958      dc.b    'NC',TK_INC                 ; INC
0000C398                          8959  KEY_INPUT
0000C398= 4E 50 55 54 84          8960      dc.b    'NPUT',TK_INPUT             ; INPUT
0000C39D                          8961  KEY_INT
0000C39D= 4E 54 28 C0             8962      dc.b    'NT(',TK_INT                ; INT(
0000C3A1= 00                      8963      dc.b    $00
0000C3A2                          8964  TAB_ASCL
0000C3A2                          8965  KEY_LCASES
0000C3A2= 43 41 53 45 24 28 D5    8966      dc.b    'CASE$(',TK_LCASES          ; LCASE$(
0000C3A9                          8967  KEY_LEEK
0000C3A9= 45 45 4B 28 CF          8968      dc.b    'EEK(',TK_LEEK              ; LEEK(
0000C3AE                          8969  KEY_LEFTS
0000C3AE= 45 46 54 24 28 E1       8970      dc.b    'EFT$(',TK_LEFTS                ; LEFT$(
0000C3B4                          8971  KEY_LEN
0000C3B4= 45 4E 28 D0             8972      dc.b    'EN(',TK_LEN                ; LEN(
0000C3B8                          8973  KEY_LET
0000C3B8= 45 54 87                8974      dc.b    'ET',TK_LET                 ; LET
0000C3BB                          8975  KEY_LIST
0000C3BB= 49 53 54 A0             8976      dc.b    'IST',TK_LIST               ; LIST
0000C3BF                          8977  KEY_LOAD
0000C3BF= 4F 41 44 95             8978      dc.b    'OAD',TK_LOAD               ; LOAD
0000C3C3                          8979  KEY_LOG
0000C3C3= 4F 47 28 C7             8980      dc.b    'OG(',TK_LOG                ; LOG(
0000C3C7                          8981  KEY_LOKE
0000C3C7= 4F 4B 45 9A             8982      dc.b    'OKE',TK_LOKE               ; LOKE
0000C3CB                          8983  KEY_LOOP
0000C3CB= 4F 4F 50 9D             8984      dc.b    'OOP',TK_LOOP               ; LOOP
0000C3CF= 00                      8985      dc.b    $00
0000C3D0                          8986  TAB_ASCM
0000C3D0                          8987  KEY_MAX
0000C3D0= 41 58 28 DA             8988      dc.b    'AX(',TK_MAX                ; MAX(
0000C3D4                          8989  KEY_MIDS
0000C3D4= 49 44 24 28 E3          8990      dc.b    'ID$(',TK_MIDS              ; MID$(
0000C3D9                          8991  KEY_MIN
0000C3D9= 49 4E 28 DB             8992      dc.b    'IN(',TK_MIN                ; MIN(
0000C3DD= 00                      8993      dc.b    $00
0000C3DE                          8994  TAB_ASCN
0000C3DE                          8995  KEY_NEW
0000C3DE= 45 57 A2                8996      dc.b    'EW',TK_NEW                 ; NEW
0000C3E1                          8997  KEY_NEXT
0000C3E1= 45 58 54 82             8998      dc.b    'EXT',TK_NEXT               ; NEXT
0000C3E5                          8999  KEY_NOT
0000C3E5= 4F 54 AE                9000      dc.b    'OT',TK_NOT                 ; NOT
0000C3E8                          9001  KEY_NULL
0000C3E8= 55 4C 4C 92             9002      dc.b    'ULL',TK_NULL               ; NULL
0000C3EC= 00                      9003      dc.b    $00
0000C3ED                          9004  TAB_ASCO
0000C3ED                          9005  KEY_ON
0000C3ED= 4E 91                   9006      dc.b    'N',TK_ON                   ; ON
0000C3EF                          9007  KEY_OR
0000C3EF= 52 B9                   9008      dc.b    'R',TK_OR                   ; OR
0000C3F1= 00                      9009      dc.b    $00
0000C3F2                          9010  TAB_ASCP
0000C3F2                          9011  KEY_PEEK
0000C3F2= 45 45 4B 28 CD          9012      dc.b    'EEK(',TK_PEEK              ; PEEK(
0000C3F7                          9013  KEY_PI
0000C3F7= 49 DD                   9014      dc.b    'I',TK_PI                   ; PI
0000C3F9                          9015  KEY_POKE
0000C3F9= 4F 4B 45 98             9016      dc.b    'OKE',TK_POKE               ; POKE
0000C3FD                          9017  KEY_POS
0000C3FD= 4F 53 28 C4             9018      dc.b    'OS(',TK_POS                ; POS(
0000C401                          9019  KEY_PRINT
0000C401= 52 49 4E 54 9E          9020      dc.b    'RINT',TK_PRINT             ; PRINT
0000C406= 00                      9021      dc.b    $00
0000C407                          9022  TAB_ASCR
0000C407                          9023  KEY_RAM
0000C407= 41 4D 42 41 53 45 DC    9024      dc.b    'AMBASE',TK_RAM             ; RAMBASE
0000C40E                          9025  KEY_READ
0000C40E= 45 41 44 86             9026      dc.b    'EAD',TK_READ               ; READ
0000C412                          9027  KEY_REM
0000C412= 45 4D 8F                9028      dc.b    'EM',TK_REM                 ; REM
0000C415                          9029  KEY_RESTORE
0000C415= 45 53 54 4F 52 45 8C    9030      dc.b    'ESTORE',TK_RESTORE         ; RESTORE
0000C41C                          9031  KEY_RETURN
0000C41C= 45 54 55 52 4E 8E       9032      dc.b    'ETURN',TK_RETURN               ; RETURN
0000C422                          9033  KEY_RIGHTS
0000C422= 49 47 48 54 24 28 E2    9034      dc.b    'IGHT$(',TK_RIGHTS          ; RIGHT$(
0000C429                          9035  KEY_RND
0000C429= 4E 44 28 C6             9036      dc.b    'ND(',TK_RND                ; RND(
0000C42D                          9037  KEY_RUN
0000C42D= 55 4E 8A                9038      dc.b    'UN',TK_RUN                 ; RUN
0000C430= 00                      9039      dc.b    $00
0000C431                          9040  TAB_ASCS
0000C431                          9041  KEY_SADD
0000C431= 41 44 44 28 E0          9042      dc.b    'ADD(',TK_SADD              ; SADD(
0000C436                          9043  KEY_SAVE
0000C436= 41 56 45 96             9044      dc.b    'AVE',TK_SAVE               ; SAVE
0000C43A                          9045  KEY_SGN
0000C43A= 47 4E 28 BF             9046      dc.b    'GN(',TK_SGN                ; SGN(
0000C43E                          9047  KEY_SIN
0000C43E= 49 4E 28 CA             9048      dc.b    'IN(',TK_SIN                ; SIN(
0000C442                          9049  KEY_SPC
0000C442= 50 43 28 AC             9050      dc.b    'PC(',TK_SPC                ; SPC(
0000C446                          9051  KEY_SQR
0000C446= 51 52 28 C5             9052      dc.b    'QR(',TK_SQR                ; SQR(
0000C44A                          9053  KEY_STEP
0000C44A= 54 45 50 AF             9054      dc.b    'TEP',TK_STEP               ; STEP
0000C44E                          9055  KEY_STOP
0000C44E= 54 4F 50 90             9056      dc.b    'TOP',TK_STOP               ; STOP
0000C452                          9057  KEY_STRS
0000C452= 54 52 24 28 D1          9058      dc.b    'TR$(',TK_STRS              ; STR$(
0000C457                          9059  KEY_SWAP
0000C457= 57 41 50 A5             9060      dc.b    'WAP',TK_SWAP               ; SWAP
0000C45B= 00                      9061      dc.b    $00
0000C45C                          9062  TAB_ASCT
0000C45C                          9063  KEY_TAB
0000C45C= 41 42 28 A8             9064      dc.b    'AB(',TK_TAB                ; TAB(
0000C460                          9065  KEY_TAN
0000C460= 41 4E 28 CB             9066      dc.b    'AN(',TK_TAN                ; TAN
0000C464                          9067  KEY_THEN
0000C464= 48 45 4E AD             9068      dc.b    'HEN',TK_THEN               ; THEN
0000C468                          9069  KEY_TO
0000C468= 4F AA                   9070      dc.b    'O',TK_TO                   ; TO
0000C46A                          9071  KEY_TWOPI
0000C46A= 57 4F 50 49 DE          9072      dc.b    'WOPI',TK_TWOPI             ; TWOPI
0000C46F= 00                      9073      dc.b    $00
0000C470                          9074  TAB_ASCU
0000C470                          9075  KEY_UCASES
0000C470= 43 41 53 45 24 28 D4    9076      dc.b    'CASE$(',TK_UCASES          ; UCASE$(
0000C477                          9077  KEY_UNTIL
0000C477= 4E 54 49 4C B0          9078      dc.b    'NTIL',TK_UNTIL             ; UNTIL
0000C47C                          9079  KEY_USINGS
0000C47C= 53 49 4E 47 24 28 E4    9080      dc.b    'SING$(',TK_USINGS          ; USING$(
0000C483                          9081  KEY_USR
0000C483= 53 52 28 C2             9082      dc.b    'SR(',TK_USR                ; USR(
0000C487= 00                      9083      dc.b    $00
0000C488                          9084  TAB_ASCV
0000C488                          9085  KEY_VAL
0000C488= 41 4C 28 D2             9086      dc.b    'AL(',TK_VAL                ; VAL(
0000C48C                          9087  KEY_VPTR
0000C48C= 41 52 50 54 52 28 DF    9088      dc.b    'ARPTR(',TK_VPTR                ; VARPTR(
0000C493= 00                      9089      dc.b    $00
0000C494                          9090  TAB_ASCW
0000C494                          9091  KEY_WAIT
0000C494= 41 49 54 94             9092      dc.b    'AIT',TK_WAIT               ; WAIT
0000C498                          9093  KEY_WHILE
0000C498= 48 49 4C 45 B1          9094      dc.b    'HILE',TK_WHILE             ; WHILE
0000C49D                          9095  KEY_WIDTH
0000C49D= 49 44 54 48 A3          9096      dc.b    'IDTH',TK_WIDTH             ; WIDTH
0000C4A2= 00                      9097      dc.b    $00
0000C4A3                          9098  TAB_POWR
0000C4A3                          9099  KEY_POWER
0000C4A3= B6 00                   9100      dc.b    TK_POWER,$00                ; ^
0000C4A5                          9101  
0000C4A5                          9102  
0000C4A5                          9103  ;************************************************************************************
0000C4A5                          9104  ;
0000C4A5                          9105  ; just messages
0000C4A5                          9106  
0000C4A5                          9107  LAB_BMSG
0000C4A5= 0D 0A 42 72 65 61 ...   9108      dc.b    $0D,$0A,'Break',$00
0000C4AD                          9109  LAB_EMSG
0000C4AD= 20 45 72 72 6F 72 00    9110      dc.b    ' Error',$00
0000C4B4                          9111  LAB_LMSG
0000C4B4= 20 69 6E 20 6C 69 ...   9112      dc.b    ' in line ',$00
0000C4BE                          9113  LAB_IMSG
0000C4BE= 45 78 74 72 61 20 ...   9114      dc.b    'Extra ignored',$0D,$0A,$00
0000C4CE                          9115  LAB_REDO
0000C4CE= 52 65 64 6F 20 66 ...   9116      dc.b    'Redo from start',$0D,$0A,$00
0000C4E0                          9117  LAB_RMSG
0000C4E0= 0D 0A 52 65 61 64 ...   9118      dc.b    $0D,$0A,'Ready',$0D,$0A,$00
0000C4EA                          9119  LAB_SMSG
0000C4EA= 20 42 79 74 65 73 ...   9120      dc.b    ' Bytes free',$0D,$0A,$0A
0000C4F8= 45 6E 68 61 6E 63 ...   9121      dc.b    'Enhanced 68k BASIC Version 3.54',$0D,$0A,$00
0000C51A                          9122  
0000C51A                          9123  
0000C51A                          9124  ;************************************************************************************
0000C51A                          9125  ;
0000C51A                          9126  ; This lot is in RAM
0000C51A                          9127  
0000C51A                          9128  ;           ORG     ram_addr    ; start of RAM
0000C51A                          9129  ; 
0000C51A                          9130  ;ram_strt   ds.l    $100        ; allow 1K for the stack, this should be plenty
0000C51A                          9131  ;                               ; for any BASIC program that doesn't do something
0000C51A                          9132  ;                               ; silly, it could even be much less.
0000C51A                          9133  ;ram_base
0000C51A                          9134  ;LAB_WARM   ds.w    1           ; BASIC warm start entry point
0000C51A                          9135  ;Wrmjpv     ds.l    1           ; BASIC warm start jump vector
0000C51A                          9136  ;
0000C51A                          9137  ;Usrjmp     ds.w    1           ; USR function JMP address
0000C51A                          9138  ;Usrjpv     ds.l    1           ; USR function JMP vector
0000C51A                          9139  ;
0000C51A                          9140  ;; system dependant i/o vectors
0000C51A                          9141  ;; these are in RAM and are set at start-up
0000C51A                          9142  ;
0000C51A                          9143  ;V_INPT     ds.w    1           ; non halting scan input device entry point
0000C51A                          9144  ;V_INPTv        ds.l    1           ; non halting scan input device jump vector
0000C51A                          9145  ;
0000C51A                          9146  ;V_OUTP     ds.w    1           ; send byte to output device entry point
0000C51A                          9147  ;V_OUTPv        ds.l    1           ; send byte to output device jump vector
0000C51A                          9148  ;
0000C51A                          9149  ;V_LOAD     ds.w    1           ; load BASIC program entry point
0000C51A                          9150  ;V_LOADv        ds.l    1           ; load BASIC program jump vector
0000C51A                          9151  ;
0000C51A                          9152  ;V_SAVE     ds.w    1           ; save BASIC program entry point
0000C51A                          9153  ;V_SAVEv        ds.l    1           ; save BASIC program jump vector
0000C51A                          9154  ;
0000C51A                          9155  ;V_CTLC     ds.w    1           ; save CTRL-C check entry point
0000C51A                          9156  ;V_CTLCv        ds.l    1           ; save CTRL-C check jump vector
0000C51A                          9157  ;
0000C51A                          9158  ;Itemp      ds.l    1           ; temporary integer (for GOTO etc)
0000C51A                          9159  ;
0000C51A                          9160  ;Smeml      ds.l    1           ; start of memory       (start of program)
0000C51A                          9161  ;
0000C51A                          9162  ;; the program is stored as a series of lines each line having the following format
0000C51A                          9163  ;;
0000C51A                          9164  ;;      ds.l    1           ; pointer to the next line or $00000000 if [EOT]
0000C51A                          9165  ;;      ds.l    1           ; line number
0000C51A                          9166  ;;      ds.b    n           ; program bytes
0000C51A                          9167  ;;      dc.b    $00         ; [EOL] marker, there will be a second $00 byte, if
0000C51A                          9168  ;;                      ; needed, to pad the line to an even number of bytes
0000C51A                          9169  ;
0000C51A                          9170  ;Sfncl      ds.l    1           ; start of functions    (end of Program)
0000C51A                          9171  ;
0000C51A                          9172  ;; the functions are stored as function name, function execute pointer and function
0000C51A                          9173  ;; variable name
0000C51A                          9174  ;;
0000C51A                          9175  ;;      ds.l    1           ; name
0000C51A                          9176  ;;      ds.l    1           ; execute pointer
0000C51A                          9177  ;;      ds.l    1           ; function variable
0000C51A                          9178  ;
0000C51A                          9179  ;Svarl      ds.l    1           ; start of variables    (end of functions)
0000C51A                          9180  ;
0000C51A                          9181  ;; the variables are stored as variable name, variable value
0000C51A                          9182  ;;
0000C51A                          9183  ;;      ds.l    1           ; name
0000C51A                          9184  ;;      ds.l    1           ; packed float or integer value
0000C51A                          9185  ;
0000C51A                          9186  ;Sstrl      ds.l    1           ; start of strings  (end of variables)
0000C51A                          9187  ;
0000C51A                          9188  ;; the strings are stored as string name, string pointer and string length
0000C51A                          9189  ;;
0000C51A                          9190  ;;      ds.l    1           ; name
0000C51A                          9191  ;;      ds.l    1           ; string pointer
0000C51A                          9192  ;;      ds.w    1           ; string length
0000C51A                          9193  ;
0000C51A                          9194  ;Sarryl     ds.l    1           ; start of arrays       (end of strings)
0000C51A                          9195  ;
0000C51A                          9196  ;; the arrays are stored as array name, array size, array dimensions count, array
0000C51A                          9197  ;; dimensions upper bounds and array elements
0000C51A                          9198  ;;
0000C51A                          9199  ;;      ds.l    1           ; name
0000C51A                          9200  ;;      ds.l    1           ; size including this header
0000C51A                          9201  ;;      ds.w    1           ; dimensions count
0000C51A                          9202  ;;      ds.w    1           ; 1st dimension upper bound
0000C51A                          9203  ;;      ds.w    1           ; 2nd dimension upper bound
0000C51A                          9204  ;;      ...             ; ...
0000C51A                          9205  ;;      ds.w    1           ; nth dimension upper bound
0000C51A                          9206  ;;
0000C51A                          9207  ;; then (i1+1)*(i2+1)...*(in+1) of either ..
0000C51A                          9208  ;;
0000C51A                          9209  ;;      ds.l    1           ; packed float or integer value
0000C51A                          9210  ;;
0000C51A                          9211  ;; .. if float or integer, or ..
0000C51A                          9212  ;;
0000C51A                          9213  ;;      ds.l    1           ; string pointer
0000C51A                          9214  ;;      ds.w    1           ; string length
0000C51A                          9215  ;;
0000C51A                          9216  ;; .. if string
0000C51A                          9217  ;
0000C51A                          9218  ;Earryl     ds.l    1           ; end of arrays     (start of free mem)
0000C51A                          9219  ;Sstorl     ds.l    1           ; string storage        (moving down)
0000C51A                          9220  ;Ememl      ds.l    1           ; end of memory     (upper bound of RAM)
0000C51A                          9221  ;Sutill     ds.l    1           ; string utility ptr
0000C51A                          9222  ;Clinel     ds.l    1           ; current line      (Basic line number)
0000C51A                          9223  ;Blinel     ds.l    1           ; break line        (Basic line number)
0000C51A                          9224  ;
0000C51A                          9225  ;Cpntrl     ds.l    1           ; continue pointer
0000C51A                          9226  ;Dlinel     ds.l    1           ; current DATA line
0000C51A                          9227  ;Dptrl      ds.l    1           ; DATA pointer
0000C51A                          9228  ;Rdptrl     ds.l    1           ; read pointer
0000C51A                          9229  ;Varname        ds.l    1           ; current var name
0000C51A                          9230  ;Cvaral     ds.l    1           ; current var address
0000C51A                          9231  ;Lvarpl     ds.l    1           ; variable pointer for LET and FOR/NEXT
0000C51A                          9232  ;
0000C51A                          9233  ;des_sk_e   ds.l    6           ; descriptor stack end address
0000C51A                          9234  ;des_sk                         ; descriptor stack start address
0000C51A                          9235  ;                               ; use a4 for the descriptor pointer
0000C51A                          9236  ;           ds.w    1           
0000C51A                          9237  ;Ibuffs     ds.l    $40         ; start of input buffer
0000C51A                          9238  ;Ibuffe
0000C51A                          9239  ;                               ; end of input buffer
0000C51A                          9240  ;
0000C51A                          9241  ;FAC1_m     ds.l    1           ; FAC1 mantissa1
0000C51A                          9242  ;FAC1_e     ds.w    1           ; FAC1 exponent
0000C51A                          9243  ;FAC1_s     EQU FAC1_e+1        ; FAC1 sign (b7)
0000C51A                          9244  ;           ds.w    1           
0000C51A                          9245  ;
0000C51A                          9246  ;FAC2_m     ds.l    1           ; FAC2 mantissa1
0000C51A                          9247  ;FAC2_e     ds.l    1           ; FAC2 exponent
0000C51A                          9248  ;FAC2_s     EQU FAC2_e+1        ; FAC2 sign (b7)
0000C51A                          9249  ;FAC_sc     EQU FAC2_e+2        ; FAC sign comparison, Acc#1 vs #2
0000C51A                          9250  ;flag       EQU FAC2_e+3        ; flag byte for divide routine
0000C51A                          9251  ;
0000C51A                          9252  ;PRNlword   ds.l    1           ; PRNG seed long word
0000C51A                          9253  ;
0000C51A                          9254  ;ut1_pl     ds.l    1           ; utility pointer 1
0000C51A                          9255  ;
0000C51A                          9256  ;Asptl      ds.l    1           ; array size/pointer
0000C51A                          9257  ;Astrtl     ds.l    1           ; array start pointer
0000C51A                          9258  ;
0000C51A                          9259  ;numexp     EQU Astrtl          ; string to float number exponent count
0000C51A                          9260  ;expcnt     EQU Astrtl+1        ; string to float exponent count
0000C51A                          9261  ;
0000C51A                          9262  ;expneg     EQU Astrtl+3        ; string to float eval exponent -ve flag
0000C51A                          9263  ;
0000C51A                          9264  ;func_l     ds.l    1           ; function pointer
0000C51A                          9265  ;
0000C51A                          9266  ;
0000C51A                          9267  ;                               ; these two need to be a word aligned pair !
0000C51A                          9268  ;Defdim     ds.w    1           ; default DIM flag
0000C51A                          9269  ;cosout     EQU Defdim          ; flag which CORDIC output (re-use byte)
0000C51A                          9270  ;Dtypef     EQU Defdim+1        ; data type flag, $80=string, $40=integer, $00=float
0000C51A                          9271  ;
0000C51A                          9272  ;
0000C51A                          9273  ;Binss      ds.l    4           ; number to bin string start (32 chrs)
0000C51A                          9274  ;
0000C51A                          9275  ;Decss      ds.l    1           ; number to decimal string start (16 chrs)
0000C51A                          9276  ;           ds.w    1
0000C51A                          9277  ;Usdss      ds.w    1           ; unsigned decimal string start (10 chrs)
0000C51A                          9278  ;
0000C51A                          9279  ;Hexss      ds.l    2           ; number to hex string start (8 chrs)
0000C51A                          9280  ;
0000C51A                          9281  ;BHsend     ds.w    1           ; bin/decimal/hex string end
0000C51A                          9282  ;
0000C51A                          9283  ;
0000C51A                          9284  ;prstk      ds.b    1           ; stacked function index
0000C51A                          9285  ;
0000C51A                          9286  ;tpower     ds.b    1           ; remember CORDIC power
0000C51A                          9287  ;
0000C51A                          9288  ;Asrch      ds.b    1           ; scan-between-quotes flag, alt search character
0000C51A                          9289  ;
0000C51A                          9290  ;Dimcnt     ds.b    1           ; # of dimensions
0000C51A                          9291  ;
0000C51A                          9292  ;Breakf     ds.b    1           ; break flag, $00=END else=break
0000C51A                          9293  ;Oquote     ds.b    1           ; open quote flag (Flag: DATA; LIST; memory)
0000C51A                          9294  ;Gclctd     ds.b    1           ; garbage collected flag
0000C51A                          9295  ;Sufnxf     ds.b    1           ; subscript/FNX flag, 1xxx xxx = FN(0xxx xxx)
0000C51A                          9296  ;Imode      ds.b    1           ; input mode flag, $00=INPUT, $98=READ
0000C51A                          9297  ;
0000C51A                          9298  ;Cflag      ds.b    1           ; comparison evaluation flag
0000C51A                          9299  ;
0000C51A                          9300  ;TabSiz     ds.b    1           ; TAB step size
0000C51A                          9301  ;
0000C51A                          9302  ;comp_f     ds.b    1           ; compare function flag, bits 0,1 and 2 used
0000C51A                          9303  ;                               ; bit 2 set if >
0000C51A                          9304  ;                               ; bit 1 set if =
0000C51A                          9305  ;                               ; bit 0 set if <
0000C51A                          9306  ;
0000C51A                          9307  ;Nullct     ds.b    1           ; nulls output after each line
0000C51A                          9308  ;TPos       ds.b    1           ; BASIC terminal position byte
0000C51A                          9309  ;TWidth     ds.b    1           ; BASIC terminal width byte
0000C51A                          9310  ;Iclim      ds.b    1           ; input column limit
0000C51A                          9311  ;ccflag     ds.b    1           ; CTRL-C check flag
0000C51A                          9312  ;ccbyte     ds.b    1           ; CTRL-C last received byte
0000C51A                          9313  ;ccnull     ds.b    1           ; CTRL-C last received byte 'life' timer
0000C51A                          9314  ;
0000C51A                          9315  ;
0000C51A                          9316  ;prg_strt
0000C51A                          9317  
0000C51A                          9318  ;************************************************************************************
0000C51A                          9319  ; EhBASIC keywords quick reference list                                             *
0000C51A                          9320  ;************************************************************************************
0000C51A                          9321  
0000C51A                          9322  ; glossary
0000C51A                          9323  
0000C51A                          9324  ;       <.>       required
0000C51A                          9325  ;       {.|.}         one of required
0000C51A                          9326  ;       [.]       optional
0000C51A                          9327  ;       ...       may repeat as last
0000C51A                          9328  
0000C51A                          9329  ;       any     = anything
0000C51A                          9330  ;       num     = number
0000C51A                          9331  ;       state       = statement
0000C51A                          9332  ;       n       = positive integer
0000C51A                          9333  ;       str     = string
0000C51A                          9334  ;       var     = variable
0000C51A                          9335  ;       nvar        = numeric variable
0000C51A                          9336  ;       svar        = string variable
0000C51A                          9337  ;       expr        = expression
0000C51A                          9338  ;       nexpr       = numeric expression
0000C51A                          9339  ;       sexpr       = string expression
0000C51A                          9340  
0000C51A                          9341  ; statement separator
0000C51A                          9342  
0000C51A                          9343  ; :         . [<state>] : [<state>]                         ; done
0000C51A                          9344  
0000C51A                          9345  ; number bases
0000C51A                          9346  
0000C51A                          9347  ; %         . %<binary num>                             ; done
0000C51A                          9348  ; $         . $<hex num>                                ; done
0000C51A                          9349  
0000C51A                          9350  ; commands
0000C51A                          9351  
0000C51A                          9352  ; END       . END                                       ; done
0000C51A                          9353  ; FOR       . FOR <nvar>=<nexpr> TO <nexpr> [STEP <nexpr>]  ; done
0000C51A                          9354  ; NEXT      . NEXT [<nvar>[,<nvar>]...]                     ; done
0000C51A                          9355  ; DATA      . DATA [{num|["]str["]}[,{num|["]str["]}]...]   ; done
0000C51A                          9356  ; INPUT     . INPUT [<">str<">;] <var>[,<var>[,<var>]...]   ; done
0000C51A                          9357  ; DIM       . DIM <var>(<nexpr>[,<nexpr>[,<nexpr>]])        ; done
0000C51A                          9358  ; READ      . READ <var>[,<var>[,<var>]...]             ; done
0000C51A                          9359  ; LET       . [LET] <var>=<expr>                        ; done
0000C51A                          9360  ; DEC       . DEC <nvar>[,<nvar>[,<nvar>]...]           ; done
0000C51A                          9361  ; GOTO      . GOTO <n>                                  ; done
0000C51A                          9362  ; RUN       . RUN [<n>]                                 ; done
0000C51A                          9363  ; IF        . IF <expr>{GOTO<n>|THEN<{n|comm}>}[ELSE <{n|comm}>]    ; done
0000C51A                          9364  ; RESTORE   . RESTORE [<n>]                             ; done
0000C51A                          9365  ; GOSUB     . GOSUB <n>                                 ; done
0000C51A                          9366  ; RETURN    . RETURN                                    ; done
0000C51A                          9367  ; REM       . REM [<any>]                               ; done
0000C51A                          9368  ; STOP      . STOP                                      ; done
0000C51A                          9369  ; ON        . ON <nexpr>{GOTO|GOSUB}<n>[,<n>[,<n>]...]  ; done
0000C51A                          9370  ; NULL      . NULL <nexpr>                              ; done
0000C51A                          9371  ; INC       . INC <nvar>[,<nvar>[,<nvar>]...]           ; done
0000C51A                          9372  ; WAIT      . WAIT <nexpr>,<nexpr>[,<nexpr>]            ; done
0000C51A                          9373  ; LOAD      . LOAD [<sexpr>]                            ; done for sim
0000C51A                          9374  ; SAVE      . SAVE [<sexpr>][,[<n>][-<n>]]              ; done for sim
0000C51A                          9375  ; DEF       . DEF FN<var>(<var>)=<expr>                 ; done
0000C51A                          9376  ; POKE      . POKE <nexpr>,<nexpr>                      ; done
0000C51A                          9377  ; DOKE      . DOKE <nexpr>,<nexpr>                      ; done
0000C51A                          9378  ; LOKE      . LOKE <nexpr>,<nexpr>                      ; done
0000C51A                          9379  ; CALL      . CALL <nexpr>                              ; done
0000C51A                          9380  ; DO        . DO                                        ; done
0000C51A                          9381  ; LOOP      . LOOP [{WHILE|UNTIL}<nexpr>]               ; done
0000C51A                          9382  ; PRINT     . PRINT [{;|,}][<expr>][{;|,}[<expr>]...]   ; done
0000C51A                          9383  ; CONT      . CONT                                      ; done
0000C51A                          9384  ; LIST      . LIST [<n>][-<n>]                          ; done
0000C51A                          9385  ; CLEAR     . CLEAR                                     ; done
0000C51A                          9386  ; NEW       . NEW                                       ; done
0000C51A                          9387  ; WIDTH     . WIDTH [<n>][,<n>]                         ; done
0000C51A                          9388  ; GET       . GET <var>                                 ; done
0000C51A                          9389  ; SWAP      . SWAP <var>,<var>                          ; done
0000C51A                          9390  ; BITSET    . BITSET <nexpr>,<nexpr>                    ; done
0000C51A                          9391  ; BITCLR    . BITCLR <nexpr>,<nexpr>                    ; done
0000C51A                          9392  
0000C51A                          9393  ; sub commands (may not start a statement)
0000C51A                          9394  
0000C51A                          9395  ; TAB       . TAB(<nexpr>)                              ; done
0000C51A                          9396  ; ELSE      . IF <expr>{GOTO<n>|THEN<{n|comm}>}[ELSE <{n|comm}>]    ; done
0000C51A                          9397  ; TO        . FOR <nvar>=<nexpr> TO <nexpr> [STEP <nexpr>]          ; done
0000C51A                          9398  ; FN        . FN <var>(<expr>)                          ; done
0000C51A                          9399  ; SPC       . SPC(<nexpr>)                              ; done
0000C51A                          9400  ; THEN      . IF <nexpr> {THEN <{n|comm}>|GOTO <n>}     ; done
0000C51A                          9401  ; NOT       . NOT <nexpr>                               ; done
0000C51A                          9402  ; STEP      . FOR <nvar>=<nexpr> TO <nexpr> [STEP <nexpr>]          ; done
0000C51A                          9403  ; UNTIL     . LOOP [{WHILE|UNTIL}<nexpr>]               ; done
0000C51A                          9404  ; WHILE     . LOOP [{WHILE|UNTIL}<nexpr>]               ; done
0000C51A                          9405  
0000C51A                          9406  ; operators
0000C51A                          9407  
0000C51A                          9408  ; +         . [expr] + <expr>                           ; done
0000C51A                          9409  ; -         . [nexpr] - <nexpr>                         ; done
0000C51A                          9410  ; *         . <nexpr>   ; <nexpr>                       ; done fast hardware
0000C51A                          9411  ; /         . <nexpr> / <nexpr>                         ; done fast hardware
0000C51A                          9412  ; ^         . <nexpr> ^ <nexpr>                         ; done
0000C51A                          9413  ; AND       . <nexpr> AND <nexpr>                       ; done
0000C51A                          9414  ; EOR       . <nexpr> EOR <nexpr>                       ; done
0000C51A                          9415  ; OR        . <nexpr> OR <nexpr>                        ; done
0000C51A                          9416  ; >>        . <nexpr> >> <nexpr>                        ; done
0000C51A                          9417  ; <<        . <nexpr> << <nexpr>                        ; done
0000C51A                          9418  
0000C51A                          9419  ; compare functions
0000C51A                          9420  
0000C51A                          9421  ; <         . <expr> < <expr>                           ; done
0000C51A                          9422  ; =         . <expr> = <expr>                           ; done
0000C51A                          9423  ; >         . <expr> > <expr>                           ; done
0000C51A                          9424  
0000C51A                          9425  ; functions
0000C51A                          9426  
0000C51A                          9427  ; SGN       . SGN(<nexpr>)                              ; done
0000C51A                          9428  ; INT       . INT(<nexpr>)                              ; done
0000C51A                          9429  ; ABS       . ABS(<nexpr>)                              ; done
0000C51A                          9430  ; USR       . USR(<expr>)                               ; done
0000C51A                          9431  ; FRE       . FRE(<expr>)                               ; done
0000C51A                          9432  ; POS       . POS(<expr>)                               ; done
0000C51A                          9433  ; SQR       . SQR(<nexpr>)                              ; done fast shift/sub
0000C51A                          9434  ; RND       . RND(<nexpr>)                              ; done 32 bit PRNG
0000C51A                          9435  ; LOG       . LOG(<nexpr>)                              ; done fast cordic
0000C51A                          9436  ; EXP       . EXP(<nexpr>)                              ; done fast cordic
0000C51A                          9437  ; COS       . COS(<nexpr>)                              ; done fast cordic
0000C51A                          9438  ; SIN       . SIN(<nexpr>)                              ; done fast cordic
0000C51A                          9439  ; TAN       . TAN(<nexpr>)                              ; done fast cordic
0000C51A                          9440  ; ATN       . ATN(<nexpr>)                              ; done fast cordic
0000C51A                          9441  ; PEEK      . PEEK(<nexpr>)                             ; done
0000C51A                          9442  ; DEEK      . DEEK(<nexpr>)                             ; done
0000C51A                          9443  ; LEEK      . LEEK(<nexpr>)                             ; done
0000C51A                          9444  ; LEN       . LEN(<sexpr>)                              ; done
0000C51A                          9445  ; STR$      . STR$(<nexpr>)                             ; done
0000C51A                          9446  ; VAL       . VAL(<sexpr>)                              ; done
0000C51A                          9447  ; ASC       . ASC(<sexpr>)                              ; done
0000C51A                          9448  ; UCASE$    . UCASE$(<sexpr>)                           ; done
0000C51A                          9449  ; LCASE$    . LCASE$(<sexpr>)                           ; done
0000C51A                          9450  ; CHR$      . CHR$(<nexpr>)                             ; done
0000C51A                          9451  ; HEX$      . HEX$(<nexpr>)                             ; done
0000C51A                          9452  ; BIN$      . BIN$(<nexpr>)                             ; done
0000C51A                          9453  ; BTST      . BTST(<nexpr>,<nexpr>)                     ; done
0000C51A                          9454  ; MAX       . MAX(<nexpr>[,<nexpr>[,<nexpr>]...])       ; done
0000C51A                          9455  ; MIN       . MIN(<nexpr>[,<nexpr>[,<nexpr>]...])       ; done
0000C51A                          9456  ; PI        . PI                                        ; done
0000C51A                          9457  ; TWOPI     . TWOPI                                     ; done
0000C51A                          9458  ; VARPTR    . VARPTR(<var>)                             ; done
0000C51A                          9459  ; SADD      . SADD(<svar>)                              ; done
0000C51A                          9460  ; LEFT$     . LEFT$(<sexpr>,<nexpr>)                    ; done
0000C51A                          9461  ; RIGHT$    . RIGHT$(<sexpr>,<nexpr>)                   ; done
0000C51A                          9462  ; MID$      . MID$(<sexpr>,<nexpr>[,<nexpr>])           ; done
0000C51A                          9463  ; USING$    . USING$(<sexpr>,<nexpr>[,<nexpr>]...])     ; done
0000C51A                          9464  
0000C51A                          9465  
0000C51A                          9466  ;************************************************************************************
0000C51A                          9467  
0000C51A                          9468      END code_start

No errors detected
No warnings generated


SYMBOL TABLE INFORMATION
Symbol-name         Value
-------------------------
AC1GTAC2            AAEE
ASPTL               5A8
ASRCH               5DA
ASTRTL              5AC
BHSEND              5D6
BIN2DEC             BAAE
BINPR               B694
BINSS               5B6
BIOS_PRIV           1000
BLINEL              456
BREAKF              5DC
CCBYTE              5E9
CCFLAG              5E8
CCNULL              5EA
CCP_BSS_BASE        1FD800
CCP_PRIV            1000
CFLAG               5E1
CLINEL              452
CODE_START          9046
COMP_F              5E3
COSOUT              5B4
CPM_BASE            400
CPNTRL              45A
CVARAL              46E
D1X02               BA88
D1X10               BA9E
D1X16               BA7A
DECSS               5C6
DEFDIM              5B4
DES_SK              48E
DES_SK_E            476
DIMCNT              5DB
DLINEL              45E
DOCMP               96EC
DOREST              96D8
DPTRL               462
DTYPEF              5B5
EARRYL              442
EHBASIC_BASE        9000
EHRAM_ADDR          100400
EHRAM_BASE          400
EHRAM_SIZE          FF400
EMEML               44A
ENDBHS              B66E
EXPCNT              5AD
EXPNEG              5AF
FAC1_E              594
FAC1_M              590
FAC1_S              595
FAC2_E              59C
FAC2_M              598
FAC2_S              59D
FAC_SC              59E
FEND                8
FLAG                59F
FLASH_SUPPORT       0
FSD                 0
FSDC                A
FSDPI               8
FSLI                6
FSTI                4
FUNC_L              5B0
GCLCTD              5DE
GETFIRST            9EC6
GETPAIR             9F82
GOPR                B69E
HEXSS               5CE
IBUFFE              590
IBUFFS              490
ICLIM               5E7
IMODE               5E0
INGET               B6F2
IO_BASE             F00000
ITEMP               42A
KEY_ABS             C30E
KEY_AND             C312
KEY_ASC             C315
KEY_ATN             C319
KEY_BINS            C31E
KEY_BITCLR          C323
KEY_BITSET          C329
KEY_BITTST          C32F
KEY_CALL            C337
KEY_CHRS            C33B
KEY_CLEAR           C340
KEY_CONT            C345
KEY_COS             C349
KEY_DATA            C34E
KEY_DEC             C352
KEY_DEEK            C355
KEY_DEF             C35A
KEY_DIM             C35D
KEY_DIV             C300
KEY_DO              C364
KEY_DOKE            C360
KEY_ELSE            C367
KEY_END             C36B
KEY_EOR             C36E
KEY_EQUAL           C306
KEY_EXP             C371
KEY_FN              C379
KEY_FOR             C376
KEY_FRE             C37B
KEY_GET             C380
KEY_GOSUB           C387
KEY_GOTO            C383
KEY_GT              C30A
KEY_HEXS            C38D
KEY_IF              C393
KEY_INC             C395
KEY_INPUT           C398
KEY_INT             C39D
KEY_LCASES          C3A2
KEY_LEEK            C3A9
KEY_LEFTS           C3AE
KEY_LEN             C3B4
KEY_LET             C3B8
KEY_LIST            C3BB
KEY_LOAD            C3BF
KEY_LOG             C3C3
KEY_LOKE            C3C7
KEY_LOOP            C3CB
KEY_LSHIFT          C302
KEY_LT              C304
KEY_MAX             C3D0
KEY_MIDS            C3D4
KEY_MIN             C3D9
KEY_MINUS           C2FE
KEY_MULT            C2FA
KEY_NEW             C3DE
KEY_NEXT            C3E1
KEY_NOT             C3E5
KEY_NULL            C3E8
KEY_ON              C3ED
KEY_OR              C3EF
KEY_PEEK            C3F2
KEY_PI              C3F7
KEY_PLUS            C2FC
KEY_POKE            C3F9
KEY_POS             C3FD
KEY_POWER           C4A3
KEY_PRINT           C401
KEY_RAM             C407
KEY_READ            C40E
KEY_REM             C412
KEY_RESTORE         C415
KEY_RETURN          C41C
KEY_RIGHTS          C422
KEY_RND             C429
KEY_RSHIFT          C308
KEY_RUN             C42D
KEY_SADD            C431
KEY_SAVE            C436
KEY_SGN             C43A
KEY_SIN             C43E
KEY_SPC             C442
KEY_SQR             C446
KEY_STEP            C44A
KEY_STOP            C44E
KEY_STRS            C452
KEY_SWAP            C457
KEY_TAB             C45C
KEY_TAN             C460
KEY_THEN            C464
KEY_TO              C468
KEY_TWOPI           C46A
KEY_UCASES          C470
KEY_UNTIL           C477
KEY_USINGS          C47C
KEY_USR             C483
KEY_VAL             C488
KEY_VPTR            C48C
KEY_WAIT            C494
KEY_WHILE           C498
KEY_WIDTH           C49D
KFCTSEED            26A3D110
LAB_11A5            9B94
LAB_11A6            9B96
LAB_11BD            9BA2
LAB_1269            917C
LAB_1274            918A
LAB_127D            9192
LAB_127E            91A0
LAB_1295            91B4
LAB_12AE            91D6
LAB_12B0            91D8
LAB_12E6            91F8
LAB_12FF            922A
LAB_1301            922C
LAB_1303            924A
LAB_1325            9262
LAB_132E            9252
LAB_1330            9254
LAB_134B            9270
LAB_1357            928E
LAB_1359            9294
LAB_1374            92B4
LAB_1378            92BA
LAB_137F            92C6
LAB_138E            92CC
LAB_1392            92D0
LAB_13A6            9304
LAB_13AC            930C
LAB_13C6            9336
LAB_13CC            933C
LAB_13D6            935E
LAB_13D8            9364
LAB_13EA            9370
LAB_13EC            9372
LAB_13FF            938A
LAB_1401            938E
LAB_1408            939A
LAB_1410            93A6
LAB_1417            93B0
LAB_141B            93B2
LAB_141F            93C2
LAB_142A            93C8
LAB_142C            93D4
LAB_145E            93EE
LAB_145F            93E0
LAB_1463            93F6
LAB_1477            9402
LAB_147A            9408
LAB_1480            9422
LAB_1491            942C
LAB_14BD            945E
LAB_14C0            9462
LAB_14D4            9482
LAB_14E2            949E
LAB_150C            94AC
LAB_1519            94BC
LAB_152E            94C8
LAB_1540            94F4
LAB_15B3            9554
LAB_15C2            957E
LAB_15D1            958A
LAB_15DC            9566
LAB_15F6            9578
LAB_15FF            9598
LAB_1602            959C
LAB_1624            9620
LAB_1629            95C0
LAB_1636            95C4
LAB_1639            95CA
LAB_163B            95D6
LAB_1647            95E2
LAB_164F            95E8
LAB_16B0            9680
LAB_16D0            96A4
LAB_1723            973E
LAB_1725            9742
LAB_172C            972E
LAB_172D            9736
LAB_174B            976A
LAB_174E            978E
LAB_1750            979A
LAB_1752            97A6
LAB_1754            97BE
LAB_1756            97AA
LAB_176C            97DC
LAB_1773            97E6
LAB_1785            9802
LAB_1786            982E
LAB_17B7            9844
LAB_17B8            9840
LAB_17D5            98C0
LAB_17D6            98C4
LAB_1810            98D6
LAB_1811            98E6
LAB_1813            98EC
LAB_1829            9924
LAB_182C            9928
LAB_1831            992E
LAB_185E            9970
LAB_1866            9974
LAB_1880            9A36
LAB_1886            9A40
LAB_188A            9A44
LAB_188B            9982
LAB_1898            9990
LAB_18A2            999A
LAB_18B7            99BC
LAB_18B8            99C8
LAB_18BD            99CE
LAB_18C3            99D8
LAB_18C6            99DC
LAB_18CD            99E6
LAB_18E3            99F0
LAB_18F0            9A10
LAB_18F7            9A1E
LAB_18F9            9A22
LAB_1904            9A48
LAB_1913            9A5A
LAB_1934            9A80
LAB_1953            9A94
LAB_195B            9A9C
LAB_1961            9AA6
LAB_1984            9AC6
LAB_1985            9ACA
LAB_1986            9ACE
LAB_1999            9AE2
LAB_19B0            9AF4
LAB_19B6            9B04
LAB_19C2            9B14
LAB_19DD            9B28
LAB_19F6            9B48
LAB_1A03            9B56
LAB_1A0E            9B66
LAB_1A1B            9B6C
LAB_1A46            9B86
LAB_1A90            9C04
LAB_1A9B            9C12
LAB_1ABA            9C3C
LAB_1ACD            9C68
LAB_1ADB            9C74
LAB_1ADE            9C78
LAB_1AE0            9C8E
LAB_1AFA            9CA8
LAB_1B0B            9CBE
LAB_1B13            9CC6
LAB_1B1C            9CD6
LAB_1B1D            9CD8
LAB_1B2A            9CEA
LAB_1B3C            9D06
LAB_1B43            9C4C
LAB_1B78            9D12
LAB_1B7B            9D16
LAB_1B7D            9D18
LAB_1B84            9D22
LAB_1B86            9D26
LAB_1B9D            9D4A
LAB_1BC1            9D7A
LAB_1BD0            9DEA
LAB_1BE7            9E04
LAB_1BF3            9D86
LAB_1BF7            9D8C
LAB_1BFB            9D90
LAB_1C01            9D98
LAB_1C11            9DC2
LAB_1C13            9DC8
LAB_1C18            9DD0
LAB_1C19            9DD4
LAB_1C1A            9DE4
LAB_1C2A            9E42
LAB_1CAE            9EEA
LAB_1CB5            9F08
LAB_1CD4            9F12
LAB_1CD5            9F18
LAB_1CD6            9F1A
LAB_1CDB            9F2A
LAB_1CE6            9F1C
LAB_1CF2            9F2C
LAB_1CFE            9F42
LAB_1D10            9FBA
LAB_1D12            9FBE
LAB_1D2D            9FD0
LAB_1D2E            9FDC
LAB_1D44            9FF8
LAB_1D45            A008
LAB_1D48            A01C
LAB_1D49            A024
LAB_1D4A            A028
LAB_1D4B            A038
LAB_1D5D            A040
LAB_1D5E            A046
LAB_1D83            9FAA
LAB_1D8A            9FA4
LAB_1D94            A05A
LAB_1D96            BDA4
LAB_1D98            A064
LAB_1DAC            A07E
LAB_1DAE            A080
LAB_1DAF            A08C
LAB_1DB0            A09A
LAB_1DB1            A09E
LAB_1DB2            A0A2
LAB_1DD7            A0BA
LAB_1DE6            A0D4
LAB_1E17            A116
LAB_1E1F            A11C
LAB_1E5C            A156
LAB_1E8D            A172
LAB_1EA1            A18E
LAB_1EC0            A1B6
LAB_1ED6            A1E2
LAB_1ED8            A1F0
LAB_1EDF            A1AA
LAB_1F07            A202
LAB_1F28            A21C
LAB_1F2C            A222
LAB_1F5A            A230
LAB_1F6A            A258
LAB_1F6B            A264
LAB_1F7C            A26A
LAB_1FB4            A298
LAB_1FD0            A2C4
LAB_201E            A31E
LAB_2043            A36C
LAB_2044            A39E
LAB_2045            A3A8
LAB_204S            A36E
LAB_204T            A39C
LAB_20AE            A3BA
LAB_20B4            A3BE
LAB_20BE            A3C4
LAB_20C9            A3E8
LAB_20CB            A3D4
LAB_20D0            A3DC
LAB_20D8            A3F2
LAB_20E0            A3FA
LAB_2115            A41A
LAB_2117            A432
LAB_2128            A44C
LAB_2137            A450
LAB_214B            A470
LAB_2161            A486
LAB_2176            A48E
LAB_217E            A49C
LAB_2183            A4B6
LAB_218B            A4BE
LAB_218F            A4C0
LAB_21C2            A4CC
LAB_21C4            A4D2
LAB_21D1            A506
LAB_2206            A50C
LAB_2212            A534
LAB_2216            A4F6
LAB_2240            A4FE
LAB_224D            A53A
LAB_224E            A550
LAB_229E            A594
LAB_22A0            A5A0
LAB_22B6            A5AE
LAB_22BA            A5B2
LAB_22BD            A5BC
LAB_22E6            A5D6
LAB_2316            A616
LAB_2317            A618
LAB_231C            A61C
LAB_2358            A650
LAB_2368            A670
LAB_2441            A864
LAB_2445            A868
LAB_2467            A8B8
LAB_2468            A8BC
LAB_249C            A8AA
LAB_24A8            A8C0
LAB_24B4            A8EA
LAB_24D0            A8F6
LAB_24D5            A902
LAB_24D6            A91C
LAB_24D7            A92A
LAB_24D8            A930
LAB_24D9            A910
LAB_24DA            A936
LAB_24F7            A8DA
LAB_24F8            A8E0
LAB_2778            AB9E
LAB_277C            ABA0
LAB_279B            ABC4
LAB_27BA            ABD2
LAB_27C3            ABEE
LAB_27C4            ABF8
LAB_27CA            ABFE
LAB_27CE            AC06
LAB_27D0            AC0A
LAB_27DB            AC18
LAB_27F0            AED8
LAB_27F1            AEEE
LAB_27F2            AEF4
LAB_27F3            AEF6
LAB_27FA            AC30
LAB_2828            AC50
LAB_282E            AC56
LAB_282F            AC58
LAB_2831            AC5C
LAB_284G            AC80
LAB_284H            AC92
LAB_284J            AC94
LAB_284L            AC88
LAB_2887            B89C
LAB_289A            B8C6
LAB_289C            B8CC
LAB_289D            B8D2
LAB_28FD            B8EE
LAB_28FE            B8F4
LAB_28FF            B8FA
LAB_2900            B908
LAB_2901            B90E
LAB_2902            B960
LAB_2903            B968
LAB_2904            B96A
LAB_2953            ACB6
LAB_295E            ACC2
LAB_2967            ACCE
LAB_2968            ACD6
LAB_2969            ACE8
LAB_296A            ACF2
LAB_2970            AD08
LAB_2978            AD18
LAB_2989            AD28
LAB_299C            AD7C
LAB_29A7            ADA4
LAB_29B7            ADBC
LAB_29B9            AD54
LAB_29C0            ADCA
LAB_29C3            ADE2
LAB_29D9            ADFC
LAB_29E4            AE0E
LAB_29F7            AE22
LAB_29FB            AE26
LAB_29FD            AE2E
LAB_2A18            AE3E
LAB_2A1A            AE40
LAB_2A21            AE48
LAB_2A3B            AE68
LAB_2A4B            AE76
LAB_2A58            AE8A
LAB_2A68            AEA2
LAB_2A74            AEAE
LAB_2A89            AECA
LAB_2A8C            AECE
LAB_2A91            AED4
LAB_2A9A            BF48
LAB_2A9B            BF64
LAB_2X01            B926
LAB_2X02            B92E
LAB_2X03            B93C
LAB_2X04            B942
LAB_2X05            B958
LAB_2Y01            B978
LAB_2Y02            B980
LAB_2Y03            B98C
LAB_2Y04            B992
LAB_3216            AB38
LAB_32_16           AB36
LAB_ABER            913E
LAB_ABS             AC28
LAB_AD              C2DB
LAB_ADD             A886
LAB_ADER            910A
LAB_AND             9EBE
LAB_ASC             A6FA
LAB_ATCD            B278
LAB_ATGO            B234
LAB_ATLE            B252
LAB_ATN             B216
LAB_ATNP            B272
LAB_AYFC            A2A4
LAB_BAER            C162
LAB_BHCB            9EA4
LAB_BHSS            9E7E
LAB_BINS            B650
LAB_BITCLR          B2DA
LAB_BITSET          B2CA
LAB_BMSG            C4A5
LAB_BS              C204
LAB_BTST            B2EA
LAB_CALL            A844
LAB_CASC            9F94
LAB_CATN            B27E
LAB_CAUC            9F9A
LAB_CBIN            BA4C
LAB_CBX1            BA66
LAB_CBXN            BA54
LAB_CCER            9122
LAB_CHEX            B9EA
LAB_CHRS            A5E0
LAB_CHX1            BA10
LAB_CHX2            BA34
LAB_CHX3            BA2C
LAB_CHXX            B9F2
LAB_CKRN            A2CC
LAB_CKTM            9C2E
LAB_CLEAR           9446
LAB_CN              C271
LAB_COLD            9052
LAB_CONT            9632
LAB_CORD            B1A8
LAB_COS             B138
LAB_CRLF            997A
LAB_CTBL            BE2C
LAB_CTNM            9C2C
LAB_D0              C222
LAB_D002            B5B4
LAB_D00A            B5C4
LAB_D00E            B5D4
LAB_DATA            9720
LAB_DD              C211
LAB_DDER            913A
LAB_DEC             9834
LAB_DECI            9894
LAB_DEEK            A7C2
LAB_DEF             A2D6
LAB_DIM             9F46
LAB_DIV0            AB30
LAB_DIVIDE          AAB6
LAB_DIVX            AB06
LAB_DO              9664
LAB_DOKE            A7EC
LAB_DUPFMT          B59C
LAB_DZER            9136
LAB_EMSG            C4AD
LAB_END             95CC
LAB_EOR             9EAE
LAB_EQUAL           9ED4
LAB_ESML            B04E
LAB_EVBY            A712
LAB_EVEX            9C42
LAB_EVEZ            9C44
LAB_EVIN            A0E0
LAB_EVIR            A0F0
LAB_EVNM            9C2A
LAB_EVPI            A0E8
LAB_EX1             AF86
LAB_EXAD            B0D8
LAB_EXCC            B0BE
LAB_EXCM            AFF0
LAB_EXNN            B0AA
LAB_EXOF            AFAA
LAB_EXOL            AFC0
LAB_EXOU            AF96
LAB_EXP             AFCA
LAB_EXPL            B0A4
LAB_EXPS            B002
LAB_EXRN            B0B0
LAB_EXXF            BA3A
LAB_FB95            B702
LAB_FBA0            B6E6
LAB_FC              C1CB
LAB_FCER            914E
LAB_FO              C2E3
LAB_FOER            9106
LAB_FOR             9500
LAB_FRE             A28E
LAB_FTBL            BEC8
LAB_FTPP            BE7C
LAB_FVAR            9FB2
LAB_GADB            A766
LAB_GADW            A77A
LAB_GARB            A466
LAB_GBYT            9DA4
LAB_GEAD            A79A
LAB_GET             98F2
LAB_GETS            990C
LAB_GFPN            97F6
LAB_GOSUB           9676
LAB_GOTO            9688
LAB_GOTS            9698
LAB_GSCH            9618
LAB_GTBY            A70E
LAB_GTHAN           AF78
LAB_GTWO            A724
LAB_GVAL            9D50
LAB_GVAR            9FB4
LAB_HEXS            B6A2
LAB_ID              C231
LAB_IDER            9132
LAB_IF              9748
LAB_IGBY            9DA2
LAB_IMSG            C4BE
LAB_INC             983A
LAB_INCI            988A
LAB_INCT            987C
LAB_INLN            9284
LAB_INPUT           9A68
LAB_INT             AC9A
LAB_IRTS            ACB4
LAB_ISHN            BA0C
LAB_KEYT            BFCE
LAB_LAAD            A9B0
LAB_LCASE           A678
LAB_LD              C293
LAB_LDER            911A
LAB_LEEK            A7D8
LAB_LEFT            A5F0
LAB_LENS            A6F2
LAB_LET             9898
LAB_LIST            944A
LAB_LMSG            C4B4
LAB_LOAD            A83C
LAB_LOCC            A9B6
LAB_LOCX            A9D2
LAB_LOG             A938
LAB_LOKE            A7F2
LAB_LOLP            A9C0
LAB_LONE            A9EE
LAB_LONN            A9D6
LAB_LOOP            96B6
LAB_LOWZ            AA28
LAB_LOXO            A9F4
LAB_LOXP            A9E4
LAB_LRMS            9E5C
LAB_LS              C24E
LAB_LSHIFT          9F52
LAB_LTHAN           9EDE
LAB_LTPF            B1B8
LAB_LTPT            B1C8
LAB_LT_1            AB44
LAB_MADD            AA56
LAB_MAN1            AB2A
LAB_MAX             B70E
LAB_MAXN            B71A
LAB_MIDS            A634
LAB_MIN             B724
LAB_MINN            B730
LAB_MKCHR           A5E4
LAB_MMEC            B73A
LAB_MNOC            AA50
LAB_MUEX            AAA4
LAB_MUF1            AA80
LAB_MUF2            AA8A
LAB_MUF3            AAA0
LAB_MULTIPLY        AA2A
LAB_MUUF            AAAA
LAB_NB1T            AB7C
LAB_NEW             93F4
LAB_NEXT            9B74
LAB_NF              C192
LAB_NFER            915E
LAB_NI              C2EA
LAB_NOST            991E
LAB_NSTT            B7A0
LAB_NULL            9628
LAB_OD              C1BF
LAB_ODER            9152
LAB_OFER            914A
LAB_OM              C1E2
LAB_OMER            9146
LAB_ON              97C2
LAB_OPPT            BF14
LAB_OR              9EB6
LAB_OV              C1D9
LAB_P004            B5F2
LAB_P008            B608
LAB_P00C            B610
LAB_P00E            B61C
LAB_P010            B620
LAB_P018            B63A
LAB_P01A            B63E
LAB_P01E            B646
LAB_PEEK            A7B0
LAB_PFAC            AB86
LAB_PHFA            B74A
LAB_PI              B87C
LAB_POKE            A7BC
LAB_POON            AEF8
LAB_POS             A2C0
LAB_POWER           AF14
LAB_POWP            AF46
LAB_POZE            AF08
LAB_PPBI            9E52
LAB_PPFN            9E44
LAB_PPFS            9E36
LAB_PRINT           992C
LAB_PRNA            99F2
LAB_PROCFO          B5DA
LAB_P_10            BBBE
LAB_RAM             B872
LAB_READ            9A8E
LAB_REDO            C4CE
LAB_REM             97BA
LAB_REMM            AB5C
LAB_RESS            960C
LAB_RESTORE         95FA
LAB_RET0            B9D8
LAB_RETURN          970C
LAB_RG              C1AA
LAB_RGER            9156
LAB_RIGHT           A604
LAB_RMSG            C4E0
LAB_RND             B0E4
LAB_RSED            BAD6
LAB_RSHIFT          9F62
LAB_RTN0            B9DA
LAB_RTST            A400
LAB_RUN             9650
LAB_RUNN            965E
LAB_SADD            A6DA
LAB_SAVE            A840
LAB_SCCA            9D9A
LAB_SCER            9126
LAB_SCGB            9D94
LAB_SCL0            B19E
LAB_SCLN            93E2
LAB_SCZE            B190
LAB_SET1            AB0E
LAB_SGBY            A70A
LAB_SGN             AC16
LAB_SIN             B150
LAB_SLER            912A
LAB_SMSG            C4EA
LAB_SN              C1A3
LAB_SNBS            9726
LAB_SNER            915A
LAB_SQE1            B824
LAB_SQE2            B82A
LAB_SQNA            B852
LAB_SQNS            B83C
LAB_SQR             B800
LAB_SSLN            93DA
LAB_ST              C25E
LAB_STOP            95D4
LAB_STRS            A3B6
LAB_SUBTRACT        A872
LAB_SVAR            9FB0
LAB_SVTB            B7D2
LAB_SWAP            A806
LAB_TAN             B116
LAB_TBSZ            B7B2
LAB_TM              C240
LAB_TMER            912E
LAB_TWOPI           B88C
LAB_U002            B342
LAB_U004            B398
LAB_U005            B3A8
LAB_U006            B3AA
LAB_U008            B3BE
LAB_U009            B3E0
LAB_U00A            B3E8
LAB_U00B            B3F2
LAB_U00C            B406
LAB_U00D            B40A
LAB_U00E            B41C
LAB_U00F            B428
LAB_U010            B42C
LAB_U014            B432
LAB_U018            B43A
LAB_U01C            B450
LAB_U020            B45C
LAB_U022            B462
LAB_U026            B472
LAB_U02A            B47C
LAB_U02B            B494
LAB_U02C            B49A
LAB_U02E            B4AC
LAB_U030            B4B0
LAB_U034            B4C6
LAB_U036            B4CC
LAB_U038            B4D4
LAB_U03C            B4DC
LAB_U03E            B4E2
LAB_U040            B4FA
LAB_U044            B50A
LAB_U046            B532
LAB_U048            B534
LAB_U04A            B53E
LAB_U04C            B570
LAB_UA              C2B6
LAB_UCASE           A6A8
LAB_UDER            9112
LAB_UF              C280
LAB_UFAC            AB6A
LAB_UFER            911E
LAB_US              C1F0
LAB_USER            9142
LAB_USINGS          B318
LAB_USR             A834
LAB_UV              C2A3
LAB_UVER            9116
LAB_VAL             A738
LAB_VALZ            A760
LAB_VARCALL         B864
LAB_VARPTR          B862
LAB_WAIT            A84E
LAB_WARM            400
LAB_WD              C2CA
LAB_WDER            910E
LAB_WDLP            B7E6
LAB_WDTH            B780
LAB_XDIV            AB1E
LAB_XERR            9160
LAB_XGADW           A794
LC_LOOP             A68E
LOOPALWAYS          96F2
LOOPDONE            9706
LVARPL              472
L_DDIV              AB64
L_DIVRND            AB12
MAINLOOP            B1E0
MON_BASE            7000
MON_PRIV            800
N                   2
NEXTA               B1F2
NEXTB1              B660
NEXTB2              B686
NEXTH1              B6B2
NEXTPRN             B0F2
NINC0               B0FA
NINC1               B100
NOBRK               0
NOLCASE             A6D0
NOSHIFT             9F5E
NOSTRING            A6D6
NOT2BIG             9F76
NOUCASE             A6A0
NOVAR               0
NULLCT              5E4
NUMEXP              5AC
OFCHR               23
OQUOTE              5DD
OUTLOOP             B200
PRG_STRT            5EC
PRNLWORD            5A0
PRSTK               5D8
RAM_BASE            100000
RAM_LEN             100000
RAM_STRT            0
RDPTRL              466
RETCHR              9028
ROM_START           9000
RTS_001             9DC0
RTS_005             9444
RTS_006             9626
RTS_007             9724
RTS_007A            973A
RTS_008             98F0
RTS_009             99EE
RTS_011             A268
RTS_012             A538
RTS_013             A5AC
RTS_015             A804
RTS_016             A8DE
RTS_017             ABFC
RTS_020             AF84
RTS_021             B2C8
RTS_022             B6F0
RTS_023             B7FE
RTS_024             BA4A
RTS_025             BAAC
SARRYL              43E
SFNCL               432
SMEML               42E
SSTORL              446
SSTRL               43A
STACK_START         1FF800
SUBEXIT             B20A
SUBLOOP             B1D8
SUFNXF              5DF
SUTILL              44E
SVARL               436
TABSIZ              5E2
TAB_ASCA            C30E
TAB_ASCB            C31E
TAB_ASCC            C337
TAB_ASCD            C34E
TAB_ASCE            C367
TAB_ASCF            C376
TAB_ASCG            C380
TAB_ASCH            C38D
TAB_ASCI            C393
TAB_ASCL            C3A2
TAB_ASCM            C3D0
TAB_ASCN            C3DE
TAB_ASCO            C3ED
TAB_ASCP            C3F2
TAB_ASCR            C407
TAB_ASCS            C431
TAB_ASCT            C45C
TAB_ASCU            C470
TAB_ASCV            C488
TAB_ASCW            C494
TAB_ATNC            BD2C
TAB_CHRT            BF64
TAB_EQUL            C306
TAB_HTHET           BDAC
TAB_LESS            C302
TAB_MNUS            C2FE
TAB_MORE            C308
TAB_PLUS            C2FC
TAB_POWR            C4A3
TAB_QEST            C30C
TAB_SLAS            C300
TAB_SNCO            BCAC
TAB_STAR            C2FA
TK_ABS              C1
TK_AND              B7
TK_ASC              D3
TK_ATN              CC
TK_BINS             D8
TK_BITCLR           A7
TK_BITSET           A6
TK_BITTST           D9
TK_CALL             9B
TK_CHRS             D6
TK_CLEAR            A1
TK_CONT             9F
TK_COS              C9
TK_DATA             83
TK_DEC              88
TK_DEEK             CE
TK_DEF              97
TK_DIM              85
TK_DIV              B5
TK_DO               9C
TK_DOKE             99
TK_ELSE             A9
TK_END              80
TK_EOR              B8
TK_EQUAL            BD
TK_EXP              C8
TK_FN               AB
TK_FOR              81
TK_FRE              C3
TK_GET              A4
TK_GOSUB            8D
TK_GOTO             89
TK_GT               BC
TK_HEXS             D7
TK_IF               8B
TK_INC              93
TK_INPUT            84
TK_INT              C0
TK_LCASES           D5
TK_LEEK             CF
TK_LEFTS            E1
TK_LEN              D0
TK_LET              87
TK_LIST             A0
TK_LOAD             95
TK_LOG              C7
TK_LOKE             9A
TK_LOOP             9D
TK_LSHIFT           BB
TK_LT               BE
TK_MAX              DA
TK_MIDS             E3
TK_MIN              DB
TK_MINUS            B3
TK_MULT             B4
TK_NEW              A2
TK_NEXT             82
TK_NOT              AE
TK_NULL             92
TK_ON               91
TK_OR               B9
TK_PEEK             CD
TK_PI               DD
TK_PLUS             B2
TK_POKE             98
TK_POS              C4
TK_POWER            B6
TK_PRINT            9E
TK_RAM              DC
TK_READ             86
TK_REM              8F
TK_RESTORE          8C
TK_RETURN           8E
TK_RIGHTS           E2
TK_RND              C6
TK_RSHIFT           BA
TK_RUN              8A
TK_SADD             E0
TK_SAVE             96
TK_SGN              BF
TK_SIN              CA
TK_SPC              AC
TK_SQR              C5
TK_STEP             AF
TK_STOP             90
TK_STRS             D1
TK_SWAP             A5
TK_TAB              A8
TK_TAN              CB
TK_THEN             AD
TK_TO               AA
TK_TWOPI            DE
TK_UCASES           D4
TK_UNTIL            B0
TK_USINGS           E4
TK_USR              C2
TK_VAL              D2
TK_VPTR             DF
TK_WAIT             94
TK_WHILE            B1
TK_WIDTH            A3
TOOBIG              9F7C
TPOS                5E5
TPOWER              5D9
TWIDTH              5E6
UC_LOOP             A6BE
USDSS               5CC
USRJMP              406
USRJPV              408
UT1_PL              5A4
VARNAME             46A
VEC_BASE            100000
VEC_CC              B6CC
VEC_IN              9016
VEC_LD              903A
VEC_OUT             9006
VEC_SIZE            400
VEC_SV              9040
V_CTLC              424
V_CTLCV             426
V_INPT              40C
V_INPTV             40E
V_LOAD              418
V_LOADV             41A
V_OUTP              412
V_OUTPV             414
V_SAVE              41E
V_SAVEV             420
WEXIT               B7D6
WRMJPV              402
