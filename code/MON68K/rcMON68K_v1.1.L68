00001378 Starting Address
Assembler used: EASy68K Editor/Assembler v5.16.01
Created On: 08/03/2025 17:22:17

00000000                             1  *******************************************************************************
00000000                             2  * rcMon-68k v1.1
00000000                             3  *******************************************************************************
00000000                             4  * Written to support my own RCBus 68000 board. Supports simple S-Record loading as
00000000                             5  * well as memory display & modification. No breakpoints, single stepping or
00000000                             6  * disassembly stuff.
00000000                             7  *
00000000                             8  * ROM : 128K organised as 64K  x 16bits (2x W27C512 EEPROM)
00000000                             9  * RAM : 1M   organised as 512K x 16bits (2x AS6C4008)
00000000                            10  *
00000000                            11  * ROM starts at 0x000000 up to 0x01FFFF (128K)
00000000                            12  * RAM starts at 0x100000 up to 0x1FFFFF (1M)
00000000                            13  *
00000000                            14  * Use EASyBIN to split the S-Record into ODD and EVEN bytes.
00000000                            15  * The *_0.BIN file goes in the U ROM socket - holding D08..D15
00000000                            16  * The *_1.BIN file goes in the L ROM socket - holding D00..D07
00000000                            17  *
00000000                            18  *******************************************************************************
00000000                            19  * Exception Handling
00000000                            20  *******************************************************************************
00000000                            21  * ROM starts at $0000 and holds the exception vector table. The table entries
00000000                            22  * each jump to a small routine that gets the handler address from the start of
00000000                            23  * RAM (or wherever VEC_BASE is defined) and re-directs execution to that address.
00000000                            24  * Initially the RAM addresses all point back to handlers in ROM but can be
00000000                            25  * overwritten to point to a user supplied handler in RAM. 
00000000                            26  *
00000000                            27  * BUS ERROR & ADDRESS ERROR handlers always use the ROM vector table addresses.
00000000                            28  * Some Easy68k TRAP #15 text I/O routines are implemented. 
00000000                            29  * NOTE THAT FOR TESTING TRAP #14 IS USED AS SIM68K STILL INTERCEPTS TRAP #15.
00000000                            30  *******************************************************************************
00000000                            31  * EASy68K TRAP #15 Support:
00000000                            32  * Currently only tasks 0,1,5,6,13 & 14 are supported.
00000000                            33  
00000000                            34  *******************************************************************************
00000000                            35  * Constants
00000000                            36  *
00000000  =00000000                 37  ROM_BASE        EQU     $00000      * ROM base addr = 0000_0000
00000000  =00100000                 38  RAM_BASE        EQU     $100000     * RAM base addr = 0010_0000
00000000  =00100000                 39  RAM_LEN         EQU     $100000     * 1M RAM fitted
00000000  =00100000                 40  VEC_BASE        EQU     RAM_BASE    * Exception vectors table in RAM
00000000  =00F00180                 41  DUART_BASE      EQU     $F00180     * SCC68692 base addr = $80 in IO space
00000000  =00F00000                 42  IO_BASE         EQU     $F00000     * I/O space base address = 00F0_0000
00000000                            43  
00000000                            44  * Set the stack pointer to RAM_BASE + RAM_LEN - 256 allowing space
00000000                            45  * for 256 bytes of monitor variables at the top of RAM if needed.
00000000                            46  *
00000000  =001FFF00                 47  STACK_START     EQU     RAM_BASE+RAM_LEN-256
00000000                            48  
00000000                            49  * Set USE_REAL_UART so:
00000000                            50  *  1 = use the real UART
00000000                            51  *  0 = use Easy68k Sim68k I/O window
00000000                            52  * -1 = use Easy68k Sim68k COM port
00000000                            53  *
00000000                            54  * COM port is defined at the end of this file - change accordingly
00000000                            55  *
00000000  =00000001                 56  USE_REAL_UART     EQU     1
00000000                            57  
00000000                            58  *-----------------------------------------------------------------------------
00000000                            59  * Baud rates with ACR[7]=0 straight from the SCC68692 datasheet table
00000000                            60  *-----------------------------------------------------------------------------
00000000  =00000066                 61  BAUD_1200       EQU     $66         * 1200 baud
00000000  =00000088                 62  BAUD_2400       EQU     $88         * 2400 baud
00000000  =00000099                 63  BAUD_4800       EQU     $99         * 4800 baud
00000000  =000000BB                 64  BAUD_9600       EQU     $BB         * 9600 baud
00000000  =000000CC                 65  BAUD_38400      EQU     $CC         * 38400 baud
00000000                            66  
00000000  =000000CC                 67  BAUD_RATE       EQU     BAUD_38400
00000000                            68  
00000000                            69  *------------------------------------------------------------------------------
00000000                            70  * SCC68692 Duart Register Addresses
00000000                            71  * DUART 8-bit data is on D0..D7
00000000                            72  *
00000000  =00F00181                 73  MRA   equ DUART_BASE+1       * Mode Register A             (R/W)
00000000  =00F00183                 74  SRA   equ DUART_BASE+3       * Status Register A           (R)
00000000  =00F00183                 75  CSRA  equ DUART_BASE+3       * Clock Select Register A     (W)
00000000  =00F00185                 76  CRA   equ DUART_BASE+5       * Commands Register A         (W)
00000000  =00F00187                 77  RBA   equ DUART_BASE+7       * Receiver Buffer A           (R)
00000000  =00F00187                 78  TBA   equ DUART_BASE+7       * Transmitter Buffer A        (W)
00000000  =00F00189                 79  ACR   equ DUART_BASE+9       * Aux. Control Register       (R/W)
00000000  =00F0018B                 80  ISR   equ DUART_BASE+11      * Interrupt Status Register   (R)
00000000  =00F0018B                 81  IMR   equ DUART_BASE+11      * Interrupt Mask Register     (W)
00000000  =00F00191                 82  MRB   equ DUART_BASE+17      * Mode Register B             (R/W)
00000000  =00F00193                 83  SRB   equ DUART_BASE+19      * Status Register B           (R)
00000000  =00F00193                 84  CSRB  equ DUART_BASE+19      * Clock Select Register B     (W)
00000000  =00F00195                 85  CRB   equ DUART_BASE+21      * Commands Register B         (W)
00000000  =00F00197                 86  RBB   equ DUART_BASE+23      * Reciever Buffer B           (R)
00000000  =00F00197                 87  TBB   equ DUART_BASE+23      * Transmitter Buffer B        (W)
00000000  =00F00199                 88  IVR   equ DUART_BASE+25      * Interrupt Vector Register   (R/W)
00000000  =00F0019B                 89  IPR   equ DUART_BASE+27      * Input Port Register         (R)
00000000  =00F0019B                 90  OPCR  equ DUART_BASE+27      * Output Port Config Register (W)
00000000  =00F0019D                 91  BCNT  equ DUART_BASE+29      * Start Counter               (R)
00000000  =00F0019D                 92  SOPR  equ DUART_BASE+29      * Set Output Port Register    (W)
00000000  =00F0019F                 93  ECNT  equ DUART_BASE+31      * Stop Counter                (R)
00000000  =00F0019F                 94  ROPR  equ DUART_BASE+31      * Reset Output Port Register  (W)
00000000                            95  
00000000                            96  *------------------------------------------------------------------------------
00000000                            97  * Macro to "jump" to exception handler pointed to in the RAM vector table
00000000                            98  * Parameter \1 is the vector number 
00000000                            99  * Put the handler address held in RAM onto the stack and RET to it
00000000                           100  *------------------------------------------------------------------------------
00000000                           101  ramVecJump  MACRO
00000000                           102      move.l  VEC_BASE+(\1<<2),-(SP)
00000000                           103      rts
00000000                           104      ENDM
00000000                           105  
00000000                           106  *------------------------------------------------------------------------------
00000000                           107  * ASCII control characters
00000000                           108  *------------------------------------------------------------------------------
00000000  =0000000A                109  LF    equ $0A
00000000  =0000000D                110  CR    equ $0D
00000000                           111  
00000000                           112  *------------------------------------------------------------------------------
00000000                           113  * 68000 Exception Vector Table - THIS ONE IS IN ROM
00000000                           114  * All exceptions get the handler addresses from the RAM vector table except for
00000000                           115  * Bus Error, Address Error & TRAP #15 which always call handlers in the ROM. 
00000000                           116  *------------------------------------------------------------------------------
00000000                           117  
00000000                           118      ORG     $0000
00000000                           119  
00000000= 001FFF00                 120      DC.l    STACK_START  * Supervisor stack pointer
00000004= 00001378                 121      DC.l    START        * Initial PC    
00000008                           122  
00000008= 00000978                 123      DC.L    handleBusErr   *02 Bus Error     (** ROM handler **)
0000000C= 00000994                 124      DC.L    handleAddrErr  *03 Address Error (** ROM handler **)
00000010= 00000410                 125      DC.L    jmpIllInst     *04 Illegal Instruction
00000014= 00000418                 126      DC.L    jmpZeroDiv     *05 Zero Divide
00000018= 00000420                 127      DC.L    jmpChkInst     *06 CHK Instruction
0000001C= 00000428                 128      DC.L    jmpTrapV       *07 TRAPV Instruction
00000020= 00000430                 129      DC.L    jmpPriv        *08 Privilege Violation
00000024= 00000438                 130      DC.L    jmpTrace       *09 Trace
00000028= 00000440                 131      DC.L    jmpLineA       *0A Line 1010 Emulator
0000002C= 00000448                 132      DC.L    jmpLineF       *0B Line 1111 Emulator
00000030= 00000450                 133      DC.L    jmpRes1        *0C (Unassigned, Reserved)
00000034= 00000458                 134      DC.L    jmpRes2        *0D (Unassigned, Reserved)
00000038= 00000460                 135      DC.L    jmpRes3        *0E (Unassigned, Reserved)
0000003C= 00000468                 136      DC.L    jmpUnInit      *0F Uninitialized Interrupt Vector
00000040= 00000470                 137      DC.L    jmpRes4        *10 (Unassigned, Reserved)
00000044= 00000478                 138      DC.L    jmpRes5        *11 (Unassigned, Reserved)
00000048= 00000480                 139      DC.L    jmpRes6        *12 (Unassigned, Reserved)
0000004C= 00000488                 140      DC.L    jmpRes7        *13 (Unassigned, Reserved)
00000050= 00000490                 141      DC.L    jmpRes8        *14 (Unassigned, Reserved)
00000054= 00000498                 142      DC.L    jmpRes9        *15 (Unassigned, Reserved)
00000058= 000004A0                 143      DC.L    jmpRes10       *16 (Unassigned, Reserved)
0000005C= 000004A8                 144      DC.L    jmpRes11       *17 (Unassigned, Reserved)
00000060= 000004B0                 145      DC.L    jmpSpur        *18 Spurious Interrupt
00000064= 000004B8                 146      DC.L    jmpAV1         *19 Level 1 Interrupt Autovector
00000068= 000004C0                 147      DC.L    jmpAV2         *1A Level 2 Interrupt Autovector
0000006C= 000004C8                 148      DC.L    jmpAV3         *1B Level 3 Interrupt Autovector
00000070= 000004D0                 149      DC.L    jmpAV4         *1C Level 4 Interrupt Autovector
00000074= 000004D8                 150      DC.L    jmpAV5         *1D Level 5 Interrupt Autovector
00000078= 000004E0                 151      DC.L    jmpAV6         *1E Level 6 Interrupt Autovector
0000007C= 000004E8                 152      DC.L    jmpAV7         *1F Level 7 Interrupt Autovector
00000080= 000004F0                 153      DC.L    jmpTrap0       *20 TRAP #0  Instruction Vector
00000084= 000004F8                 154      DC.L    jmpTrap1       *21 TRAP #1  Instruction Vector
00000088= 00000500                 155      DC.L    jmpTrap2       *22 TRAP #2  Instruction Vector
0000008C= 00000508                 156      DC.L    jmpTrap3       *23 TRAP #3  Instruction Vector
00000090= 00000510                 157      DC.L    jmpTrap4       *24 TRAP #4  Instruction Vector
00000094= 00000518                 158      DC.L    jmpTrap5       *25 TRAP #5  Instruction Vector
00000098= 00000520                 159      DC.L    jmpTrap6       *26 TRAP #6  Instruction Vector
0000009C= 00000528                 160      DC.L    jmpTrap7       *27 TRAP #7  Instruction Vector
000000A0= 00000530                 161      DC.L    jmpTrap8       *28 TRAP #8  Instruction Vector
000000A4= 00000538                 162      DC.L    jmpTrap9       *29 TRAP #9  Instruction Vector
000000A8= 00000540                 163      DC.L    jmpTrap10      *2A TRAP #10 Instruction Vector
000000AC= 00000548                 164      DC.L    jmpTrap11      *2B TRAP #11 Instruction Vector
000000B0= 00000550                 165      DC.L    jmpTrap12      *2C TRAP #12 Instruction Vector
000000B4= 00000558                 166      DC.L    jmpTrap13      *2D TRAP #13 Instruction Vector
000000B8= 00000560                 167      DC.L    jmpTrap14      *2E TRAP #14 Instruction Vector
000000BC= 00001850                 168      DC.L    easy68kTrap15  *2E TRAP #15 Instruction Vector (** ROM handler **)
000000C0                           169  *    DC.L    jmpTrap15      *2F TRAP #15 Instruction Vector
000000C0                           170      
000000C0                           171      
000000C0                           172  *------------------------------------------------------------------------------
000000C0                           173  * Exception Vectors 30 to FF are not used on my system so just point them
000000C0                           174  * all to the default handler.
000000C0                           175  
000000C0= 00000570 00000570 ...    176      DCB.L   208,jmpUnused
00000400                           177      
00000400                           178  *------------------------------------------------------------------------------
00000400                           179  * The hard coded ROM exception vector table entries point to these individual
00000400                           180  * handlers that then jump to the address specified in the RAM exception vector
00000400                           181  * table.
00000400                           182  *------------------------------------------------------------------------------
00000400                           183      ORG     (*+1)&-2    * make sure the table is word aligned
00000400                           184  
00000400                           185m jmpBusErr:  ramVecJump  $02
00000400  2F39 00100008            186m     MOVE.L  VEC_BASE+($02<<2),-(SP)
00000406  4E75                     187m     RTS
00000408                           188m     ENDM
00000408                           189m jmpAddrErr: ramVecJump  $03
00000408  2F39 0010000C            190m     MOVE.L  VEC_BASE+($03<<2),-(SP)
0000040E  4E75                     191m     RTS
00000410                           192m     ENDM
00000410                           193m jmpIllInst: ramVecJump  $04
00000410  2F39 00100010            194m     MOVE.L  VEC_BASE+($04<<2),-(SP)
00000416  4E75                     195m     RTS
00000418                           196m     ENDM
00000418                           197m jmpZeroDiv: ramVecJump  $05
00000418  2F39 00100014            198m     MOVE.L  VEC_BASE+($05<<2),-(SP)
0000041E  4E75                     199m     RTS
00000420                           200m     ENDM
00000420                           201m jmpChkInst: ramVecJump  $06
00000420  2F39 00100018            202m     MOVE.L  VEC_BASE+($06<<2),-(SP)
00000426  4E75                     203m     RTS
00000428                           204m     ENDM
00000428                           205m jmpTrapV:   ramVecJump  $07
00000428  2F39 0010001C            206m     MOVE.L  VEC_BASE+($07<<2),-(SP)
0000042E  4E75                     207m     RTS
00000430                           208m     ENDM
00000430                           209m jmpPriv:    ramVecJump  $08
00000430  2F39 00100020            210m     MOVE.L  VEC_BASE+($08<<2),-(SP)
00000436  4E75                     211m     RTS
00000438                           212m     ENDM
00000438                           213m jmpTrace:   ramVecJump  $09
00000438  2F39 00100024            214m     MOVE.L  VEC_BASE+($09<<2),-(SP)
0000043E  4E75                     215m     RTS
00000440                           216m     ENDM
00000440                           217m jmpLineA:   ramVecJump  $0A
00000440  2F39 00100028            218m     MOVE.L  VEC_BASE+($0A<<2),-(SP)
00000446  4E75                     219m     RTS
00000448                           220m     ENDM
00000448                           221m jmpLineF:   ramVecJump  $0B
00000448  2F39 0010002C            222m     MOVE.L  VEC_BASE+($0B<<2),-(SP)
0000044E  4E75                     223m     RTS
00000450                           224m     ENDM
00000450                           225m jmpRes1:    ramVecJump  $0C
00000450  2F39 00100030            226m     MOVE.L  VEC_BASE+($0C<<2),-(SP)
00000456  4E75                     227m     RTS
00000458                           228m     ENDM
00000458                           229m jmpRes2:    ramVecJump  $0D
00000458  2F39 00100034            230m     MOVE.L  VEC_BASE+($0D<<2),-(SP)
0000045E  4E75                     231m     RTS
00000460                           232m     ENDM
00000460                           233m jmpRes3:    ramVecJump  $0E
00000460  2F39 00100038            234m     MOVE.L  VEC_BASE+($0E<<2),-(SP)
00000466  4E75                     235m     RTS
00000468                           236m     ENDM
00000468                           237m jmpUnInit:  ramVecJump  $0F
00000468  2F39 0010003C            238m     MOVE.L  VEC_BASE+($0F<<2),-(SP)
0000046E  4E75                     239m     RTS
00000470                           240m     ENDM
00000470                           241m jmpRes4:    ramVecJump  $10
00000470  2F39 00100040            242m     MOVE.L  VEC_BASE+($10<<2),-(SP)
00000476  4E75                     243m     RTS
00000478                           244m     ENDM
00000478                           245m jmpRes5:    ramVecJump  $11
00000478  2F39 00100044            246m     MOVE.L  VEC_BASE+($11<<2),-(SP)
0000047E  4E75                     247m     RTS
00000480                           248m     ENDM
00000480                           249m jmpRes6:    ramVecJump  $12
00000480  2F39 00100048            250m     MOVE.L  VEC_BASE+($12<<2),-(SP)
00000486  4E75                     251m     RTS
00000488                           252m     ENDM
00000488                           253m jmpRes7:    ramVecJump  $13
00000488  2F39 0010004C            254m     MOVE.L  VEC_BASE+($13<<2),-(SP)
0000048E  4E75                     255m     RTS
00000490                           256m     ENDM
00000490                           257m jmpRes8:    ramVecJump  $14
00000490  2F39 00100050            258m     MOVE.L  VEC_BASE+($14<<2),-(SP)
00000496  4E75                     259m     RTS
00000498                           260m     ENDM
00000498                           261m jmpRes9:    ramVecJump  $15
00000498  2F39 00100054            262m     MOVE.L  VEC_BASE+($15<<2),-(SP)
0000049E  4E75                     263m     RTS
000004A0                           264m     ENDM
000004A0                           265m jmpRes10:   ramVecJump  $16
000004A0  2F39 00100058            266m     MOVE.L  VEC_BASE+($16<<2),-(SP)
000004A6  4E75                     267m     RTS
000004A8                           268m     ENDM
000004A8                           269m jmpRes11:   ramVecJump  $17
000004A8  2F39 0010005C            270m     MOVE.L  VEC_BASE+($17<<2),-(SP)
000004AE  4E75                     271m     RTS
000004B0                           272m     ENDM
000004B0                           273m jmpSpur:    ramVecJump  $18
000004B0  2F39 00100060            274m     MOVE.L  VEC_BASE+($18<<2),-(SP)
000004B6  4E75                     275m     RTS
000004B8                           276m     ENDM
000004B8                           277m jmpAV1:     ramVecJump  $19
000004B8  2F39 00100064            278m     MOVE.L  VEC_BASE+($19<<2),-(SP)
000004BE  4E75                     279m     RTS
000004C0                           280m     ENDM
000004C0                           281m jmpAV2:     ramVecJump  $1A
000004C0  2F39 00100068            282m     MOVE.L  VEC_BASE+($1A<<2),-(SP)
000004C6  4E75                     283m     RTS
000004C8                           284m     ENDM
000004C8                           285m jmpAV3:     ramVecJump  $1B
000004C8  2F39 0010006C            286m     MOVE.L  VEC_BASE+($1B<<2),-(SP)
000004CE  4E75                     287m     RTS
000004D0                           288m     ENDM
000004D0                           289m jmpAV4:     ramVecJump  $1C
000004D0  2F39 00100070            290m     MOVE.L  VEC_BASE+($1C<<2),-(SP)
000004D6  4E75                     291m     RTS
000004D8                           292m     ENDM
000004D8                           293m jmpAV5:     ramVecJump  $1D
000004D8  2F39 00100074            294m     MOVE.L  VEC_BASE+($1D<<2),-(SP)
000004DE  4E75                     295m     RTS
000004E0                           296m     ENDM
000004E0                           297m jmpAV6:     ramVecJump  $1E
000004E0  2F39 00100078            298m     MOVE.L  VEC_BASE+($1E<<2),-(SP)
000004E6  4E75                     299m     RTS
000004E8                           300m     ENDM
000004E8                           301m jmpAV7:     ramVecJump  $1F
000004E8  2F39 0010007C            302m     MOVE.L  VEC_BASE+($1F<<2),-(SP)
000004EE  4E75                     303m     RTS
000004F0                           304m     ENDM
000004F0                           305m jmpTrap0:   ramVecJump  $20
000004F0  2F39 00100080            306m     MOVE.L  VEC_BASE+($20<<2),-(SP)
000004F6  4E75                     307m     RTS
000004F8                           308m     ENDM
000004F8                           309m jmpTrap1:   ramVecJump  $21
000004F8  2F39 00100084            310m     MOVE.L  VEC_BASE+($21<<2),-(SP)
000004FE  4E75                     311m     RTS
00000500                           312m     ENDM
00000500                           313m jmpTrap2:   ramVecJump  $22
00000500  2F39 00100088            314m     MOVE.L  VEC_BASE+($22<<2),-(SP)
00000506  4E75                     315m     RTS
00000508                           316m     ENDM
00000508                           317m jmpTrap3:   ramVecJump  $23
00000508  2F39 0010008C            318m     MOVE.L  VEC_BASE+($23<<2),-(SP)
0000050E  4E75                     319m     RTS
00000510                           320m     ENDM
00000510                           321m jmpTrap4:   ramVecJump  $24
00000510  2F39 00100090            322m     MOVE.L  VEC_BASE+($24<<2),-(SP)
00000516  4E75                     323m     RTS
00000518                           324m     ENDM
00000518                           325m jmpTrap5:   ramVecJump  $25
00000518  2F39 00100094            326m     MOVE.L  VEC_BASE+($25<<2),-(SP)
0000051E  4E75                     327m     RTS
00000520                           328m     ENDM
00000520                           329m jmpTrap6:   ramVecJump  $26
00000520  2F39 00100098            330m     MOVE.L  VEC_BASE+($26<<2),-(SP)
00000526  4E75                     331m     RTS
00000528                           332m     ENDM
00000528                           333m jmpTrap7:   ramVecJump  $27
00000528  2F39 0010009C            334m     MOVE.L  VEC_BASE+($27<<2),-(SP)
0000052E  4E75                     335m     RTS
00000530                           336m     ENDM
00000530                           337m jmpTrap8:   ramVecJump  $28
00000530  2F39 001000A0            338m     MOVE.L  VEC_BASE+($28<<2),-(SP)
00000536  4E75                     339m     RTS
00000538                           340m     ENDM
00000538                           341m jmpTrap9:   ramVecJump  $29
00000538  2F39 001000A4            342m     MOVE.L  VEC_BASE+($29<<2),-(SP)
0000053E  4E75                     343m     RTS
00000540                           344m     ENDM
00000540                           345m jmpTrap10:  ramVecJump  $2A
00000540  2F39 001000A8            346m     MOVE.L  VEC_BASE+($2A<<2),-(SP)
00000546  4E75                     347m     RTS
00000548                           348m     ENDM
00000548                           349m jmpTrap11:  ramVecJump  $2B
00000548  2F39 001000AC            350m     MOVE.L  VEC_BASE+($2B<<2),-(SP)
0000054E  4E75                     351m     RTS
00000550                           352m     ENDM
00000550                           353m jmpTrap12:  ramVecJump  $2C
00000550  2F39 001000B0            354m     MOVE.L  VEC_BASE+($2C<<2),-(SP)
00000556  4E75                     355m     RTS
00000558                           356m     ENDM
00000558                           357m jmpTrap13:  ramVecJump  $2D
00000558  2F39 001000B4            358m     MOVE.L  VEC_BASE+($2D<<2),-(SP)
0000055E  4E75                     359m     RTS
00000560                           360m     ENDM
00000560                           361m jmpTrap14:  ramVecJump  $2E
00000560  2F39 001000B8            362m     MOVE.L  VEC_BASE+($2E<<2),-(SP)
00000566  4E75                     363m     RTS
00000568                           364m     ENDM
00000568                           365m jmpTrap15:  ramVecJump  $2F
00000568  2F39 001000BC            366m     MOVE.L  VEC_BASE+($2F<<2),-(SP)
0000056E  4E75                     367m     RTS
00000570                           368m     ENDM
00000570                           369  
00000570                           370m jmpUnused:  ramVecJump  $30
00000570  2F39 001000C0            371m     MOVE.L  VEC_BASE+($30<<2),-(SP)
00000576  4E75                     372m     RTS
00000578                           373m     ENDM
00000578                           374  
00000578                           375  *------------------------------------------------------------------------------
00000578                           376  * This is the initial exception vector table that gets copied into RAM. It just
00000578                           377  * holds the addresses of basic exception handlers in ROM. The ramVecJump indexes
00000578                           378  * into this table to get the addresses of the actual exception handlers. 
00000578                           379  *
00000578                           380  * NOTE: Bus Error, Address Error & TRAP #15 are all hard coded to be handled by
00000578                           381  * routines in ROM and the entries in this table are not used.
00000578                           382  *------------------------------------------------------------------------------
00000578                           383      ORG     (*+1)&-2       * make sure the table is word aligned
00000578                           384  
00000578                           385  rom2ramIVT:
00000578= 001FFF00                 386      DC.L    STACK_START    *00 Supervisor stack pointer
0000057C= 00001378                 387      DC.L    START          *01 Initial PC    
00000580                           388  
00000580= 00000978                 389      DC.L    handleBusErr   *02 Bus Error
00000584= 00000994                 390      DC.L    handleAddrErr  *03 Address Error
00000588= 000009B0                 391      DC.L    handleIllInst  *04 Illegal Instruction
0000058C= 000009BC                 392      DC.L    handleZeroDiv  *05 Zero Divide
00000590= 000009C8                 393      DC.L    handleChkInst  *06 CHK Instruction
00000594= 000009D4                 394      DC.L    handleTrapV    *07 TRAPV Instruction
00000598= 000009E0                 395      DC.L    handlePriv     *08 Privilege Violation
0000059C= 000009EC                 396      DC.L    handleTrace    *09 Trace
000005A0= 000009F8                 397      DC.L    handleLineA    *0A Line 1010 Emulator
000005A4= 00000A04                 398      DC.L    handleLineF    *0B Line 1111 Emulator
000005A8= 00000A10                 399      DC.L    handleRes1     *0C (Unassigned, Reserved)
000005AC= 00000A10                 400      DC.L    handleRes2     *0D (Unassigned, Reserved)
000005B0= 00000A10                 401      DC.L    handleRes3     *0E (Unassigned, Reserved)
000005B4= 00000A1C                 402      DC.L    handleUnInit   *0F Uninitialized Interrupt Vector
000005B8= 00000A10                 403      DC.L    handleRes4     *10 (Unassigned, Reserved)
000005BC= 00000A10                 404      DC.L    handleRes5     *11 (Unassigned, Reserved)
000005C0= 00000A10                 405      DC.L    handleRes6     *12 (Unassigned, Reserved)
000005C4= 00000A10                 406      DC.L    handleRes7     *13 (Unassigned, Reserved)
000005C8= 00000A10                 407      DC.L    handleRes8     *14 (Unassigned, Reserved)
000005CC= 00000A10                 408      DC.L    handleRes9     *15 (Unassigned, Reserved)
000005D0= 00000A10                 409      DC.L    handleRes10    *16 (Unassigned, Reserved)
000005D4= 00000A10                 410      DC.L    handleRes11    *17 (Unassigned, Reserved)
000005D8= 00000A28                 411      DC.L    handleSpur     *18 Spurious Interrupt
000005DC= 00000A34                 412      DC.L    handleAV1      *19 Level 1 Interrupt Autovector
000005E0= 00000A40                 413      DC.L    handleAV2      *1A Level 2 Interrupt Autovector
000005E4= 00000A4C                 414      DC.L    handleAV3      *1B Level 3 Interrupt Autovector
000005E8= 00000A58                 415      DC.L    handleAV4      *1C Level 4 Interrupt Autovector
000005EC= 00000A64                 416      DC.L    handleAV5      *1D Level 5 Interrupt Autovector
000005F0= 00000A70                 417      DC.L    handleAV6      *1E Level 6 Interrupt Autovector
000005F4= 00000A7C                 418      DC.L    handleAV7      *1F Level 7 Interrupt Autovector
000005F8= 00000A88                 419      DC.L    handleTrap0    *20 TRAP #0  Instruction Vector
000005FC= 00000A94                 420      DC.L    handleTrap1    *21 TRAP #1  Instruction Vector
00000600= 00000AA0                 421      DC.L    handleTrap2    *22 TRAP #2  Instruction Vector
00000604= 00000AAC                 422      DC.L    handleTrap3    *23 TRAP #3  Instruction Vector
00000608= 00000AB8                 423      DC.L    handleTrap4    *24 TRAP #4  Instruction Vector
0000060C= 00000AC4                 424      DC.L    handleTrap5    *25 TRAP #5  Instruction Vector
00000610= 00000AD0                 425      DC.L    handleTrap6    *26 TRAP #6  Instruction Vector
00000614= 00000ADC                 426      DC.L    handleTrap7    *27 TRAP #7  Instruction Vector
00000618= 00000AE8                 427      DC.L    handleTrap8    *28 TRAP #8  Instruction Vector
0000061C= 00000AF4                 428      DC.L    handleTrap9    *29 TRAP #9  Instruction Vector
00000620= 00000B00                 429      DC.L    handleTrap10   *2A TRAP #10 Instruction Vector
00000624= 00000B0C                 430      DC.L    handleTrap11   *2B TRAP #11 Instruction Vector
00000628= 00000B18                 431      DC.L    handleTrap12   *2C TRAP #12 Instruction Vector
0000062C= 00000B24                 432      DC.L    handleTrap13   *2D TRAP #13 Instruction Vector
00000630= 00000B30                 433      DC.L    handleTrap14   *2E TRAP #14 Instruction Vector
00000634= 00000B3C                 434      DC.L    handleTrap15   *2F TRAP #15 Instruction Vector
00000638                           435  
00000638= 00000B48 00000B48 ...    436      DCB.L   208,handleUnused
00000978                           437  
00000978                           438  *------------------------------------------------------------------------------
00000978                           439  * Below are the actual exception handlers that are accessed from the vector
00000978                           440  * table in RAM. The user can overwrite any of the RAM vector table addresses
00000978                           441  * with the address of their own exception handler. These handlers simply output
00000978                           442  * a message to the serial port and enter an endless loop.
00000978                           443  *------------------------------------------------------------------------------
00000978                           444  
00000978                           445  *------------------------------------------------------------------------------
00000978                           446  * BUS ERROR handler
00000978                           447  * Print a message showing the PC and address being accessed
00000978                           448  *------------------------------------------------------------------------------
00000978                           449  handleBusErr:
00000978  41FA 0402                450      lea     bemsg1(PC), a0  * first message
0000097C  6100 0F36                451      bsr.w   putString
00000980  202F 000A                452      move.l  10(a7),d0       * get the program counter 
00000984  6100 0EEA                453      bsr.w   writeAddr32
00000988                           454      
00000988  41FA 0431                455      lea     bemsg2(PC), a0  * second message
0000098C  6100 0F26                456      bsr.w   putString
00000990  6000 01C2                457      bra.w   handleCleanUp
00000994                           458      
00000994                           459  *------------------------------------------------------------------------------
00000994                           460  * ADDRESS ERROR handler
00000994                           461  * Print a message showing the PC and address being accessed
00000994                           462  *------------------------------------------------------------------------------
00000994                           463  handleAddrErr:
00000994  41FA 01CC                464      lea     aemsg1(PC), a0  * first message
00000998  6100 0F1A                465      bsr.w   putString
0000099C  202F 000A                466      move.l  10(a7),d0       * get the program counter 
000009A0  6100 0ECE                467      bsr.w   writeAddr32
000009A4                           468      
000009A4  41FA 0200                469      lea     aemsg2(PC), a0  * second message
000009A8  6100 0F0A                470      bsr.w   putString
000009AC  6000 01A6                471      bra.w   handleCleanUp
000009B0                           472      
000009B0                           473  *------------------------------------------------------------------------------
000009B0                           474  * ILLEGAL INSTRUCTION handler
000009B0                           475  *------------------------------------------------------------------------------
000009B0                           476  handleIllInst:
000009B0  41FA 0468                477      lea     iimsg(PC), a0   * display message
000009B4  6100 0EFE                478      bsr.w   putString
000009B8  6000 019A                479      bra.w   handleCleanUp
000009BC                           480      
000009BC                           481  *------------------------------------------------------------------------------
000009BC                           482  * DIVISION BY ZERO handler
000009BC                           483  *------------------------------------------------------------------------------
000009BC                           484  handleZeroDiv:
000009BC  41FA 0985                485      lea     zdmsg(PC), a0   * display message
000009C0  6100 0EF2                486      bsr.w   putString
000009C4  6000 018E                487      bra.w   handleCleanUp
000009C8                           488      
000009C8                           489  *------------------------------------------------------------------------------
000009C8                           490  * CHK handler
000009C8                           491  *------------------------------------------------------------------------------
000009C8                           492  handleChkInst:
000009C8  41FA 0423                493      lea     cimsg(PC), a0   * display message
000009CC  6100 0EE6                494      bsr.w   putString
000009D0  6000 0182                495      bra.w   handleCleanUp
000009D4                           496      
000009D4                           497  *------------------------------------------------------------------------------
000009D4                           498  * TRAPV handler
000009D4                           499  *------------------------------------------------------------------------------
000009D4                           500  handleTrapV:
000009D4  41FA 08CF                501      lea     tvmsg(PC), a0   * display message
000009D8  6100 0EDA                502      bsr.w   putString
000009DC  6000 0176                503      bra.w   handleCleanUp
000009E0                           504      
000009E0                           505  *------------------------------------------------------------------------------
000009E0                           506  * PRIVILEGE VIOLATION handler
000009E0                           507  *------------------------------------------------------------------------------
000009E0                           508  handlePriv:
000009E0  41FA 04D3                509      lea     pvmsg(PC), a0   * display message
000009E4  6100 0ECE                510      bsr.w   putString
000009E8  6000 016A                511      bra.w   handleCleanUp
000009EC                           512      
000009EC                           513  *------------------------------------------------------------------------------
000009EC                           514  * TRACE handler
000009EC                           515  *------------------------------------------------------------------------------
000009EC                           516  handleTrace:
000009EC  41FA 0572                517      lea     trmsg(PC), a0   * display message
000009F0  6100 0EC2                518      bsr.w   putString
000009F4  6000 015E                519      bra.w   handleCleanUp
000009F8                           520      
000009F8                           521  *------------------------------------------------------------------------------
000009F8                           522  * Unimplementd Instruction - Line A handler
000009F8                           523  *------------------------------------------------------------------------------
000009F8                           524  handleLineA:
000009F8  41FA 045B                525      lea     lamsg(PC), a0   * display message
000009FC  6100 0EB6                526      bsr.w   putString
00000A00  6000 0152                527      bra.w   handleCleanUp
00000A04                           528      
00000A04                           529  *------------------------------------------------------------------------------
00000A04                           530  * Unimplementd Instruction - Line F handler
00000A04                           531  *------------------------------------------------------------------------------
00000A04                           532  handleLineF:
00000A04  41FA 047F                533      lea     lfmsg(PC), a0   * display message
00000A08  6100 0EAA                534      bsr.w   putString
00000A0C  6000 0146                535      bra.w   handleCleanUp
00000A10                           536      
00000A10                           537  *------------------------------------------------------------------------------
00000A10                           538  * Reserved Instruction handler
00000A10                           539  *------------------------------------------------------------------------------
00000A10                           540  handleRes1:
00000A10                           541  handleRes2:
00000A10                           542  handleRes3:
00000A10                           543  handleRes4:
00000A10                           544  handleRes5:
00000A10                           545  handleRes6:
00000A10                           546  handleRes7:
00000A10                           547  handleRes8:
00000A10                           548  handleRes9:
00000A10                           549  handleRes10:
00000A10                           550  handleRes11:
00000A10  41FA 04E0                551      lea     rimsg(PC), a0   * display message
00000A14  6100 0E9E                552      bsr.w   putString
00000A18  6000 013A                553      bra.w   handleCleanUp
00000A1C                           554      
00000A1C                           555  *------------------------------------------------------------------------------
00000A1C                           556  * Uninitialised Interrupt handler
00000A1C                           557  *------------------------------------------------------------------------------
00000A1C                           558  handleUnInit:
00000A1C  41FA 08B6                559      lea     uimsg(PC), a0   * display message
00000A20  6100 0E92                560      bsr.w   putString
00000A24  6000 012E                561      bra.w   handleCleanUp
00000A28                           562      
00000A28                           563  *------------------------------------------------------------------------------
00000A28                           564  * Spurious Interrupt handler
00000A28                           565  *------------------------------------------------------------------------------
00000A28                           566  handleSpur:
00000A28  41FA 04FA                567      lea     simsg(PC), a0   * display message
00000A2C  6100 0E86                568      bsr.w   putString
00000A30  6000 0122                569      bra.w   handleCleanUp
00000A34                           570      
00000A34                           571  *------------------------------------------------------------------------------
00000A34                           572  * Autovector Level 1 Exception handler
00000A34                           573  *------------------------------------------------------------------------------
00000A34                           574  handleAV1:
00000A34  41FA 01A2                575      lea     av1msg(PC), a0  * display message
00000A38  6100 0E7A                576      bsr.w   putString
00000A3C  6000 0116                577      bra.w   handleCleanUp
00000A40                           578  
00000A40                           579  *------------------------------------------------------------------------------
00000A40                           580  * Autovector Level 2 Exception handler
00000A40                           581  *------------------------------------------------------------------------------
00000A40                           582  handleAV2:
00000A40  41FA 01D2                583      lea     av2msg(PC), a0  * display message
00000A44  6100 0E6E                584      bsr.w   putString
00000A48  6000 010A                585      bra.w   handleCleanUp
00000A4C                           586  
00000A4C                           587  *------------------------------------------------------------------------------
00000A4C                           588  * Autovector Level 3 Exception handler
00000A4C                           589  *------------------------------------------------------------------------------
00000A4C                           590  handleAV3:
00000A4C  41FA 0202                591      lea     av3msg(PC), a0  * display message
00000A50  6100 0E62                592      bsr.w   putString
00000A54  6000 00FE                593      bra.w   handleCleanUp
00000A58                           594  
00000A58                           595  *------------------------------------------------------------------------------
00000A58                           596  * Autovector Level 4 Exception handler
00000A58                           597  *------------------------------------------------------------------------------
00000A58                           598  handleAV4:
00000A58  41FA 0232                599      lea     av4msg(PC), a0  * display message
00000A5C  6100 0E56                600      bsr.w   putString
00000A60  6000 00F2                601      bra.w   handleCleanUp
00000A64                           602  
00000A64                           603  *------------------------------------------------------------------------------
00000A64                           604  * Autovector Level 5 Exception handler
00000A64                           605  *------------------------------------------------------------------------------
00000A64                           606  handleAV5:
00000A64  41FA 0262                607      lea     av5msg(PC), a0  * display message
00000A68  6100 0E4A                608      bsr.w   putString
00000A6C  6000 00E6                609      bra.w   handleCleanUp
00000A70                           610  
00000A70                           611  *------------------------------------------------------------------------------
00000A70                           612  * Autovector Level 6 Exception handler
00000A70                           613  *------------------------------------------------------------------------------
00000A70                           614  handleAV6:
00000A70  41FA 0292                615      lea     av6msg(PC), a0  * display message
00000A74  6100 0E3E                616      bsr.w   putString
00000A78  6000 00DA                617      bra.w   handleCleanUp
00000A7C                           618  
00000A7C                           619  *------------------------------------------------------------------------------
00000A7C                           620  * Autovector Level 7 Exception handler
00000A7C                           621  *------------------------------------------------------------------------------
00000A7C                           622  handleAV7:
00000A7C  41FA 02C2                623      lea     av7msg(PC), a0  * display message
00000A80  6100 0E32                624      bsr.w   putString
00000A84  6000 00CE                625      bra.w   handleCleanUp
00000A88                           626      
00000A88                           627  *------------------------------------------------------------------------------
00000A88                           628  * TRAP #0 Exception handler
00000A88                           629  *------------------------------------------------------------------------------
00000A88                           630  handleTrap0:
00000A88  41FA 0505                631      lea     tr0msg(PC), a0  * display message
00000A8C  6100 0E26                632      bsr.w   putString
00000A90  6000 00C2                633      bra.w   handleCleanUp
00000A94                           634  
00000A94                           635  *------------------------------------------------------------------------------
00000A94                           636  * TRAP #1 Exception handler
00000A94                           637  *------------------------------------------------------------------------------
00000A94                           638  handleTrap1:
00000A94  41FA 052A                639      lea     tr1msg(PC), a0  * display message
00000A98  6100 0E1A                640      bsr.w   putString
00000A9C  6000 00B6                641      bra.w   handleCleanUp
00000AA0                           642  
00000AA0                           643  *------------------------------------------------------------------------------
00000AA0                           644  * TRAP #2 Exception handler
00000AA0                           645  *------------------------------------------------------------------------------
00000AA0                           646  handleTrap2:
00000AA0  41FA 054F                647      lea     tr2msg(PC), a0  * display message
00000AA4  6100 0E0E                648      bsr.w   putString
00000AA8  6000 00AA                649      bra.w   handleCleanUp
00000AAC                           650  
00000AAC                           651  *------------------------------------------------------------------------------
00000AAC                           652  * TRAP #3 Exception handler
00000AAC                           653  *------------------------------------------------------------------------------
00000AAC                           654  handleTrap3:
00000AAC  41FA 0574                655      lea     tr3msg(PC), a0  * display message
00000AB0  6100 0E02                656      bsr.w   putString
00000AB4  6000 009E                657      bra.w   handleCleanUp
00000AB8                           658  
00000AB8                           659  *------------------------------------------------------------------------------
00000AB8                           660  * TRAP #4 Exception handler
00000AB8                           661  *------------------------------------------------------------------------------
00000AB8                           662  handleTrap4:
00000AB8  41FA 0599                663      lea     tr4msg(PC), a0  * display message
00000ABC  6100 0DF6                664      bsr.w   putString
00000AC0  6000 0092                665      bra.w   handleCleanUp
00000AC4                           666  
00000AC4                           667  *------------------------------------------------------------------------------
00000AC4                           668  * TRAP #5 Exception handler
00000AC4                           669  *------------------------------------------------------------------------------
00000AC4                           670  handleTrap5:
00000AC4  41FA 05BE                671      lea     tr5msg(PC), a0  * display message
00000AC8  6100 0DEA                672      bsr.w   putString
00000ACC  6000 0086                673      bra.w   handleCleanUp
00000AD0                           674  
00000AD0                           675  *------------------------------------------------------------------------------
00000AD0                           676  * TRAP #6 Exception handler
00000AD0                           677  *------------------------------------------------------------------------------
00000AD0                           678  handleTrap6:
00000AD0  41FA 05E3                679      lea     tr6msg(PC), a0  * display message
00000AD4  6100 0DDE                680      bsr.w   putString
00000AD8  6000 007A                681      bra.w   handleCleanUp
00000ADC                           682  
00000ADC                           683  *------------------------------------------------------------------------------
00000ADC                           684  * TRAP #7 Exception handler
00000ADC                           685  *------------------------------------------------------------------------------
00000ADC                           686  handleTrap7:
00000ADC  41FA 0608                687      lea     tr7msg(PC), a0  * display message
00000AE0  6100 0DD2                688      bsr.w   putString
00000AE4  6000 006E                689      bra.w   handleCleanUp
00000AE8                           690  
00000AE8                           691  *------------------------------------------------------------------------------
00000AE8                           692  * TRAP #8 Exception handler
00000AE8                           693  *------------------------------------------------------------------------------
00000AE8                           694  handleTrap8:
00000AE8  41FA 062D                695      lea     tr8msg(PC), a0  * display message
00000AEC  6100 0DC6                696      bsr.w   putString
00000AF0  6000 0062                697      bra.w   handleCleanUp
00000AF4                           698  
00000AF4                           699  *------------------------------------------------------------------------------
00000AF4                           700  * TRAP #9 Exception handler
00000AF4                           701  *------------------------------------------------------------------------------
00000AF4                           702  handleTrap9:
00000AF4  41FA 0652                703      lea     tr9msg(PC), a0  * display message
00000AF8  6100 0DBA                704      bsr.w   putString
00000AFC  6000 0056                705      bra.w   handleCleanUp
00000B00                           706  
00000B00                           707  *------------------------------------------------------------------------------
00000B00                           708  * TRAP #10 Exception handler
00000B00                           709  *------------------------------------------------------------------------------
00000B00                           710  handleTrap10:
00000B00  41FA 0677                711      lea     tr10msg(PC), a0 * display message
00000B04  6100 0DAE                712      bsr.w   putString
00000B08  6000 004A                713      bra.w   handleCleanUp
00000B0C                           714  
00000B0C                           715  *------------------------------------------------------------------------------
00000B0C                           716  * TRAP #11 Exception handler
00000B0C                           717  *------------------------------------------------------------------------------
00000B0C                           718  handleTrap11:
00000B0C  41FA 069D                719      lea     tr11msg(PC), a0 * display message
00000B10  6100 0DA2                720      bsr.w   putString
00000B14  6000 003E                721      bra.w   handleCleanUp
00000B18                           722  
00000B18                           723  *------------------------------------------------------------------------------
00000B18                           724  * TRAP #12 Exception handler
00000B18                           725  *------------------------------------------------------------------------------
00000B18                           726  handleTrap12:
00000B18  41FA 06C3                727      lea     tr12msg(PC), a0 * display message
00000B1C  6100 0D96                728      bsr.w   putString
00000B20  6000 0032                729      bra.w   handleCleanUp
00000B24                           730      
00000B24                           731  *------------------------------------------------------------------------------
00000B24                           732  * TRAP #13 Exception handler
00000B24                           733  *------------------------------------------------------------------------------
00000B24                           734  handleTrap13:
00000B24  41FA 06E9                735      lea     tr13msg(PC), a0 * display message
00000B28  6100 0D8A                736      bsr.w   putString
00000B2C  6000 0026                737      bra.w   handleCleanUp
00000B30                           738      
00000B30                           739  *------------------------------------------------------------------------------
00000B30                           740  * TRAP #14 Exception handler
00000B30                           741  *------------------------------------------------------------------------------
00000B30                           742  handleTrap14:
00000B30  41FA 070F                743      lea     tr14msg(PC), a0 * display message
00000B34  6100 0D7E                744      bsr.w   putString
00000B38  6000 001A                745      bra.w   handleCleanUp
00000B3C                           746      
00000B3C                           747  *------------------------------------------------------------------------------
00000B3C                           748  * TRAP #15 Exception handler
00000B3C                           749  *------------------------------------------------------------------------------
00000B3C                           750  handleTrap15:
00000B3C  41FA 0735                751      lea     tr15msg(PC), a0 * display message
00000B40  6100 0D72                752      bsr.w   putString
00000B44  6000 000E                753      bra.w   handleCleanUp
00000B48                           754      
00000B48                           755  *------------------------------------------------------------------------------
00000B48                           756  * User Exception handler - all remaining exception handlers land here
00000B48                           757  *------------------------------------------------------------------------------
00000B48                           758  handleUnused:
00000B48  41FA 07CB                759      lea     usermsg(PC), a0 * display message
00000B4C  6100 0D66                760      bsr.w   putString
00000B50  6000 0002                761      bra.w   handleCleanUp
00000B54                           762      
00000B54                           763  *------------------------------------------------------------------------------
00000B54                           764  * All exception handlers jump here to output the PC of the next instruction
00000B54                           765  * after the exception occured.
00000B54                           766  *------------------------------------------------------------------------------
00000B54                           767  handleCleanUp:
00000B54  202F 0002                768      move.l  2(a7),d0        * get the address
00000B58  6100 0D16                769      bsr.w   writeAddr32
00000B5C  6100 0D52                770      bsr.w   putCRLF
00000B60                           771  .infloop:
00000B60  60FE                     772      bra.s   .infloop
00000B62                           773  
00000B62                           774  *------------------------------------------------------------------------------
00000B62                           775  * Exception handler messages
00000B62                           776  *------------------------------------------------------------------------------
00000B62= 0A 0D 53 54 4F 50 ...    777  aemsg1:  dc.b   10,13,'STOP: An Address Error occured whilst executing code at address $',0
00000BA6= 0A 0D 53 54 4F 50 ...    778  aemsg2:  dc.b   10,13,'STOP: The address location being accessed was $',0
00000BD8= 0A 0D 53 54 4F 50 ...    779  av1msg:  dc.b   10,13,'STOP: Autovector Level 1 exception occured near address $',0
00000C14= 0A 0D 53 54 4F 50 ...    780  av2msg:  dc.b   10,13,'STOP: Autovector Level 2 exception occured near address $',0
00000C50= 0A 0D 53 54 4F 50 ...    781  av3msg:  dc.b   10,13,'STOP: Autovector Level 3 exception occured near address $',0
00000C8C= 0A 0D 53 54 4F 50 ...    782  av4msg:  dc.b   10,13,'STOP: Autovector Level 4 exception occured near address $',0
00000CC8= 0A 0D 53 54 4F 50 ...    783  av5msg:  dc.b   10,13,'STOP: Autovector Level 5 exception occured near address $',0
00000D04= 0A 0D 53 54 4F 50 ...    784  av6msg:  dc.b   10,13,'STOP: Autovector Level 6 exception occured near address $',0
00000D40= 0A 0D 53 54 4F 50 ...    785  av7msg:  dc.b   10,13,'STOP: Autovector Level 7 exception occured near address $',0
00000D7C= 0A 0D 53 54 4F 50 ...    786  bemsg1:  dc.b   10,13,'STOP: A Bus Error occured whilst executing code at address $',0
00000DBB= 0A 0D 20 20 20 20 ...    787  bemsg2:  dc.b   10,13,'    : The address location being accessed was $',0
00000DED= 0A 0D 53 54 4F 50 ...    788  cimsg:   dc.b   10,13,'STOP: CHK exception occured near address $',0
00000E1A= 0A 0D 53 54 4F 50 ...    789  iimsg:   dc.b   10,13,'STOP: Illegal Instruction was encountered near address $',0
00000E55= 0A 0D 53 54 4F 50 ...    790  lamsg:   dc.b   10,13,'STOP: LINE A exception occured near address $',0
00000E85= 0A 0D 53 54 4F 50 ...    791  lfmsg:   dc.b   10,13,'STOP: LINE F exception occured near address $',0
00000EB5= 0A 0D 53 54 4F 50 ...    792  pvmsg:   dc.b   10,13,'STOP: Privilege Viloation exception occured near address $',0
00000EF2= 0A 0D 53 54 4F 50 ...    793  rimsg:   dc.b   10,13,'STOP: Reserved exception occured near address $',0
00000F24= 0A 0D 53 54 4F 50 ...    794  simsg:   dc.b   10,13,'STOP: Spurious Interrupt exception occured near address $',0
00000F60= 0A 0D 53 54 4F 50 ...    795  trmsg:   dc.b   10,13,'STOP: TRACE exception occured near address $',0
00000F8F= 0A 0D 53 54 4F 50 ...    796  tr0msg:  dc.b   10,13,'STOP: TRAP #0 exception occured near address $',0
00000FC0= 0A 0D 53 54 4F 50 ...    797  tr1msg:  dc.b   10,13,'STOP: TRAP #1 exception occured near address $',0
00000FF1= 0A 0D 53 54 4F 50 ...    798  tr2msg:  dc.b   10,13,'STOP: TRAP #2 exception occured near address $',0
00001022= 0A 0D 53 54 4F 50 ...    799  tr3msg:  dc.b   10,13,'STOP: TRAP #3 exception occured near address $',0
00001053= 0A 0D 53 54 4F 50 ...    800  tr4msg:  dc.b   10,13,'STOP: TRAP #4 exception occured near address $',0
00001084= 0A 0D 53 54 4F 50 ...    801  tr5msg:  dc.b   10,13,'STOP: TRAP #5 exception occured near address $',0
000010B5= 0A 0D 53 54 4F 50 ...    802  tr6msg:  dc.b   10,13,'STOP: TRAP #6 exception occured near address $',0
000010E6= 0A 0D 53 54 4F 50 ...    803  tr7msg:  dc.b   10,13,'STOP: TRAP #7 exception occured near address $',0
00001117= 0A 0D 53 54 4F 50 ...    804  tr8msg:  dc.b   10,13,'STOP: TRAP #8 exception occured near address $',0
00001148= 0A 0D 53 54 4F 50 ...    805  tr9msg:  dc.b   10,13,'STOP: TRAP #9 exception occured near address $',0
00001179= 0A 0D 53 54 4F 50 ...    806  tr10msg: dc.b   10,13,'STOP: TRAP #10 exception occured near address $',0
000011AB= 0A 0D 53 54 4F 50 ...    807  tr11msg: dc.b   10,13,'STOP: TRAP #11 exception occured near address $',0
000011DD= 0A 0D 53 54 4F 50 ...    808  tr12msg: dc.b   10,13,'STOP: TRAP #12 exception occured near address $',0
0000120F= 0A 0D 53 54 4F 50 ...    809  tr13msg: dc.b   10,13,'STOP: TRAP #13 exception occured near address $',0
00001241= 0A 0D 53 54 4F 50 ...    810  tr14msg: dc.b   10,13,'STOP: TRAP #14 exception occured near address $',0
00001273= 0A 0D 53 54 4F 50 ...    811  tr15msg: dc.b   10,13,'STOP: TRAP #15 exception occured near address $',0
000012A5= 0A 0D 53 54 4F 50 ...    812  tvmsg:   dc.b   10,13,'STOP: TRAPV exception occured near address $',0
000012D4= 0A 0D 53 54 4F 50 ...    813  uimsg:   dc.b   10,13,'STOP: Uninitialised Interrupt exception occured near address $',0
00001315= 0A 0D 53 54 4F 50 ...    814  usermsg: dc.b   10,13,'STOP: User exception occured near address $',0
00001343= 0A 0D 53 54 4F 50 ...    815  zdmsg:   dc.b   10,13,'STOP: Divide By Zero error occured near address $',0
00001377                           816  
00001377                           817  * #############################################################################
00001377                           818  * #############################################################################
00001377                           819  * C O L D   S T A R T
00001377                           820  * #############################################################################
00001377                           821  * #############################################################################
00001377                           822  
00001378                           823      ORG     (*+1)&-2    * make we start on a word aligned address
00001378                           824  START:
00001378  4FF9 001FFF00            825      lea     STACK_START, sp     * Set the stack pointer just in case
0000137E                           826  
0000137E                           827      * copy the exception vector table into RAM
0000137E  207C 00000578            828      move.l  #rom2ramIVT,a0      * start of exception table in ROM
00001384  227C 00100000            829      move.l  #VEC_BASE,a1        * location in RAM to copy table to
0000138A  203C 00000100            830      move.l  #256,d0             * 256 entries to copy
00001390                           831  .copy:
00001390  22D8                     832      move.l  (a0)+,(a1)+     * copy the byte from ROM to RAM
00001392  51C8 FFFC                833      dbra    d0,.copy
00001396                           834  
00001396                           835  *------------------------------------------------------------------------------
00001396                           836  * Initialise the SCC68692 DUART port A
00001396                           837  *------------------------------------------------------------------------------
00001396                           838  
00001396  13FC 0030 00F00185       839      move.b  #$30, CRA       * Reset Transmitter
0000139E  13FC 0020 00F00185       840      move.b  #$20, CRA       * Reset Reciever
000013A6  13FC 0010 00F00185       841      move.b  #$10, CRA       * Reset Mode Register Pointer
000013AE                           842      
000013AE  13FC 0000 00F00189       843      move.b  #$00, ACR       * Baud Rate Set #1
000013B6  13FC 0013 00F00181       844      move.b  #$13, MRA       * No Parity & 8-bit
000013BE  13FC 0007 00F00181       845      move.b  #$07, MRA       * Normal Mode, No CTS/RTS & 1 stop bit
000013C6  13FC 00CC 00F00183       846      move.b  #BAUD_RATE, CSRA      * Set Tx and Rx baud rates
000013CE  13FC 0000 00F0018B       847      move.b  #$00, IMR       * No interrupts
000013D6  13FC 0005 00F00185       848      move.b  #$05, CRA       * Enable Transmit/Recieve
000013DE  13FC 0003 00F0019D       849      move.b  #$03, SOPR      * Turn off the 2 user LEDs on OP0 & OP1
000013E6                           850  
000013E6                 FALSE     851      iflt USE_REAL_UART
000013E6                           852      ; using Sim68K COM port
000013E6                           853      ; initialise the serial port
000013E6                           854      ; set port parameters
000013E6                           855      endc
000013E6                           856  *------------------------------------------------------------------------------
000013E6                           857  * Warm Restart entry point
000013E6                           858  *------------------------------------------------------------------------------
000013E6                           859  monStart:
000013E6  41FA 0504                860      lea     strBanner1(PC), a0  * Show the monitor details
000013EA  6100 04C8                861      bsr.w   putString
000013EE                           862  
000013EE  41FA 055A                863      lea     strCommands(PC), a0 * And the command help message
000013F2  6100 04C0                864      bsr.w   putString
000013F6                           865  
000013F6                           866  monLoop:
000013F6  41FA 06BF                867      lea     strPrompt(PC), a0   * Prompt
000013FA  6100 04B8                868      bsr.w   putString
000013FE                           869  
000013FE                           870  monLoop_NP:
000013FE  6100 04D0                871      bsr.w   getc            * get a character into D0
00001402  6100 02CE                872      bsr.w   chToUpper       * convert character to upper case
00001406                           873      
00001406  0C00 000A                874      cmpi.b  #LF,d0          * ignore Line-Feed
0000140A  67EA                     875      beq.s   monLoop
0000140C                           876      
0000140C  B03C 0044                877      cmp.b   #'D', d0        * Dump memory command
00001410  6700 004E                878      beq.w   cmdDispMemory
00001414                           879  
00001414  B03C 0049                880      cmp.b   #'I', d0        * Read from I/O space address
00001418  6700 0088                881      beq.w   cmdIORead
0000141C                           882  
0000141C  B03C 004D                883      cmp.b   #'M', d0        * Modify memory command
00001420  6700 00C2                884      beq.w   cmdModifyMemory
00001424                           885  
00001424  B03C 004F                886      cmp.b   #'O', d0        * Write to I/O space address
00001428  6700 0118                887      beq.w   cmdIOWrite
0000142C                           888  
0000142C  B03C 0053                889      cmp.b   #'S', d0        * S record download
00001430  6700 015A                890      beq.w   cmdDownload
00001434                           891  
00001434  B03C 0047                892      cmp.b   #'G', d0        * Go command
00001438  6700 0048                893      beq.w   cmdRun
0000143C                           894  
0000143C  B03C 003F                895      cmp.b   #'?', d0        * Help command
00001440  6700 021E                896      beq.w   cmdHelp
00001444                           897  
00001444  B03C 0020                898      cmp.b   #' ', d0        * Ignore spaces
00001448  6FB4                     899      ble.s   monLoop_NP      * go back without printing prompt    
0000144A                           900  
0000144A  1200                     901      move.b  d0,d1           * save the unknown char
0000144C  41FA 066C                902      lea     strUnkCmd(PC), a0   * unknown command
00001450  6100 0462                903      bsr.w   putString
00001454  1001                     904      move.b  d1,d0           * get unnknown char back
00001456  6100 0436                905      bsr.w   writeByte       * print it
0000145A                           906  
0000145A                           907  monLoop_CRLF:
0000145A  6100 0454                908      bsr.w   putCRLF
0000145E  6096                     909      bra.s   monLoop
00001460                           910      
00001460                           911  *------------------------------------------------------------------------------
00001460                           912  * (D)ump memory
00001460                           913  * Display 256 bytes of memory as ASCII-HEX characters
00001460                           914  *------------------------------------------------------------------------------
00001460                           915  cmdDispMemory:
00001460  6100 045C                916      bsr.w   putc            * echo back the command character in D0
00001464  103C 0020                917      move.b  #' ',d0
00001468  6100 0454                918      bsr.w   putc
0000146C                           919      
0000146C  4282                     920      clr.l   d2              * pre-set D2 to 0
0000146E  7208                     921      move.l  #8,d1           * read up to 8 digits
00001470  6100 02BE                922      bsr.w   hexToIntEcho    * from the serial port into D0
00001474  6500 FF80                923      bcs.w   monLoop         * back to prompt if there's an error
00001478                           924      
00001478  2040                     925      move.l  d0,a0           * A0 holds the start address
0000147A  6100 01F0                926      bsr.w   dumpRAM
0000147E                           927  
0000147E  6000 FF76                928      bra.w   monLoop
00001482                           929  
00001482                           930  *------------------------------------------------------------------------------
00001482                           931  * (G)o - execute code in memory starting at the specified address
00001482                           932  *------------------------------------------------------------------------------
00001482                           933  cmdRun:
00001482  6100 043A                934      bsr.w   putc            * echo back the command character in D0
00001486  103C 0020                935      move.b  #' ',d0
0000148A  6100 0432                936      bsr.w   putc
0000148E                           937  
0000148E  4282                     938      clr.l   d2              * pre-set D2 to 0
00001490  7208                     939      move.l  #8,d1           * read up to 8 digits
00001492  6100 029C                940      bsr.w   hexToIntEcho    * from the serial port
00001496  6500 FF5E                941      bcs.w   monLoop         * back to prompt if there's an error
0000149A                           942  
0000149A  2040                     943      move.l  d0, a0          * copy start address into A0
0000149C  4E90                     944      jsr     (a0)            * jump to user code 
0000149E  6000 FF56                945      bra.w   monLoop
000014A2                           946  
000014A2                           947  *------------------------------------------------------------------------------
000014A2                           948  * (I)nput a byte from I/O space address
000014A2                           949  *------------------------------------------------------------------------------
000014A2                           950  cmdIORead:
000014A2  6100 041A                951      bsr.w   putc            * echo back the command character in D0
000014A6  103C 0020                952      move.b  #' ',d0
000014AA  6100 0412                953      bsr.w   putc
000014AE                           954  
000014AE  4282                     955      clr.l   d2              * pre-set D2 to 0
000014B0  7202                     956      move.l  #2,d1           * read up to 2 digit address
000014B2  6100 027C                957      bsr.w   hexToIntEcho    * from the serial port
000014B6  6500 FF3E                958      bcs.w   monLoop         * back to prompt if there's an error
000014BA  1600                     959      move.b  d0,d3           * save the typed in 8-bit address
000014BC  103C 003D                960      move.b  #'=',d0
000014C0  6100 03FC                961      bsr.w   putc            * send an EQUALS
000014C4                           962  
000014C4                           963      ; D3 = 8-bit address
000014C4  207C 00F00000            964      movea.l #IO_BASE,a0
000014CA  0283 000000FF            965      andi.l  #$FF,d3         * clear all the unused bits
000014D0  E383                     966      asl.l   #1,d3           * make it a word offset
000014D2  5283                     967      addi.l  #1,d3           * make it an odd address to read from D0..D7
000014D4  1030 3000                968      move.b  (0,a0,d3),d0    * and read the new value in
000014D8  6100 03B4                969      bsr.w   writeByte       * display the value
000014DC  6100 03D2                970      bsr.w   putCRLF
000014E0  6000 FF14                971      bra.w   monLoop
000014E4                           972  
000014E4                           973  *------------------------------------------------------------------------------
000014E4                           974  * (M)odify memory
000014E4                           975  * Change memory contents 1 byte at a time
000014E4                           976  *------------------------------------------------------------------------------
000014E4                           977  cmdModifyMemory:
000014E4  6100 03D8                978      bsr.w   putc            * echo back the command character in D0
000014E8  103C 0020                979      move.b  #' ',d0
000014EC  6100 03D0                980      bsr.w   putc
000014F0                           981  
000014F0  4282                     982      clr.l   d2              * pre-set D2 to 0
000014F2  7208                     983      move.l  #8,d1           * read up to 8 digits
000014F4  6100 023A                984      bsr.w   hexToIntEcho    * from the serial port
000014F8  6500 FEFC                985      bcs.w   monLoop         * back to prompt if there's an error
000014FC  1200                     986      move.b  d0,d1           * save the typed in address
000014FE  6100 03B0                987      bsr.w   putCRLF
00001502  1001                     988      move.b  d1,d0           * restore the typed in address
00001504                           989      
00001504  2040                     990      move.l  d0,a0           * copy address into A0
00001506                           991  .cMM_1:
00001506  6100 0368                992      bsr.w   writeAddr32     * display the memory location address
0000150A  103C 0020                993      move.b  #' ',d0
0000150E  6100 03AE                994      bsr.w   putc
00001512  1010                     995      move.b  (a0),d0         * get the current memory contents
00001514  1400                     996      move.b  d0,d2           * pre-set D2 to the existing memory value
00001516  6100 0376                997      bsr.w   writeByte       * display the byte
0000151A  103C 0020                998      move.b  #' ',d0
0000151E  6100 039E                999      bsr.w   putc
00001522  7202                    1000      move.l  #2,d1           * read up to 2 digits
00001524  6100 020A               1001      bsr.w   hexToIntEcho    * from the serial port
00001528  6500 0010               1002      bcs.w   .cMM_2          * back to prompt if there's an error
0000152C                          1003  
0000152C  10C0                    1004      move.b  d0,(a0)+        * write out the new byte and move on
0000152E  2F08                    1005      move.l  a0,-(SP)        * save our address
00001530  6100 037E               1006      bsr.w   putCRLF
00001534  205F                    1007      move.l  (SP)+,a0        * restore our address
00001536  2008                    1008      move.l  a0,d0           * copy address back into D0 for printing
00001538  60CC                    1009      bra.s   .cMM_1
0000153A                          1010  
0000153A                          1011  .cMM_2:
0000153A  6100 0374               1012      bsr.w   putCRLF
0000153E  6000 FEB6               1013      bra.w   monLoop
00001542                          1014      
00001542                          1015  *------------------------------------------------------------------------------
00001542                          1016  * (O)utput a byte to I/O space address
00001542                          1017  *------------------------------------------------------------------------------
00001542                          1018  cmdIOWrite:
00001542  6100 037A               1019      bsr.w   putc            * echo back the command character in D0
00001546  103C 0020               1020      move.b  #' ',d0
0000154A  6100 0372               1021      bsr.w   putc
0000154E                          1022  
0000154E  4282                    1023      clr.l   d2              * pre-set D2 to 0
00001550  7202                    1024      move.l  #2,d1           * read up to 2 digit address
00001552  6100 01DC               1025      bsr.w   hexToIntEcho    * from the serial port
00001556  6500 FE9E               1026      bcs.w   monLoop         * back to prompt if there's an error
0000155A  1600                    1027      move.b  d0,d3           * save the typed in 8-bit address
0000155C  103C 003D               1028      move.b  #'=',d0
00001560  6100 035C               1029      bsr.w   putc            * send an EQUALS
00001564                          1030  
00001564  4282                    1031      clr.l   d2              * pre-set D2 to 0
00001566  7202                    1032      move.l  #2,d1           * read up to 2 digit value
00001568  6100 01C6               1033      bsr.w   hexToIntEcho    * from the serial port
0000156C  6500 FE88               1034      bcs.w   monLoop         * back to prompt if there's an error
00001570                          1035  
00001570                          1036      ; D0 = value and D3 = 8-bit address
00001570  207C 00F00000           1037      movea.l #IO_BASE,a0
00001576  0283 000000FF           1038      andi.l  #$FF,d3         * clear all the unused bits
0000157C  E383                    1039      asl.l   #1,d3           * make it a word offset
0000157E  5283                    1040      addi.l  #1,d3           * make it an odd address to write to D0..D7
00001580  1180 3000               1041      move.b  d0,(0,a0,d3)    * and write the new value out
00001584                          1042  
00001584  6100 032A               1043      bsr.w   putCRLF
00001588  6000 FE6C               1044      bra.w   monLoop
0000158C                          1045  
0000158C                          1046  *------------------------------------------------------------------------------
0000158C                          1047  * (S) - download a single line of a Motorola S-Record
0000158C                          1048  *------------------------------------------------------------------------------
0000158C                          1049  cmdDownload:
0000158C  6100 0342               1050      bsr.w   getc            * get the S-Record type
00001590  B03C 0031               1051      cmp.b   #'1', d0
00001594  671A                    1052      beq.s   .cdl_S1         * read in an S1 record
00001596  B03C 0032               1053      cmp.b   #'2', d0
0000159A  6738                    1054      beq.s   .cdl_S2         * read in an S2 record
0000159C  B03C 0038               1055      cmp.b   #'8', d0
000015A0  6700 00A8               1056      beq.w   .cdl_EOL89      * handle S8 SRec terminator
000015A4  B03C 0039               1057      cmp.b   #'9', d0
000015A8  6700 00A0               1058      beq.w   .cdl_EOL89      * handle S9 SRec terminator
000015AC                          1059  
000015AC  6600 008A               1060      bne     .cdl_EOL        * not S1 or S2 so ignore to end of line
000015B0                          1061              
000015B0                          1062  .cdl_S1:        
000015B0  4282                    1063      clr.l   d2
000015B2  123C 0002               1064      move.b  #2, d1          * 2 characters to read
000015B6  6100 013E               1065      bsr     hexToInt        * convert to byte count
000015BA  2C00                    1066      move.l  d0, d6          * D6 = byte count
000015BC  2E00                    1067      move.l  d0, d7          * D7 = byte count (running checksum)
000015BE                          1068  
000015BE  4282                    1069      clr.l   d2
000015C0  123C 0004               1070      move.b  #4, d1          * 4 characters to read
000015C4  6100 0130               1071      bsr     hexToInt        * convert to address
000015C8  2640                    1072      movea.l d0, a3          * A3 = destination address
000015CA  DE00                    1073      add.b   d0, d7          * update checksum with bits 00..07
000015CC  E088                    1074      lsr.l   #8, d0
000015CE  DE00                    1075      add.b   d0, d7          * update checksum with bits 08..15
000015D0                          1076  
000015D0  5746                    1077      subq.w  #3, D6          * take off the 3 bytes we just read in
000015D2                          1078  
000015D2  6026                    1079      bra.s   .cdl_1              
000015D4                          1080                  
000015D4                          1081  .cdl_S2:            
000015D4  4282                    1082      clr.l   d2
000015D6  123C 0002               1083      move.b  #2, d1          * 2 characters to read
000015DA  6100 011A               1084      bsr     hexToInt        * convert to byte count
000015DE  2C00                    1085      move.l  d0, d6          * D6 = byte count
000015E0  2E00                    1086      move.l  d0, d7          * D7 = byte count (running checksum)
000015E2                          1087  
000015E2  4282                    1088      clr.l   d2
000015E4  123C 0006               1089      move.b  #6, d1          * 6 characters to read
000015E8  6100 010C               1090      bsr     hexToInt        * convert to address
000015EC  2640                    1091      movea.l d0, a3          * A3 = destination address
000015EE  DE00                    1092      add.b   d0, d7          * update checksum with bits 00..07
000015F0  E088                    1093      lsr.l   #8, d0
000015F2  DE00                    1094      add.b   d0, d7          * update checksum with bits 08..15
000015F4  E088                    1095      lsr.l   #8, d0
000015F6  DE00                    1096      add.b   d0, d7          * update checksum with bits 16..23
000015F8                          1097  
000015F8  5946                    1098      subq.w  #4, d6          * take off the 4 bytes we just read in
000015FA                          1099  
000015FA                          1100  .cdl_1:
000015FA  4A46                    1101      tst.w   d6              * read all the bytes yet?
000015FC  6712                    1102      beq.s   .cdl_2
000015FE                          1103  
000015FE  4282                    1104      clr.l   d2
00001600  323C 0002               1105      move.w  #2, d1          * 2 characters to read
00001604  6100 00F0               1106      bsr     hexToInt        * convert to data byte
00001608  16C0                    1107      move.b  d0, (a3)+       * write the byte to memory
0000160A  DE00                    1108      add.b   d0, d7          * update checksum
0000160C  5346                    1109      subq.w  #1, d6          * decrement byte count
0000160E  60EA                    1110      bra.s   .cdl_1
00001610                          1111  
00001610                          1112  .cdl_2:
00001610  4282                    1113      clr.l   d2
00001612  323C 0002               1114      move.w  #2, d1          * 2 characters to read
00001616  6100 00DE               1115      bsr     hexToInt        * convert to checksum byte
0000161A  DE00                    1116      add.b   d0, d7          * D7 = calc checksum + srec checksum
0000161C  5207                    1117      addq.b  #1, d7          * checksum + 1 should = 0 if OK
0000161E  670C                    1118      beq.s   .cdl_X
00001620                          1119  
00001620  103C 0058               1120      move.b  #'X', d0        * checksum fail - print an X
00001624  6100 0298               1121      bsr     putc
00001628  6000 FDD4               1122      bra.w   monLoop_NP      * return to main loop without prompt
0000162C                          1123  
0000162C                          1124  .cdl_X
0000162C  103C 002E               1125      move.b  #'.', d0        * checksum good - print a dot
00001630  6100 028C               1126      bsr     putc
00001634  6000 FDC8               1127      bra.w   monLoop_NP      * return to main loop without prompt
00001638                          1128  
00001638                          1129  .cdl_EOL
00001638  6100 0296               1130      bsr.w   getc            * discard chars until CR or LF
0000163C  0C00 000D               1131      cmpi.b  #CR,d0
00001640  67EA                    1132      beq.s   .cdl_X
00001642  0C00 000A               1133      cmpi.b  #LF,d0
00001646  67E4                    1134      beq.s   .cdl_X
00001648  60EE                    1135      bra.s   .cdl_EOL
0000164A                          1136  
0000164A                          1137  .cdl_EOL89
0000164A  6100 0284               1138      bsr.w   getc            * discard chars until CR or LF
0000164E  0C00 000D               1139      cmpi.b  #CR,d0
00001652  6700 FE06               1140      beq.w   monLoop_CRLF    * return to main loop with prompt
00001656  0C00 000A               1141      cmpi.b  #LF,d0
0000165A  6700 FDFE               1142      beq.w   monLoop_CRLF    * return to main loop with prompt
0000165E  60EA                    1143      bra.s   .cdl_EOL89
00001660                          1144      
00001660                          1145  *------------------------------------------------------------------------------
00001660                          1146  * Display the supported commands
00001660                          1147  *------------------------------------------------------------------------------
00001660                          1148  cmdHelp:
00001660  41FA 02E8               1149      lea     strCommands(PC), a0
00001664  6100 024E               1150      bsr.w   putString
00001668  6000 FD8C               1151      bra.w   monLoop
0000166C                          1152  
0000166C                          1153  *------------------------------------------------------------------------------
0000166C                          1154  * Dumps a 256 section of RAM to the screen
0000166C                          1155  * Displays both hex values and ASCII characters
0000166C                          1156  * a0 - Start Address
0000166C                          1157  *------------------------------------------------------------------------------
0000166C                          1158  dumpRAM:
0000166C  48E7 E040               1159      movem.l d0-d2/a1, -(SP) * Save registers
00001670  2248                    1160      move.l  a0,a1           * move the start address to A1
00001672                          1161  
00001672  6100 023C               1162      bsr.w   putCRLF         * new line - trashes D0 & A0
00001676                          1163      
00001676  323C 000F               1164      move.w  #15,d1          * 16 rows of data (DBRA needs 1 less!)
0000167A                          1165  .dr_1:
0000167A  343C 000F               1166      move.w  #15,d2          * 16 bytes of data per row (DBRA needs 1 less!)
0000167E  2009                    1167      move.l  a1, d0          * copy the start address of the line into D0          
00001680  6100 01EE               1168      bsr.w   writeAddr32     * Display as a 32-bit hex value
00001684  41FA 0449               1169      lea     strColonSpace(PC), a0
00001688  6100 022A               1170      bsr.w   putString
0000168C  41F9 001FFF00           1171      lea     msgASCIIDump, a0
00001692                          1172  .dr_2:
00001692  1019                    1173      move.b  (a1)+, d0       * Read a byte from RAM
00001694  6100 01F8               1174      bsr.w   writeByte       * display byte as 2 hex digits  
00001698  6100 004A               1175      bsr.w   makePrintable   * convert to printable character
0000169C  10C0                    1176      move.b  d0,(a0)+        * save the printable char in output string
0000169E  103C 0020               1177      move.b  #' ', d0
000016A2  6100 021A               1178      bsr.w   putc            * insert a space
000016A6  51CA FFEA               1179      dbra    d2,.dr_2
000016AA                          1180  
000016AA  103C 0020               1181      move.b  #' ', d0
000016AE  6100 020E               1182      bsr.w   putc            * insert a space
000016B2                          1183  
000016B2  10FC 000D               1184      move.b  #CR,(a0)+
000016B6  10FC 000A               1185      move.b  #LF,(a0)+
000016BA  10FC 0000               1186      move.b  #0,(a0)+
000016BE  41F9 001FFF00           1187      lea     msgASCIIDump, a0
000016C4  6100 01EE               1188      bsr.w   putString       * print out the printable bytes
000016C8  51C9 FFB0               1189      dbra    d1,.dr_1
000016CC                          1190  
000016CC  4CDF 0207               1191      movem.l (SP)+, d0-d2/a1 * Restore registers
000016D0  4E75                    1192      rts
000016D2                          1193              
000016D2                          1194  *------------------------------------------------------------------------------
000016D2                          1195  * Convert character in D0 to upper case
000016D2                          1196  * Only changes D0 if char is between 'a'..'z'
000016D2                          1197  *------------------------------------------------------------------------------
000016D2                          1198  chToUpper:
000016D2  B03C 0061               1199      cmp.b   #'a', d0         
000016D6  6D0A                    1200      blt.s   .done            * less than lower-case 'a' so leave alone
000016D8  B03C 007A               1201      cmp.b   #'z', d0
000016DC  6E04                    1202      bgt.s   .done            * greater than lower-case 'z' so leave alone
000016DE  0400 0020               1203      sub.b   #$20, d0         * convert to upper case
000016E2                          1204  .done:
000016E2  4E75                    1205      rts
000016E4                          1206      
000016E4                          1207  *------------------------------------------------------------------------------
000016E4                          1208  * Convert a byte into a print safe character
000016E4                          1209  * Substitute a '.' for any byte <32 or >126
000016E4                          1210  * D0 holds the byte
000016E4                          1211  *------------------------------------------------------------------------------
000016E4                          1212  makePrintable:
000016E4  B03C 0020               1213      cmp.b   #' ', d0         
000016E8  6D06                    1214      blt.s   .mp_1           * less than a SPACE (char 32)
000016EA                          1215  
000016EA  B03C 007E               1216      cmp.b   #'~', d0         
000016EE  6F04                    1217      ble.s   .mp_x           * less than a DEL (char 127)
000016F0                          1218  
000016F0                          1219  .mp_1:
000016F0  103C 002E               1220      move.b  #'.',d0         * substitute a DOT (char 46)
000016F4                          1221  .mp_x:
000016F4  4E75                    1222      rts
000016F6                          1223      
000016F6                          1224  *--------------------------------------------------------------------------
000016F6                          1225  * Read in an ASCII-HEX number - no echo back
000016F6                          1226  *
000016F6                          1227  * D2 = Value to return if no digits read in
000016F6                          1228  * D1 = Max no of ASCII digits to read in
000016F6                          1229  * D0 = Result
000016F6                          1230  * Carry flag set if an error occurs / not ASCII-HEX digit
000016F6                          1231  *--------------------------------------------------------------------------
000016F6                          1232  hexToInt:
000016F6                          1233  *   move.l  d2,-(SP)        * save D2
000016F6                          1234  *   clr.l   d2              * D2 used to accumulate the final value
000016F6                          1235  .h2i_1:
000016F6  6100 01D8               1236      bsr.w   getc            * get a character
000016FA  61D6                    1237      bsr.s   chToUpper       * convert to upper case if needed
000016FC                          1238  
000016FC  0C00 000A               1239      cmpi.b  #10,d0          * finish if it's CR or LF
00001700  6724                    1240      beq.s   .h2i_x
00001702  0C00 000D               1241      cmpi.b  #13,d0
00001706  671E                    1242      beq.s   .h2i_x
00001708                          1243      
00001708  0400 0030               1244      subi.b  #'0',d0
0000170C  6B1C                    1245      bmi.s   .h2i_err        * quit if char is less than '0'
0000170E                          1246  
0000170E  0C00 0009               1247      cmpi.b  #9,d0
00001712  6F0A                    1248      ble.s   .h2i_2          * is it <= 9
00001714                          1249      
00001714  5F00                    1250      subi.b  #7,d0
00001716  6B12                    1251      bmi.s   .h2i_err        * quit if char is >'9' and <'A'
00001718                          1252  
00001718  0C00 000F               1253      cmpi.b  #15,d0
0000171C  6E0C                    1254      bgt.s   .h2i_err        * quit if char is >'F'
0000171E                          1255  
0000171E                          1256  .h2i_2:
0000171E  E98A                    1257      lsl.l   #4, d2
00001720  8400                    1258      or.b    d0, d2          * insert the new digit
00001722                          1259  
00001722  5301                    1260      subq.b  #1, d1          * decrement the digit count
00001724  66D0                    1261      bne.s   .h2i_1          * go back for another digit?
00001726                          1262  
00001726                          1263  .h2i_x:
00001726  2002                    1264      move.l  d2,d0           * put the answer back into D0
00001728                          1265  *   move.l  (SP)+,d2        * restore D2
00001728  4E75                    1266      rts
0000172A                          1267  
0000172A                          1268  .h2i_err:
0000172A                          1269  *   move.l  (SP)+,d2        * restore D2
0000172A  003C 0001               1270      ori.b   #1,CCR          * set the CARRY flag to signal an error
0000172E  4E75                    1271      rts
00001730                          1272  
00001730                          1273  *--------------------------------------------------------------------------
00001730                          1274  * Read in an ASCII-HEX number with echo back
00001730                          1275  *
00001730                          1276  * D2 = Value to return if no digits read in
00001730                          1277  * D1 = Max no of ASCII digits to read in
00001730                          1278  * D0 = Result
00001730                          1279  * Carry flag set if an error occurs / not ASCII-HEX digit
00001730                          1280  *--------------------------------------------------------------------------
00001730                          1281  hexToIntEcho:
00001730                          1282  *   move.l  d2,-(SP)        * save D2
00001730                          1283  *   clr.l   d2              * D2 used to accumulate the final value
00001730                          1284  .h2i_1:
00001730  6100 019E               1285      bsr.w   getc            * get a character
00001734  6100 0188               1286      bsr.w   putc            * echo it back
00001738  6198                    1287      bsr.s   chToUpper       * convert to upper case if needed
0000173A                          1288  
0000173A  0C00 000A               1289      cmpi.b  #10,d0          * finish if it's CR or LF
0000173E  6724                    1290      beq.s   .h2i_x
00001740  0C00 000D               1291      cmpi.b  #13,d0
00001744  671E                    1292      beq.s   .h2i_x
00001746                          1293      
00001746  0400 0030               1294      subi.b  #'0',d0
0000174A  6B1C                    1295      bmi.s   .h2i_err        * quit if char is less than '0'
0000174C                          1296  
0000174C  0C00 0009               1297      cmpi.b  #9,d0
00001750  6F0A                    1298      ble.s   .h2i_2          * is it <= 9
00001752                          1299      
00001752  5F00                    1300      subi.b  #7,d0
00001754  6B12                    1301      bmi.s   .h2i_err        * quit if char is >'9' and <'A'
00001756                          1302  
00001756  0C00 000F               1303      cmpi.b  #15,d0
0000175A  6E0C                    1304      bgt.s   .h2i_err        * quit if char is >'F'
0000175C                          1305  
0000175C                          1306  .h2i_2:
0000175C  E98A                    1307      lsl.l   #4, d2
0000175E  8400                    1308      or.b    d0, d2          * insert the new digit
00001760                          1309  
00001760  5301                    1310      subq.b  #1, d1          * decrement the digit count
00001762  66CC                    1311      bne.s   .h2i_1          * go back for another digit?
00001764                          1312  
00001764                          1313  .h2i_x:
00001764  2002                    1314      move.l  d2,d0           * put the answer back into D0
00001766                          1315  *   move.l  (SP)+,d2        * restore D2
00001766  4E75                    1316      rts
00001768                          1317  
00001768                          1318  .h2i_err:
00001768                          1319  *   move.l  (SP)+,d2        * restore D2
00001768  003C 0001               1320      ori.b   #1,CCR          * set the CARRY flag to signal an error
0000176C  4E75                    1321      rts
0000176E                          1322  
0000176E                          1323  *==============================================================================
0000176E                          1324  *==============================================================================
0000176E                          1325  * EASy68K TRAP #15 routines
0000176E                          1326  *==============================================================================
0000176E                          1327  *==============================================================================
0000176E                          1328  
0000176E                          1329  *------------------------------------------------------------------------------
0000176E                          1330  * This is the jump table for the TRAP #15 tasks - not all tasks are supported!
0000176E                          1331  *------------------------------------------------------------------------------
0000176E                          1332  
0000176E                          1333  easy68kTaskTable:
0000176E  6000 0088               1334      bra.w   easyTask0 
00001772  6000 009C               1335      bra.w   easyTask1 
00001776  6000 005E               1336      bra.w   easyTask2 
0000177A  6000 005A               1337      bra.w   easyTask3 
0000177E  6000 0056               1338      bra.w   easyTask4 
00001782  6000 00A0               1339      bra.w   easyTask5 
00001786  6000 00A4               1340      bra.w   easyTask6 
0000178A  6000 004A               1341      bra.w   easyTask7 
0000178E  6000 0046               1342      bra.w   easyTask8 
00001792  6000 0042               1343      bra.w   easyTask9 
00001796  6000 003E               1344      bra.w   easyTask10
0000179A  6000 003A               1345      bra.w   easyTask11
0000179E  6000 0036               1346      bra.w   easyTask12
000017A2  6000 0090               1347      bra.w   easyTask13
000017A6  6000 009C               1348      bra.w   easyTask14
000017AA  6000 002A               1349      bra.w   easyTask15
000017AE  6000 0026               1350      bra.w   easyTask16
000017B2  6000 0022               1351      bra.w   easyTask17
000017B6  6000 001E               1352      bra.w   easyTask18
000017BA  6000 001A               1353      bra.w   easyTask19
000017BE  6000 0016               1354      bra.w   easyTask20
000017C2  6000 0012               1355      bra.w   easyTask21
000017C6  6000 000E               1356      bra.w   easyTask22
000017CA  6000 000A               1357      bra.w   easyTask23
000017CE  6000 0006               1358      bra.w   easyTask24
000017D2  6000 0002               1359      bra.w   easyTask25
000017D6                          1360  
000017D6                          1361  *------------------------------------------------------------------------------
000017D6                          1362  * These are the EASy68K tasks not yet implemented
000017D6                          1363  * The required task number is in D0
000017D6                          1364  * Display a message and stop in an endless loop.
000017D6                          1365  *------------------------------------------------------------------------------
000017D6                          1366  
000017D6                          1367  easyTask2: 
000017D6                          1368  easyTask3:
000017D6                          1369  easyTask4:   
000017D6                          1370  easyTask7: 
000017D6                          1371  easyTask8: 
000017D6                          1372  easyTask9: 
000017D6                          1373  easyTask10:
000017D6                          1374  easyTask11:
000017D6                          1375  easyTask12:
000017D6                          1376  easyTask15:
000017D6                          1377  easyTask16:
000017D6                          1378  easyTask17:
000017D6                          1379  easyTask18:
000017D6                          1380  easyTask19:
000017D6                          1381  easyTask20:
000017D6                          1382  easyTask21:
000017D6                          1383  easyTask22:
000017D6                          1384  easyTask23:
000017D6                          1385  easyTask24:
000017D6                          1386  easyTask25:
000017D6                          1387  easyTaskUnsupported:
000017D6  1200                    1388      move.b  d0,d1           ; copy the task number into D1
000017D8  41FA 030F               1389      lea     strEasyTask1(PC), a0
000017DC  6100 00D6               1390      bsr.w   putString
000017E0  82FC 000A               1391      divu    #10,d1          ; divide task number by 10
000017E4  6100 00B0               1392      bsr.w   writeNibble     ; output the 10's digit
000017E8  4841                    1393      swap    d1
000017EA  6100 00AA               1394      bsr.w   writeNibble     ; output the 1's digit
000017EE  41FA 031A               1395      lea     strEasyTask2(PC), a0
000017F2  6100 00C0               1396      bsr.w   putString
000017F6                          1397  .infloop:
000017F6  60FE                    1398      bra.s   .infloop
000017F8                          1399  
000017F8                          1400  *------------------------------------------------------------------------------
000017F8                          1401  * EASy68K TRAP #15 - Task 0
000017F8                          1402  * Display n characters of string at (A1), n is D1.W (stops on NULL or max 255) with CR, LF.
000017F8                          1403  *------------------------------------------------------------------------------
000017F8                          1404  easyTask0:
000017F8  0241 00FF               1405      andi.w  #$00FF,d1   * DBRA works on a WORD so make sure upper byte is zero
000017FC  5301                    1406      sub.b   #1,d1       * DBRA requires 1 less than actual number
000017FE                          1407  .loop:
000017FE  1019                    1408      move.b  (a1)+, d0    * Read in character
00001800  6708                    1409      beq.s   .end         * Check for the null
00001802                          1410      
00001802  6100 00BA               1411      bsr.w   putc         * Otherwise write the character
00001806  51C9 FFF6               1412      dbra    d1,.loop     * And continue
0000180A                          1413  .end:
0000180A  6100 00A4               1414      bsr.w   putCRLF     * append CR & LF
0000180E  4E75                    1415      rts
00001810                          1416  
00001810                          1417  *------------------------------------------------------------------------------
00001810                          1418  * EASy68K TRAP #15 - Task 1
00001810                          1419  * Display n characters of string at (A1), n is D1.W (stops on NULL or max 255) without CR, LF.
00001810                          1420  *------------------------------------------------------------------------------
00001810                          1421  easyTask1:
00001810  0241 00FF               1422      andi.w  #$00FF,d1   * DBRA works on a WORD so make sure upper byte is zero
00001814  5301                    1423      sub.b   #1,d1       * DBRA requires 1 less than actual number
00001816                          1424  .loop:
00001816  1019                    1425      move.b  (a1)+, d0    * Read in character
00001818  6708                    1426      beq.s   .end         * Check for the null
0000181A                          1427      
0000181A  6100 00A2               1428      bsr.w   putc         * Otherwise write the character
0000181E  51C9 FFF6               1429      dbra    d1,.loop     * And continue
00001822                          1430  .end:
00001822  4E75                    1431      rts
00001824                          1432  
00001824                          1433  *------------------------------------------------------------------------------
00001824                          1434  * EASy68K TRAP #15 - Task 5
00001824                          1435  * Read single ASCII character from the keyboard into D1.B. 
00001824                          1436  *------------------------------------------------------------------------------
00001824                          1437  easyTask5:
00001824  6100 00AA               1438      bsr.w   getc        * wait for char - returned in D0
00001828  1200                    1439      move.b  d0,d1       * move the char into D1
0000182A  4E75                    1440      rts
0000182C                          1441      
0000182C                          1442  *------------------------------------------------------------------------------
0000182C                          1443  * EASy68K TRAP #15 - Task 6
0000182C                          1444  * Display single ASCII character in D1.B.   
0000182C                          1445  *------------------------------------------------------------------------------
0000182C                          1446  easyTask6:
0000182C  1001                    1447      move.b  d1,d0       * move the char into D0
0000182E  6100 008E               1448      bsr.w   putc        * output the char
00001832  4E75                    1449      rts
00001834                          1450  
00001834                          1451  *------------------------------------------------------------------------------
00001834                          1452  * EASy68K TRAP #15 - Task 13
00001834                          1453  * Display the NULL terminated string at (A1) with CR, LF.
00001834                          1454  *------------------------------------------------------------------------------
00001834                          1455  easyTask13:
00001834                          1456  .loop:
00001834  1019                    1457      move.b  (a1)+, d0    * Read in character
00001836  6706                    1458      beq.s   .end         * Check for the null
00001838                          1459      
00001838  6100 0084               1460      bsr.w   putc         * Otherwise write the character
0000183C  60F6                    1461      bra.s   .loop        * And continue
0000183E                          1462  .end:
0000183E  6100 0070               1463      bsr.w   putCRLF     * append CR & LF
00001842  4E75                    1464      rts
00001844                          1465  
00001844                          1466  *------------------------------------------------------------------------------
00001844                          1467  * EASy68K TRAP #15 - Task 14
00001844                          1468  * Display the NULL terminated string pointed to by (A1).
00001844                          1469  *------------------------------------------------------------------------------
00001844                          1470  easyTask14:
00001844                          1471  .loop:
00001844  1019                    1472      move.b  (a1)+, d0    * Read in character
00001846  6706                    1473      beq.s   .end         * Check for the null
00001848                          1474      
00001848  6100 0074               1475      bsr.w   putc         * Otherwise write the character
0000184C  60F6                    1476      bra.s   .loop        * And continue
0000184E                          1477  .end:
0000184E  4E75                    1478      rts
00001850                          1479  
00001850                          1480  *------------------------------------------------------------------------------
00001850                          1481  * This is the entry point for the TRAP #15 handler that gets called when any
00001850                          1482  * TRAP #15 services are required. Only a few tasks are implemented.
00001850                          1483  * Unimplemented tasks will produce an error message.
00001850                          1484  *------------------------------------------------------------------------------
00001850                          1485  easy68kTrap15:
00001850  48E7 10A0               1486      movem.l d3/a0/a2,-(sp)
00001854  45FA FF18               1487      lea     easy68kTaskTable(PC),a2
00001858  B03C 0019               1488      cmp.b   #25,d0          ; is task number greater than 25?
0000185C  6E00 FF78               1489      bgt     easyTaskUnsupported
00001860                          1490      
00001860  4283                    1491      clr.l   d3
00001862  1600                    1492      move.b  d0,d3           ; task number into D3
00001864  E58B                    1493      lsl.l   #2,d3           ; convert task number into longword offset
00001866  4EB2 3000               1494      jsr     (a2,d3)         ; jump to the specific task handler
0000186A                          1495      
0000186A  4CDF 0508               1496      movem.l (sp)+,d3/a0/a2
0000186E  4E73                    1497      rte
00001870                          1498      
00001870                          1499  *==============================================================================
00001870                          1500  * These are the various printing rouitnes that handle displaying of bytes,
00001870                          1501  * words, long words and 24-bit values as ASCII hexadecimal text. The routines
00001870                          1502  * must be kept in this order as program flow is meant to fall out of one
00001870                          1503  * routine and into the next, often without a return statement.
00001870                          1504  *==============================================================================
00001870                          1505  
00001870                          1506  *------------------------------------------------------------------------------
00001870                          1507  * Output a 32-bit address as 8 ASCII hexadecimal digits
00001870                          1508  * D0 holds the 32-bit address
00001870                          1509  *------------------------------------------------------------------------------
00001870                          1510  writeAddr32:
00001870  2F00                    1511      move.l  d0,-(sp)    ; save D0 first
00001872  E098                    1512      ror.l   #8,d0
00001874  E098                    1513      ror.l   #8,d0
00001876  610E                    1514      bsr.s   writeWord   ; write bits 16..31
00001878  201F                    1515      move.l  (sp)+,d0    ; restore D0
0000187A  600A                    1516      bra.s   writeWord
0000187C                          1517      
0000187C                          1518  *------------------------------------------------------------------------------
0000187C                          1519  * Output a 24-bit address as 6 ASCII hexadecimal digits
0000187C                          1520  * D0 holds the address in bits 0..23
0000187C                          1521  * NOTE: the writeWord function must be directly after this function
0000187C                          1522  *------------------------------------------------------------------------------
0000187C                          1523  writeAddr24:
0000187C  2F00                    1524      move.l  d0,-(sp)    ; save D0 first
0000187E  E098                    1525      ror.l   #8,d0
00001880  E098                    1526      ror.l   #8,d0
00001882  610A                    1527      bsr.s   writeByte   ; write bits 16..23
00001884  201F                    1528      move.l  (sp)+,d0    ; restore D0
00001886                          1529      
00001886                          1530  *------------------------------------------------------------------------------
00001886                          1531  * Output a word as 4 ASCII hexadecimal digits
00001886                          1532  * D0 holds the word in bits 0..15
00001886                          1533  * NOTE: the writeByte function must be directly after this function
00001886                          1534  *------------------------------------------------------------------------------
00001886                          1535  writeWord:
00001886  3F00                    1536      move.w  d0,-(sp)    ; save D0 first
00001888  E058                    1537      ror.w   #8,d0       ; get upper byte (0 => shift 8 times)
0000188A  6102                    1538      bsr.s   writeByte
0000188C  301F                    1539      move.w  (sp)+,d0    ; restore D0
0000188E                          1540  
0000188E                          1541  *------------------------------------------------------------------------------
0000188E                          1542  * Output a byte as 2 ASCII hexadecimal digits
0000188E                          1543  * D0 holds the byte in bits 0..7
0000188E                          1544  * NOTE: the writeNibble function must be directly after this function
0000188E                          1545  *------------------------------------------------------------------------------
0000188E                          1546  writeByte:
0000188E  1F00                    1547      move.b  d0,-(sp)    ; save D0 first
00001890  E818                    1548      ror.b   #4,d0       ; get upper nibble
00001892  6102                    1549      bsr.s   writeNibble
00001894  101F                    1550      move.b  (sp)+,d0    ; restore D0
00001896                          1551      
00001896                          1552  *------------------------------------------------------------------------------
00001896                          1553  * Output 4 bits as an ASCII hexadecimal digit
00001896                          1554  * D0 holds the nibble in bits 0..3
00001896                          1555  *------------------------------------------------------------------------------
00001896                          1556  writeNibble:
00001896  1F00                    1557      move.b  d0,-(sp)    ; save D0 first
00001898  0200 000F               1558      andi.b  #$0F,d0     ; make sure we only have the lower 4 bits
0000189C  0C00 000A               1559      cmpi.b  #10,d0      ; compare D0 to 10
000018A0  6502                    1560      bcs.b   .wn1        ; less than 10 so don't add 7
000018A2  5E00                    1561      addi.b  #07,d0      ; add 7
000018A4                          1562  .wn1:
000018A4  0600 0030               1563      addi.b  #'0',d0     ; add ASCII code for char zero
000018A8  6100 0014               1564      bsr     putc        ; write the ASCII digit out
000018AC  101F                    1565      move.b  (sp)+,d0    ; restore D0
000018AE  4E75                    1566      rts
000018B0                          1567  
000018B0                          1568  endc
000018B0                          1569  
000018B0                          1570  *------------------------------------------------------------------------------
000018B0                          1571  * Prints a newline (CR, LF)
000018B0                          1572  * NOTE: the putString function must follow this function
000018B0                          1573  *------------------------------------------------------------------------------
000018B0                          1574  putCRLF:
000018B0  41FA 021A               1575      lea     strNewline(PC), a0
000018B4                          1576  
000018B4                          1577  *------------------------------------------------------------------------------
000018B4                          1578  * Print a null terminated string
000018B4                          1579  * A0 holds the address of the first character of the null terminated string
000018B4                          1580  *------------------------------------------------------------------------------
000018B4                          1581  putString:
000018B4                          1582  .loop:
000018B4  1018                    1583      move.b  (a0)+, d0    * Read in character
000018B6  6704                    1584      beq.s   .end         * Check for the null
000018B8                          1585      
000018B8  6104                    1586      bsr.s   putc         * Otherwise write the character
000018BA  60F8                    1587      bra.s   .loop        * And continue
000018BC                          1588  .end:
000018BC  4E75                    1589      rts
000018BE                          1590  
000018BE                          1591  
000018BE                          1592  *------------------------------------------------------------------------------
000018BE                          1593  * Write a character to UART Port A, blocking if UART is not ready
000018BE                          1594  * D0 = char to send
000018BE                          1595  *------------------------------------------------------------------------------
000018BE                          1596  putc:
000018BE                 TRUE     1597      ifgt USE_REAL_UART
000018BE                          1598      ; using real hardware
000018BE                          1599      
000018BE  0839 0002 00F00183      1600      btst.b    #2, SRA      * Check if transmitter ready bit is set
000018C6  67F6                    1601      beq     putc     
000018C8  13C0 00F00187           1602      move.b  d0, TBA      * Transmit Character
000018CE  4E75                    1603      rts
000018D0                          1604      
000018D0                          1605      endc
000018D0                          1606      
000018D0                 FALSE    1607      ifeq USE_REAL_UART
000018D0                          1608      ; using Sim68K I/O window
000018D0                          1609      endc
000018D0                          1610  
000018D0                 FALSE    1611      iflt USE_REAL_UART
000018D0                          1612      ; using Sim68K COM port
000018D0                          1613      endc
000018D0                          1614  
000018D0                          1615  *------------------------------------------------------------------------------
000018D0                          1616  * Read a character from UART Port A - blocking call so will wait for character
000018D0                          1617  * D0 = recevied char
000018D0                          1618  *------------------------------------------------------------------------------
000018D0                          1619  getc:
000018D0                 TRUE     1620      ifgt USE_REAL_UART
000018D0                          1621      ; using real hardware
000018D0                          1622  
000018D0  1039 00F00183           1623      move.b  SRA,d0          * get DUART status register
000018D6  0200 0001               1624      andi.b  #$01,d0         * mask all but the RxRDY bit
000018DA  67F4                    1625      beq.s   getc
000018DC                          1626  
000018DC  4E71                    1627      nop
000018DE  4E71                    1628      nop
000018E0  4E71                    1629      nop
000018E2  4E71                    1630      nop
000018E4  1039 00F00187           1631      move.b  RBA, d0      * Read Character into D0
000018EA  4E75                    1632      rts
000018EC                          1633  
000018EC                          1634      endc
000018EC                          1635      
000018EC                 FALSE    1636      ifeq USE_REAL_UART
000018EC                          1637      ; using Sim68K I/O window
000018EC                          1638      endc
000018EC                          1639  
000018EC                 FALSE    1640      iflt USE_REAL_UART
000018EC                          1641      ; using Sim68K COM port
000018EC                          1642      ; got a character?
000018EC                          1643      endc
000018EC                          1644  
000018EC                          1645  *------------------------------------------------------------------------------
000018EC                          1646  * String constants
000018EC                          1647  *------------------------------------------------------------------------------
000018EC                          1648  strBanner1:
000018EC= 0A 0D                   1649      dc.b 10,13
000018EE= 53 69 6D 70 6C 65 ...   1650      dc.b 'Simple RCBus 68000 ROM Monitor v1.0',10,13
00001913= 52 4F 4D 3A 20 30 ...   1651      dc.b 'ROM: 0x000000 .. 0x01FFFF',10,13
0000192E= 52 41 4D 3A 20 30 ...   1652      dc.b 'RAM: 0x100000 .. 0x1FFFFF',10,13,0
0000194A                          1653  strCommands:
0000194A= 0A 0D 43 6F 6D 6D ...   1654      dc.b 10,13,'Commands: ',10,13
00001958= 44 6E 6E 6E 6E 20 ...   1655      dc.b 'Dnnnn : Display 256 bytes of memory starting at address nnnn',10,13
00001996= 47 6E 6E 6E 6E 20 ...   1656      dc.b 'Gnnnn : Execute code starting at address nnnn',10,13
000019C5= 49 61 61 20 20 20 ...   1657      dc.b 'Iaa   : Read a byte from address aa in I/O space',10,13
000019F7= 4D 6E 6E 6E 6E 20 ...   1658      dc.b 'Mnnnn : Modify memory starting at address nnnn',10,13
00001A27= 4F 61 61 62 62 20 ...   1659      dc.b 'Oaabb : Write byte bb to address aa in I/O space',10,13
00001A59= 53 31 78 78 78 20 ...   1660      dc.b 'S1xxx : Download S1 Hex Record ',10,13          
00001A7A= 53 32 78 78 78 20 ...   1661      dc.b 'S2xxx : Download S2 Hex Record ',10,13    
00001A9B= 3F 20 20 20 20 20 ...   1662      dc.b '?     : Display this help',10,13
00001AB6= 00                      1663      dc.b 0
00001AB7                          1664  strPrompt:
00001AB7= 3E 20 00                1665      dc.b '> ',0
00001ABA                          1666  strUnkCmd:
00001ABA= 55 6E 6B 6E 6F 77 ...   1667      dc.b 'Unknown Command: ',0
00001ACC                          1668  strNewline:
00001ACC= 0A 0D 00                1669      dc.b 10,13,0
00001ACF                          1670  strColonSpace:
00001ACF= 3A 20 00                1671      dc.b ': ',0
00001AD2                          1672  strUninitInt:
00001AD2= 55 6E 68 61 6E 64 ...   1673      dc.b 'Unhandled interrupt.',10,13,0
00001AE9                          1674  strEasyTask1:
00001AE9= 0A 0D 53 54 4F 50 ...   1675      dc.b    10,13,'STOP: EASy68K TRAP #15 - Task ',0
00001B0A                          1676  strEasyTask2:
00001B0A= 20 6E 6F 74 20 79 ...   1677      dc.b    ' not yet implemented',10,13,0
00001B21                          1678      
00001B21                 FALSE    1679      iflt USE_REAL_UART
00001B21                          1680      ; using Sim68K COM port
00001B21                          1681  * PORTPARAMS dc.l    0         ; 9600,8,N,1
00001B21                          1682      endc
00001B21                          1683  
00001B21                          1684  *------------------------------------------------------------------------------
00001B21                          1685  * Monitor variables
00001B21                          1686  *------------------------------------------------------------------------------
001FFF00                          1687      ORG     STACK_START
001FFF00                          1688  msgASCIIDump:
001FFF00                          1689      ds.b 20
001FFF14                          1690  serBuff:   
001FFF14                          1691      ds.b    8
001FFF1C                          1692      
001FFF1C                          1693      END    START            * last line of source

No errors detected
No warnings generated


SYMBOL TABLE INFORMATION
Symbol-name         Value
-------------------------
ACR                 F00189
AEMSG1              B62
AEMSG2              BA6
AV1MSG              BD8
AV2MSG              C14
AV3MSG              C50
AV4MSG              C8C
AV5MSG              CC8
AV6MSG              D04
AV7MSG              D40
BAUD_1200           66
BAUD_2400           88
BAUD_38400          CC
BAUD_4800           99
BAUD_9600           BB
BAUD_RATE           CC
BCNT                F0019D
BEMSG1              D7C
BEMSG2              DBB
CHTOUPPER           16D2
CHTOUPPER:DONE      16E2
CIMSG               DED
CMDDISPMEMORY       1460
CMDDOWNLOAD         158C
CMDDOWNLOAD:CDL_1   15FA
CMDDOWNLOAD:CDL_2   1610
CMDDOWNLOAD:CDL_EOL  1638
CMDDOWNLOAD:CDL_EOL89  164A
CMDDOWNLOAD:CDL_S1  15B0
CMDDOWNLOAD:CDL_S2  15D4
CMDDOWNLOAD:CDL_X   162C
CMDHELP             1660
CMDIOREAD           14A2
CMDIOWRITE          1542
CMDMODIFYMEMORY     14E4
CMDMODIFYMEMORY:CMM_1  1506
CMDMODIFYMEMORY:CMM_2  153A
CMDRUN              1482
CR                  D
CRA                 F00185
CRB                 F00195
CSRA                F00183
CSRB                F00193
DUART_BASE          F00180
DUMPRAM             166C
DUMPRAM:DR_1        167A
DUMPRAM:DR_2        1692
EASY68KTASKTABLE    176E
EASY68KTRAP15       1850
EASYTASK0           17F8
EASYTASK0:END       180A
EASYTASK0:LOOP      17FE
EASYTASK1           1810
EASYTASK10          17D6
EASYTASK11          17D6
EASYTASK12          17D6
EASYTASK13          1834
EASYTASK13:END      183E
EASYTASK13:LOOP     1834
EASYTASK14          1844
EASYTASK14:END      184E
EASYTASK14:LOOP     1844
EASYTASK15          17D6
EASYTASK16          17D6
EASYTASK17          17D6
EASYTASK18          17D6
EASYTASK19          17D6
EASYTASK1:END       1822
EASYTASK1:LOOP      1816
EASYTASK2           17D6
EASYTASK20          17D6
EASYTASK21          17D6
EASYTASK22          17D6
EASYTASK23          17D6
EASYTASK24          17D6
EASYTASK25          17D6
EASYTASK3           17D6
EASYTASK4           17D6
EASYTASK5           1824
EASYTASK6           182C
EASYTASK7           17D6
EASYTASK8           17D6
EASYTASK9           17D6
EASYTASKUNSUPPORTED  17D6
EASYTASKUNSUPPORTED:INFLOOP  17F6
ECNT                F0019F
ENDC                18B0
GETC                18D0
HANDLEADDRERR       994
HANDLEAV1           A34
HANDLEAV2           A40
HANDLEAV3           A4C
HANDLEAV4           A58
HANDLEAV5           A64
HANDLEAV6           A70
HANDLEAV7           A7C
HANDLEBUSERR        978
HANDLECHKINST       9C8
HANDLECLEANUP       B54
HANDLECLEANUP:INFLOOP  B60
HANDLEILLINST       9B0
HANDLELINEA         9F8
HANDLELINEF         A04
HANDLEPRIV          9E0
HANDLERES1          A10
HANDLERES10         A10
HANDLERES11         A10
HANDLERES2          A10
HANDLERES3          A10
HANDLERES4          A10
HANDLERES5          A10
HANDLERES6          A10
HANDLERES7          A10
HANDLERES8          A10
HANDLERES9          A10
HANDLESPUR          A28
HANDLETRACE         9EC
HANDLETRAP0         A88
HANDLETRAP1         A94
HANDLETRAP10        B00
HANDLETRAP11        B0C
HANDLETRAP12        B18
HANDLETRAP13        B24
HANDLETRAP14        B30
HANDLETRAP15        B3C
HANDLETRAP2         AA0
HANDLETRAP3         AAC
HANDLETRAP4         AB8
HANDLETRAP5         AC4
HANDLETRAP6         AD0
HANDLETRAP7         ADC
HANDLETRAP8         AE8
HANDLETRAP9         AF4
HANDLETRAPV         9D4
HANDLEUNINIT        A1C
HANDLEUNUSED        B48
HANDLEZERODIV       9BC
HEXTOINT            16F6
HEXTOINT:H2I_1      16F6
HEXTOINT:H2I_2      171E
HEXTOINT:H2I_ERR    172A
HEXTOINT:H2I_X      1726
HEXTOINTECHO        1730
HEXTOINTECHO:H2I_1  1730
HEXTOINTECHO:H2I_2  175C
HEXTOINTECHO:H2I_ERR  1768
HEXTOINTECHO:H2I_X  1764
IIMSG               E1A
IMR                 F0018B
IO_BASE             F00000
IPR                 F0019B
ISR                 F0018B
IVR                 F00199
JMPADDRERR          408
JMPAV1              4B8
JMPAV2              4C0
JMPAV3              4C8
JMPAV4              4D0
JMPAV5              4D8
JMPAV6              4E0
JMPAV7              4E8
JMPBUSERR           400
JMPCHKINST          420
JMPILLINST          410
JMPLINEA            440
JMPLINEF            448
JMPPRIV             430
JMPRES1             450
JMPRES10            4A0
JMPRES11            4A8
JMPRES2             458
JMPRES3             460
JMPRES4             470
JMPRES5             478
JMPRES6             480
JMPRES7             488
JMPRES8             490
JMPRES9             498
JMPSPUR             4B0
JMPTRACE            438
JMPTRAP0            4F0
JMPTRAP1            4F8
JMPTRAP10           540
JMPTRAP11           548
JMPTRAP12           550
JMPTRAP13           558
JMPTRAP14           560
JMPTRAP15           568
JMPTRAP2            500
JMPTRAP3            508
JMPTRAP4            510
JMPTRAP5            518
JMPTRAP6            520
JMPTRAP7            528
JMPTRAP8            530
JMPTRAP9            538
JMPTRAPV            428
JMPUNINIT           468
JMPUNUSED           570
JMPZERODIV          418
LAMSG               E55
LF                  A
LFMSG               E85
MAKEPRINTABLE       16E4
MAKEPRINTABLE:MP_1  16F0
MAKEPRINTABLE:MP_X  16F4
MONLOOP             13F6
MONLOOP_CRLF        145A
MONLOOP_NP          13FE
MONSTART            13E6
MRA                 F00181
MRB                 F00191
MSGASCIIDUMP        1FFF00
OPCR                F0019B
PUTC                18BE
PUTCRLF             18B0
PUTSTRING           18B4
PUTSTRING:END       18BC
PUTSTRING:LOOP      18B4
PVMSG               EB5
RAMVECJUMP          0
RAM_BASE            100000
RAM_LEN             100000
RBA                 F00187
RBB                 F00197
RIMSG               EF2
ROM2RAMIVT          578
ROM_BASE            0
ROPR                F0019F
SERBUFF             1FFF14
SIMSG               F24
SOPR                F0019D
SRA                 F00183
SRB                 F00193
STACK_START         1FFF00
START               1378
START:COPY          1390
STRBANNER1          18EC
STRCOLONSPACE       1ACF
STRCOMMANDS         194A
STREASYTASK1        1AE9
STREASYTASK2        1B0A
STRNEWLINE          1ACC
STRPROMPT           1AB7
STRUNINITINT        1AD2
STRUNKCMD           1ABA
TBA                 F00187
TBB                 F00197
TR0MSG              F8F
TR10MSG             1179
TR11MSG             11AB
TR12MSG             11DD
TR13MSG             120F
TR14MSG             1241
TR15MSG             1273
TR1MSG              FC0
TR2MSG              FF1
TR3MSG              1022
TR4MSG              1053
TR5MSG              1084
TR6MSG              10B5
TR7MSG              10E6
TR8MSG              1117
TR9MSG              1148
TRMSG               F60
TVMSG               12A5
UIMSG               12D4
USERMSG             1315
USE_REAL_UART       1
VEC_BASE            100000
WRITEADDR24         187C
WRITEADDR32         1870
WRITEBYTE           188E
WRITENIBBLE         1896
WRITENIBBLE:WN1     18A4
WRITEWORD           1886
ZDMSG               1343
